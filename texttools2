<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TextTools《ﾃｷｽﾄﾂｰﾙｽﾞ》- テキスト処理ツール集</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/encoding-japanese/2.0.0/encoding.min.js"></script>

<link id="favicon" rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCI+CiAgPGRlZnM+CiAgICA8bGluZWFyR3JhZGllbnQgaWQ9InRleHRHcmFkIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIxMDAlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzAwNzdjYyIvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwMGZmY2MiLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgPC9kZWZzPgogIDxyZWN0IHdpZHRoPSI2NCIgaGVpZ2h0PSI2NCIgcng9IjEyIiBmaWxsPSIjZjVmNWY3Ii8+CiAgPHRleHQgeD0iMzIiIHk9IjQ2IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIgogICAgICAgIGZvbnQtZmFtaWx5PSJCYWhuc2NocmlmdCwgJ1NlZ29lIFVJJywgc2Fucy1zZXJpZiIKICAgICAgICBmb250LXNpemU9IjM2IiBmb250LXdlaWdodD0iNTAwIgogICAgICAgIGZpbGw9InVybCgjdGV4dEdyYWQpIj5UVDwvdGV4dD4KPC9zdmc+Cg==">

<style>
:root {
  --bg: #f5f5f7;
  --surface: #ffffff;
  --surface-raised: #f0f0f2;
  --border: #d0d0d8;
  --text: #1a1a2e;
  --text-muted: #666680;
  --accent: #0077cc;
  --accent-glow: rgba(0, 119, 204, 0.1);
  --delete: #d63031;
  --delete-bg: rgba(214, 48, 49, 0.12);
  --insert: #00a86b;
  --insert-bg: rgba(0, 168, 107, 0.12);
  --change: #e67e22;
  --change-bg: rgba(230, 126, 34, 0.12);
  --grid-color: rgba(0, 119, 204, 0.05);
}

[data-theme="dark"] {
  --bg: #0a0a0f;
  --surface: #12121a;
  --surface-raised: #1a1a26;
  --border: #2a2a3a;
  --text: #e8e8f0;
  --text-muted: #8888a0;
  --accent: #00d4ff;
  --accent-glow: rgba(0, 212, 255, 0.15);
  --delete: #ff6b8a;
  --delete-bg: rgba(255, 107, 138, 0.15);
  --insert: #7dffb3;
  --insert-bg: rgba(125, 255, 179, 0.15);
  --change: #ffcc4d;
  --change-bg: rgba(255, 204, 77, 0.15);
  --grid-color: rgba(0, 212, 255, 0.03);
}

[data-theme="sepia"] {
  --bg: #f4ecd8;
  --surface: #faf6eb;
  --surface-raised: #efe9d9;
  --border: #d4c9a8;
  --text: #433422;
  --text-muted: #7a6a50;
  --accent: #8b4513;
  --accent-glow: rgba(139, 69, 19, 0.1);
  --delete: #a0522d;
  --delete-bg: rgba(160, 82, 45, 0.15);
  --insert: #228b22;
  --insert-bg: rgba(34, 139, 34, 0.15);
  --change: #b8860b;
  --change-bg: rgba(184, 134, 11, 0.15);
  --grid-color: rgba(139, 69, 19, 0.04);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  line-height: 1.6;
}

body::before {
  content: '';
  position: fixed;
  inset: 0;
  background-image: 
    linear-gradient(var(--grid-color) 1px, transparent 1px),
    linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
  background-size: 50px 50px;
  pointer-events: none;
  z-index: -1;
}

.container {
  max-width: 1400px;
  margin: 0 auto;
  padding: 24px;
}

header {
  text-align: center;
  margin-bottom: 24px;
  animation: fadeInDown 0.6s ease-out;
}

@keyframes fadeInDown {
  from { opacity: 0; transform: translateY(-20px); }
  to { opacity: 1; transform: translateY(0); }
}

h1 {
  font-size: 1.8rem;
  font-weight: 700;
  letter-spacing: -0.02em;
  margin-bottom: 8px;
}

h1 span.tool-name {
  background: linear-gradient(135deg, var(--accent), #00ffcc);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

h1 span.katakana {
  font-size: 1rem;
  color: var(--text-muted);
  -webkit-text-fill-color: var(--text-muted);
  margin-left: 8px;
  font-weight: 400;
}

.tagline {
  color: var(--text-muted);
  font-size: 0.9rem;
}

/* Theme selector */
.theme-selector {
  display: flex;
  justify-content: center;
  gap: 8px;
  margin-bottom: 24px;
}

.theme-btn {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  border: 2px solid var(--border);
  cursor: pointer;
  transition: all 0.2s;
  padding: 0;
}

.theme-btn:hover { transform: scale(1.1); }
.theme-btn.active {
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-glow);
}

.theme-btn.dark { background: #0a0a0f; }
.theme-btn.light { background: #f5f5f7; }
.theme-btn.sepia { background: #f4ecd8; }

/* Tool selector tabs */
.tool-tabs {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-bottom: 24px;
  justify-content: center;
  animation: fadeIn 0.6s ease-out 0.1s both;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.tool-tab {
  padding: 10px 18px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  cursor: pointer;
  font-size: 0.85rem;
  font-weight: 500;
  color: var(--text-muted);
  transition: all 0.2s;
}

.tool-tab:hover {
  border-color: var(--accent);
  color: var(--text);
}

.tool-tab.active {
  background: var(--accent);
  color: var(--bg);
  border-color: var(--accent);
  box-shadow: 0 4px 15px var(--accent-glow);
}

/* Main layout */
.main-content {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 24px;
  animation: fadeIn 0.6s ease-out 0.2s both;
}

.main-content.full-width {
  grid-template-columns: 1fr;
}

@media (max-width: 900px) {
  .main-content {
    grid-template-columns: 1fr;
  }
}

/* Panels */
.panel {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  overflow: hidden;
}

.panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  background: var(--surface-raised);
  border-bottom: 1px solid var(--border);
}

.panel-title {
  font-size: 0.8rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  gap: 8px;
}

.panel-title::before {
  content: '';
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 2px;
  background: var(--accent);
}

.output-panel .panel-title::before {
  background: linear-gradient(135deg, #00ffcc, #00d4ff);
}

.panel-actions {
  display: flex;
  gap: 6px;
}

.panel-body {
  padding: 16px;
}

textarea {
  width: 100%;
  min-height: 300px;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 12px;
  font-family: 'SF Mono', Consolas, monospace;
  font-size: 0.9rem;
  color: var(--text);
  resize: vertical;
  transition: border-color 0.2s, box-shadow 0.2s;
}

textarea:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-glow);
}

textarea::placeholder {
  color: var(--text-muted);
  opacity: 0.6;
}

/* ドラッグ&ドロップ */
.panel.drag-over {
  border: 2px dashed var(--accent);
  background: var(--accent-glow);
}

.panel.drag-over textarea {
  pointer-events: none;
}

/* Buttons */
button {
  font-family: inherit;
  font-size: 0.8rem;
  font-weight: 500;
  padding: 6px 12px;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-small {
  padding: 4px 10px;
  font-size: 0.75rem;
}

.btn-primary {
  background: var(--accent);
  color: var(--bg);
  border: none;
  box-shadow: 0 2px 10px var(--accent-glow);
}

.btn-primary:hover {
  transform: translateY(-1px);
  filter: brightness(1.1);
}

.btn-secondary {
  background: transparent;
  color: var(--text-muted);
  border: 1px solid var(--border);
}

.btn-secondary:hover {
  border-color: var(--accent);
  color: var(--text);
}

/* Tool options */
.tool-options {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 24px;
  animation: fadeIn 0.6s ease-out 0.15s both;
}

.tool-options-title {
  font-size: 0.9rem;
  font-weight: 600;
  margin-bottom: 16px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.tool-options-title::before {
  content: '⚙';
}

.option-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 12px;
  flex-wrap: wrap;
}

.option-row:last-child {
  margin-bottom: 0;
}

.option-section {
  background: var(--surface-raised);
  border-radius: 8px;
  padding: 12px;
  margin-bottom: 12px;
}

.option-section:last-child {
  margin-bottom: 0;
}

.option-section-title {
  font-size: 0.85rem;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 10px;
}

/* Combination Generator Styles */
.combination-inputs {
  display: flex;
  gap: 8px;
  overflow-x: auto;
  padding: 12px 0;
  align-items: flex-start;
}

.combo-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  flex-shrink: 0;
}

.combo-label {
  font-size: 0.75rem;
  color: var(--text-muted);
  margin-bottom: 6px;
  font-weight: 500;
}

.combo-field {
  width: 80px;
  padding: 8px;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 0.85rem;
  color: var(--text);
  text-align: center;
}

.combo-field:focus {
  outline: none;
  border-color: var(--accent);
}

.combo-textarea {
  width: 150px;
  height: 150px;
  padding: 8px;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  font-family: monospace;
  font-size: 0.8rem;
  color: var(--text);
  resize: vertical;
}

.combo-textarea:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 2px var(--accent-glow);
}

.combo-count {
  font-size: 0.7rem;
  color: var(--text-muted);
  margin-top: 4px;
}

.combo-delim {
  align-self: center;
  margin-top: 20px;
}

.combo-delim .combo-field {
  width: 60px;
}

.combo-prefix, .combo-suffix {
  align-self: center;
  margin-top: 20px;
}

.combo-add {
  align-self: center;
  margin-top: 20px;
}

.combo-actions {
  display: flex;
  align-items: center;
  gap: 16px;
  margin-top: 12px;
  padding-top: 12px;
  border-top: 1px solid var(--border);
}

/* Count Table Styles */
.count-table {
  overflow-x: auto;
}

.count-table table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85rem;
}

.count-table th, .count-table td {
  padding: 12px 16px;
  text-align: left;
  border: 1px solid var(--border);
}

.count-table th {
  background: var(--bg);
  font-weight: 600;
  color: var(--text);
  text-align: center;
}

.count-table td:nth-child(odd) {
  background: var(--bg);
  font-weight: 500;
  color: var(--text-muted);
  width: 100px;
}

.count-table td:nth-child(even) {
  text-align: right;
  color: var(--text);
}

.count-table td:nth-child(even) strong {
  font-size: 1.1rem;
  color: var(--accent);
}

/* Word Frequency Table */
.word-freq-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.8rem;
}

.word-freq-table th, .word-freq-table td {
  padding: 6px 10px;
  text-align: left;
  border-bottom: 1px solid var(--border);
}

.word-freq-table th {
  background: var(--bg);
  font-weight: 600;
  position: sticky;
  top: 0;
}

.word-freq-table td:nth-child(2),
.word-freq-table td:nth-child(3) {
  text-align: right;
}

/* Column Extract Results */
.column-results-container {
  margin-top: 15px;
  overflow-x: auto;
}

.column-results-container table {
  width: 100%;
  border-collapse: collapse;
  table-layout: fixed;
}

.column-results-container th {
  background: var(--bg);
  padding: 10px;
  border: 1px solid var(--border);
  font-weight: 600;
  font-size: 0.85rem;
}

.column-results-container td {
  padding: 0;
  border: 1px solid var(--border);
  vertical-align: top;
}

.column-results-container textarea {
  width: 100%;
  height: 200px;
  border: none;
  padding: 8px;
  font-family: monospace;
  font-size: 0.85rem;
  resize: vertical;
  background: var(--surface);
  color: var(--text);
}

.column-results-container .col-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.column-results-container .btn-copy-col {
  padding: 2px 8px;
  font-size: 0.7rem;
  background: var(--accent);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.column-results-container .btn-copy-col:hover {
  background: var(--accent-hover);
}

.option-row label {
  font-size: 0.85rem;
  color: var(--text);
  min-width: 120px;
}

.option-row input[type="text"],
.option-row select {
  flex: 1;
  min-width: 150px;
  max-width: 300px;
  padding: 8px 12px;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 0.85rem;
  color: var(--text);
}

.option-row input[type="text"]:focus,
.option-row select:focus {
  outline: none;
  border-color: var(--accent);
}

.option-row input[type="checkbox"] {
  width: 18px;
  height: 18px;
  cursor: pointer;
}

.option-row input[type="number"] {
  width: 80px;
  padding: 8px 12px;
  background: var(--bg);
  border: 1px solid var(--border);
  border-radius: 6px;
  font-size: 0.85rem;
  color: var(--text);
}

/* Execute button */
.execute-section {
  display: flex;
  justify-content: center;
  gap: 12px;
  margin-bottom: 24px;
}

.btn-execute {
  padding: 12px 32px;
  font-size: 1rem;
  font-weight: 600;
}

/* Stats bar */
.stats-bar {
  display: flex;
  gap: 16px;
  padding: 12px 16px;
  background: var(--surface-raised);
  border-top: 1px solid var(--border);
  font-size: 0.8rem;
  flex-wrap: wrap;
}

.stat-item {
  display: flex;
  align-items: center;
  gap: 6px;
}

.stat-label {
  color: var(--text-muted);
}

.stat-value {
  font-weight: 600;
  color: var(--text);
  font-variant-numeric: tabular-nums;
}

/* Footer */
footer {
  margin-top: 32px;
  text-align: center;
  color: var(--text-muted);
  font-size: 0.75rem;
  padding-top: 16px;
  border-top: 1px solid var(--border);
}

/* Hidden tool panels */
.tool-panel {
  display: none;
}

.tool-panel.active {
  display: block;
}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>
      <span class="tool-name">TextTools</span>
      <span class="katakana">《ﾃｷｽﾄﾂｰﾙｽﾞ》</span>
    </h1>
    <p class="tagline">テキスト処理に便利なツール集</p>
  </header>

  <div class="theme-selector">
    <button class="theme-btn dark" onclick="setTheme('dark')" title="ダーク"></button>
    <button class="theme-btn light active" onclick="setTheme('light')" title="ライト"></button>
    <button class="theme-btn sepia" onclick="setTheme('sepia')" title="セピア"></button>
  </div>

  <div class="tool-tabs">
    <button class="tool-tab active" data-tool="prefix-suffix">行頭/行末追加</button>
    <button class="tool-tab" data-tool="line-breaks">改行追加/削除</button>
    <button class="tool-tab" data-tool="count">文字カウント</button>
    <button class="tool-tab" data-tool="column-extract">列抽出</button>
    <button class="tool-tab" data-tool="find-replace">検索と置換</button>
    <button class="tool-tab" data-tool="combination">組み合わせ生成</button>
    <button class="tool-tab" data-tool="remove-spaces">空白削除</button>
    <button class="tool-tab" data-tool="add-spaces">空白追加</button>
    <button class="tool-tab" data-tool="convert">文字変換</button>
    <button class="tool-tab" data-tool="line-ops">行操作</button>
    <button class="tool-tab" data-tool="sql-format">SQL整形</button>
    <button class="tool-tab" data-tool="regex-tester">正規表現</button>
    <button class="tool-tab" data-tool="md-html">MD/HTML</button>
    <button class="tool-tab" data-tool="mail-decode">メールデコード</button>
  </div>

  <!-- Prefix/Suffix Tool -->
  <div class="tool-panel active" id="panel-prefix-suffix">
    <div class="tool-options">
      <div class="tool-options-title">行頭/行末追加オプション</div>
      <div class="option-row">
        <label>行頭に追加:</label>
        <input type="text" id="prefix-text" placeholder="例: - ">
      </div>
      <div class="option-row">
        <label>行末に追加:</label>
        <input type="text" id="suffix-text" placeholder="例: ,">
      </div>
      <div class="option-row">
        <label>
          <input type="checkbox" id="prefix-skip-empty"> 空行をスキップ
        </label>
      </div>
    </div>
  </div>

  <!-- Line Breaks Tool -->
  <div class="tool-panel" id="panel-line-breaks">
    <div class="tool-options">
      <div class="tool-options-title">改行追加/削除オプション</div>
      
      <div class="option-section">
        <div class="option-section-title">■ すべての改行を削除</div>
        <div class="option-row">
          <label>置換文字列:</label>
          <input type="text" id="lb-remove-replace" placeholder="空欄で単純削除" style="max-width:200px;">
          <button class="btn-primary btn-small" onclick="executeLineBreakRemoveAll()">実行</button>
        </div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ 指定文字列の前後に改行を追加</div>
        <div class="option-row">
          <label>対象文字列:</label>
          <input type="text" id="lb-target-text" placeholder="この文字列の前後に改行" style="max-width:200px;">
        </div>
        <div class="option-row">
          <label>
            <input type="radio" name="lb-position" value="after" checked> 後に追加
          </label>
          <label>
            <input type="radio" name="lb-position" value="before"> 前に追加
          </label>
        </div>
        <div class="option-row">
          <label>
            <input type="checkbox" id="lb-case-sensitive"> 大文字小文字を区別
          </label>
          <label>
            <input type="checkbox" id="lb-remove-existing"> 既存の改行を削除
          </label>
          <button class="btn-primary btn-small" onclick="executeLineBreakAtText()">実行</button>
        </div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ N文字ごとに改行</div>
        <div class="option-row">
          <label>文字数:</label>
          <input type="number" id="lb-every-n" value="80" min="1" style="width:80px;">
        </div>
        <div class="option-row">
          <label>
            <input type="checkbox" id="lb-wordwrap"> 単語の途中で切らない
          </label>
          <label>
            <input type="checkbox" id="lb-escape-existing"> 既存の改行をエスケープ（\nに変換）
          </label>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeLineBreakEveryN()">実行</button>
        </div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ その他の改行操作</div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeLineBreakAddAfterEach()">各行の後に空行追加</button>
          <button class="btn-primary btn-small" onclick="executeLineBreakAddBeforeEach()">各行の前に空行追加</button>
          <button class="btn-primary btn-small" onclick="executeLineBreakMergeMultiple()">連続空行を1つに</button>
        </div>
      </div>

    </div>
  </div>

  <!-- Count Tool -->
  <div class="tool-panel" id="panel-count">
    <div class="tool-options">
      <div class="tool-options-title">文字カウント</div>
      
      <div class="option-section">
        <div class="count-table">
          <table>
            <tbody>
              <tr>
                <td>文字数</td>
                <td id="count-chars"><strong>0</strong> 文字</td>
                <td>改行除く</td>
                <td id="count-chars-no-newline"><strong>0</strong> 文字</td>
                <td>改行・空白除く</td>
                <td id="count-chars-no-space"><strong>0</strong> 文字</td>
              </tr>
              <tr>
                <td>行数</td>
                <td id="count-lines"><strong>0</strong> 行</td>
                <td>原稿用紙</td>
                <td id="count-genko"><strong>0</strong> 枚</td>
                <td>異体字</td>
                <td id="count-variant"><strong>0</strong> 文字</td>
              </tr>
              <tr>
                <td>UTF-8</td>
                <td id="count-utf8"><strong>0</strong> バイト</td>
                <td>UTF-16</td>
                <td id="count-utf16"><strong>0</strong> バイト</td>
                <td>Shift-JIS</td>
                <td id="count-sjis"><strong>0</strong> バイト</td>
              </tr>
              <tr>
                <td>EUC-JP</td>
                <td id="count-eucjp"><strong>0</strong> バイト</td>
                <td>JIS</td>
                <td id="count-jis"><strong>0</strong> バイト</td>
                <td></td>
                <td></td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ 文字種別カウント</div>
        <div class="count-table">
          <table>
            <thead>
              <tr>
                <th>ひらがな</th>
                <th>カタカナ</th>
                <th>漢字</th>
                <th>英字</th>
                <th>数字</th>
                <th>記号</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td id="count-hiragana">0</td>
                <td id="count-katakana">0</td>
                <td id="count-kanji">0</td>
                <td id="count-alpha">0</td>
                <td id="count-digit">0</td>
                <td id="count-symbol">0</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ 詳細カウント</div>
        <div class="count-table">
          <table>
            <thead>
              <tr>
                <th>単語数</th>
                <th>文数</th>
                <th>段落数</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td id="count-words">0</td>
                <td id="count-sentences">0</td>
                <td id="count-paragraphs">0</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ カウントオプション</div>
        <div class="option-row">
          <label>
            <input type="checkbox" id="count-no-spaces"> スペースを除外
          </label>
          <label>
            <input type="checkbox" id="count-no-html"> HTMLタグを除外
          </label>
          <label>
            <input type="checkbox" id="count-linebreak-space"> 改行をスペースとしてカウント
          </label>
          <label>
            <input type="checkbox" id="count-realtime" checked> リアルタイム更新
          </label>
        </div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ カスタムカウント（特定文字列の出現回数）</div>
        <div class="option-row">
          <input type="text" id="count-custom-query" placeholder="検索する文字列" style="max-width:200px;">
          <label>
            <input type="checkbox" id="count-custom-case"> 大文字小文字を区別
          </label>
          <span id="count-custom-result" style="font-weight:600; color:var(--accent); margin-left:10px;"></span>
        </div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ 単語頻度分析</div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="showWordFrequency()">単語頻度を分析</button>
          <button class="btn-secondary btn-small" onclick="showCharFrequency()">文字頻度を分析</button>
        </div>
        <div id="word-frequency-result" style="max-height:200px; overflow-y:auto; margin-top:10px; display:none;">
        </div>
      </div>
    </div>
  </div>

  <!-- Column Extract Tool -->
  <div class="tool-panel" id="panel-column-extract">
    <div class="tool-options">
      <div class="tool-options-title">列抽出オプション</div>
      
      <div class="option-section">
        <div class="option-row">
          <label>列の区切り文字:</label>
          <input type="text" id="column-delimiter-text" value="," style="max-width:100px;">
          <label>抽出する列数:</label>
          <input type="number" id="column-count" value="4" min="1" max="20" style="max-width:80px;">
        </div>
        <div class="option-row">
          <label>行の区切り文字:</label>
          <input type="text" id="column-row-delimiter" value="\n" style="max-width:100px;">
        </div>
        <div class="option-row">
          <label>
            <input type="checkbox" id="column-remove-col-delim"> 列の区切り文字を出力から削除
          </label>
          <label>
            <input type="checkbox" id="column-remove-row-delim"> 行の区切り文字を出力から削除
          </label>
        </div>
        <div class="option-row">
          <label>
            <input type="checkbox" id="column-has-title"> 1列目にタイトルがある（区切り文字:
          </label>
          <input type="text" id="column-title-delimiter" value=":" style="max-width:60px;">
          <span>）</span>
        </div>
        <div class="option-row">
          <label>
            <input type="checkbox" id="column-remove-empty"> 空行を削除
          </label>
          <label>
            <input type="checkbox" id="column-trim"> 各値の前後の空白を削除
          </label>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeColumnExtractMulti()">列を抽出</button>
        </div>
      </div>
      
      <div id="column-results" class="column-results-container" style="display:none;">
        <!-- 動的に列が追加される -->
      </div>
    </div>
  </div>

  <!-- Find Replace Tool -->
  <div class="tool-panel" id="panel-find-replace">
    <div class="tool-options">
      <div class="tool-options-title">検索と置換オプション</div>
      <div class="option-row">
        <label>検索文字列:</label>
        <input type="text" id="find-text" placeholder="検索する文字列">
      </div>
      <div class="option-row">
        <label>置換文字列:</label>
        <input type="text" id="replace-text" placeholder="置換後の文字列">
      </div>
      <div class="option-row">
        <label>
          <input type="checkbox" id="find-regex"> 正規表現を使用
        </label>
        <label>
          <input type="checkbox" id="find-case"> 大文字小文字を区別
        </label>
      </div>
    </div>
  </div>

  <!-- Line Combine Tool -->
  <!-- Combination Generator Tool -->
  <div class="tool-panel" id="panel-combination">
    <div class="tool-options">
      <div class="tool-options-title">組み合わせ生成</div>
      <p style="font-size:0.8rem; color:var(--text-muted); margin-bottom:12px;">
        複数のリストからすべての組み合わせを生成します。「リスト追加」ボタンでリストを増やせます。
      </p>
      
      <div class="combination-inputs" id="combinationInputs">
        <!-- Prefix -->
        <div class="combo-item combo-prefix">
          <div class="combo-label">Prefix</div>
          <input type="text" id="combo-prefix" class="combo-field" placeholder="">
        </div>
        
        <!-- List 1 -->
        <div class="combo-item combo-list" data-index="0">
          <div class="combo-label">リスト 1</div>
          <textarea class="combo-textarea" id="combo-list-0" placeholder="各行に1項目"></textarea>
          <div class="combo-count"><span id="combo-count-0">0</span> 行</div>
        </div>
        
        <!-- Delimiter 1 -->
        <div class="combo-item combo-delim" data-index="0">
          <div class="combo-label">区切り</div>
          <input type="text" class="combo-field combo-delim-field" id="combo-delim-0" placeholder="">
        </div>
        
        <!-- List 2 -->
        <div class="combo-item combo-list" data-index="1">
          <div class="combo-label">リスト 2</div>
          <textarea class="combo-textarea" id="combo-list-1" placeholder="各行に1項目"></textarea>
          <div class="combo-count"><span id="combo-count-1">0</span> 行</div>
        </div>
        
        <!-- Delimiter 2 -->
        <div class="combo-item combo-delim" data-index="1">
          <div class="combo-label">区切り</div>
          <input type="text" class="combo-field combo-delim-field" id="combo-delim-1" placeholder="">
        </div>
        
        <!-- List 3 -->
        <div class="combo-item combo-list" data-index="2">
          <div class="combo-label">リスト 3</div>
          <textarea class="combo-textarea" id="combo-list-2" placeholder="各行に1項目"></textarea>
          <div class="combo-count"><span id="combo-count-2">0</span> 行</div>
        </div>
        
        <!-- Suffix -->
        <div class="combo-item combo-suffix">
          <div class="combo-label">Suffix</div>
          <input type="text" id="combo-suffix" class="combo-field" placeholder="">
        </div>
        
        <!-- Add button -->
        <div class="combo-item combo-add">
          <button class="btn-secondary btn-small" onclick="addComboList()">+ リスト追加</button>
        </div>
      </div>
      
      <div class="combo-actions">
        <span id="combination-count" style="font-size:0.85rem; color:var(--accent); font-weight:600;"></span>
        <button class="btn-secondary btn-small" onclick="clearComboInputs()">入力クリア</button>
      </div>
    </div>
  </div>

  <!-- Remove Duplicates Tool -->
  <!-- Remove Empty Lines Tool -->
  <!-- Remove/Add Spaces Tool -->
  <!-- Remove Spaces Tool -->
  <div class="tool-panel" id="panel-remove-spaces">
    <div class="tool-options">
      <div class="tool-options-title">空白削除オプション</div>
      
      <div class="option-section">
        <div class="option-row">
          <label>
            <input type="checkbox" id="spaces-trim" checked> 行頭/行末の空白を削除（トリム）
          </label>
        </div>
        <div class="option-row">
          <label>
            <input type="radio" name="spaces-remove-mode" value="extra" checked> 連続する空白を1つに
          </label>
          <label>
            <input type="radio" name="spaces-remove-mode" value="all"> すべての空白を削除
          </label>
          <label>
            <input type="radio" name="spaces-remove-mode" value="none"> 削除しない（トリムのみ）
          </label>
        </div>
      </div>
    </div>
  </div>

  <!-- Add Spaces Tool -->
  <div class="tool-panel" id="panel-add-spaces">
    <div class="tool-options">
      <div class="tool-options-title">空白追加オプション</div>
      
      <div class="option-section">
        <div class="option-row">
          <label>
            <input type="checkbox" id="spaces-add-every-n"> 
            <input type="number" id="spaces-add-n" value="10" min="1" style="width:60px;"> 文字ごとに空白を追加
          </label>
        </div>
        <div class="option-row">
          <label>
            <input type="checkbox" id="spaces-add-after-char"> 指定文字の後に空白を追加:
          </label>
          <input type="text" id="spaces-after-char" value="." style="max-width:80px;">
        </div>
        <div class="option-row">
          <label>
            <input type="checkbox" id="spaces-add-after-line"> 各行の末尾に空白を追加
          </label>
        </div>
      </div>
    </div>
  </div>

  <!-- Convert Tool (文字変換) -->
  <div class="tool-panel" id="panel-convert">
    <div class="tool-options">
      <div class="tool-options-title">文字変換</div>
      
      <div class="option-section">
        <div class="option-section-title">■ 大文字/小文字</div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeConvert('lowercase')">小文字に変換</button>
          <button class="btn-primary btn-small" onclick="executeConvert('uppercase')">大文字に変換</button>
          <button class="btn-primary btn-small" onclick="executeConvert('randomcase')">ランダム</button>
          <button class="btn-primary btn-small" onclick="executeConvert('studlycaps')">交互大小文字</button>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeConvert('capitalizeWords')">各単語の先頭を大文字</button>
          <button class="btn-primary btn-small" onclick="executeConvert('uncapitalizeWords')">各単語の先頭を小文字</button>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeConvert('capitalizeSentences')">各文の先頭を大文字</button>
          <button class="btn-primary btn-small" onclick="executeConvert('uncapitalizeSentences')">各文の先頭を小文字</button>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeConvert('snakeCase')">snake_case</button>
          <button class="btn-primary btn-small" onclick="executeConvert('kebabCase')">kebab-case</button>
          <button class="btn-primary btn-small" onclick="executeConvert('camelCase')">camelCase</button>
          <button class="btn-primary btn-small" onclick="executeConvert('pascalCase')">PascalCase</button>
        </div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ 全角/半角変換</div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeConvert('toFullwidth')">全角→半角</button>
          <button class="btn-primary btn-small" onclick="executeConvert('toHalfwidth')">半角→全角</button>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeConvert('hiraToFullKata')">半角＋ひら→全角・カタカナ</button>
          <button class="btn-primary btn-small" onclick="executeConvert('hiraToHalfKata')">半角＋全カタ→全角・ひらがな</button>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeConvert('alphaToFull')">全角英数→半角英数</button>
          <button class="btn-primary btn-small" onclick="executeConvert('alphaToHalf')">半角英数→全角英数</button>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeConvert('kataToFull')">全角カタカナ→半角カタカナ</button>
          <button class="btn-primary btn-small" onclick="executeConvert('kataToHalf')">半角カタカナ→全角カタカナ</button>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeConvert('hiraToKata')">ひらがな→カタカナ</button>
          <button class="btn-primary btn-small" onclick="executeConvert('kataToHira')">カタカナ→ひらがな</button>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeConvert('romaToHira')">ローマ字→ひらがな</button>
          <button class="btn-primary btn-small" onclick="executeConvert('romaToKata')">ローマ字→カタカナ</button>
          <button class="btn-primary btn-small" onclick="executeConvert('hiraToRoma')">ひらがな→ローマ字</button>
        </div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ スペース/TAB変換</div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeConvert('tabToSpace')">TAB→空白</button>
          <button class="btn-primary btn-small" onclick="executeConvert('spaceToTab')">空白→TAB</button>
          <label style="margin-left:10px;">スペース数: <input type="number" id="convert-tab-spaces" value="4" min="1" max="16" style="width:70px;"></label>
        </div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ エンコード/デコード</div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeConvert('base64Encode')">Base64 エンコード</button>
          <button class="btn-primary btn-small" onclick="executeConvert('base64Decode')">Base64 デコード</button>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeConvert('quotedPrintableEncode')">Quoted-Printable エンコード</button>
          <button class="btn-primary btn-small" onclick="executeConvert('quotedPrintableDecode')">Quoted-Printable デコード</button>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeConvert('urlEncode')">URLエンコード</button>
          <button class="btn-primary btn-small" onclick="executeConvert('urlDecode')">URLデコード</button>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeConvert('htmlEntityEncode')">HTMLエンティティ エンコード</button>
          <button class="btn-primary btn-small" onclick="executeConvert('htmlEntityDecode')">HTMLエンティティ デコード</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Line Operations Tool (行操作) -->
  <div class="tool-panel" id="panel-line-ops">
    <div class="tool-options">
      <div class="tool-options-title">行操作</div>
      
      <div class="option-section">
        <div class="option-section-title">■ 空白を削除</div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeLineOps('trimLeft')">左(先頭)の空白を削除</button>
          <button class="btn-primary btn-small" onclick="executeLineOps('trimRight')">右(末尾)の空白を削除</button>
        </div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ ソート</div>
        <div class="option-row">
          <label>区切り文字:</label>
          <input type="text" id="sort-delimiter" value="" placeholder="空欄=行全体" style="max-width:80px;">
          <label>列番号:</label>
          <input type="number" id="sort-column" value="1" min="1" style="max-width:60px;">
          <span style="font-size:0.7rem; color:var(--text-muted);">※区切り文字を指定した場合のみ有効</span>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeLineOps('sortAlpha')">アルファベット順</button>
          <button class="btn-secondary btn-small" onclick="executeLineOps('sortAlphaCase')">Aa区別</button>
          <button class="btn-primary btn-small" onclick="executeLineOps('sortNatural')">自然順</button>
          <button class="btn-secondary btn-small" onclick="executeLineOps('sortNaturalCase')">Aa区別</button>
          <button class="btn-primary btn-small" onclick="executeLineOps('sortLength')">文字数順</button>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeLineOps('sortRandom')">ランダム</button>
          <button class="btn-primary btn-small" onclick="executeLineOps('sortReverse')">逆順</button>
          <label style="margin-left:15px;">
            <input type="checkbox" id="sort-desc"> 降順（Z→A）
          </label>
        </div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ 重複行削除</div>
        <div class="option-row">
          <label>
            <input type="checkbox" id="dup-case" checked> 大文字小文字を区別
          </label>
          <label>
            <input type="checkbox" id="dup-trim"> 前後の空白を無視
          </label>
          <label>
            <input type="checkbox" id="dup-keep-order" checked> 出現順序を保持
          </label>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeLineOps('removeDuplicates')">すべての重複行を削除</button>
          <button class="btn-primary btn-small" onclick="executeLineOps('uniq')">連続した重複行のみ削除 (uniq)</button>
        </div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ 行結合</div>
        <div class="option-row">
          <label>結合文字:</label>
          <input type="text" id="combine-delimiter" placeholder="例: , (空欄で直接結合)" style="max-width:120px;">
          <label>
            <input type="checkbox" id="combine-skip-empty" checked> 空行をスキップ
          </label>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeLineOps('combine')">行を結合</button>
        </div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ 空行削除</div>
        <div class="option-row">
          <label>
            <input type="checkbox" id="empty-whitespace" checked> 空白のみの行も削除
          </label>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeLineOps('removeEmpty')">空行を削除</button>
        </div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ 指定文字列で行をフィルタ</div>
        <div class="option-row">
          <label>検索文字列:</label>
          <input type="text" id="filter-text" placeholder="検索する文字列" style="flex:1; max-width:300px;">
        </div>
        <div class="option-row">
          <label>
            <input type="checkbox" id="filter-case"> 大文字小文字を区別
          </label>
          <label>
            <input type="checkbox" id="filter-regex"> 正規表現を使用
          </label>
          <label>
            <input type="checkbox" id="filter-show-removed"> 削除された行を表示
          </label>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeLineOps('filterContaining')">含む行を削除</button>
          <button class="btn-primary btn-small" onclick="executeLineOps('filterNotContaining')">含まない行を削除</button>
        </div>
        <div id="filter-removed-count" style="font-size:0.8rem; color:var(--accent); margin-top:5px;"></div>
      </div>

      <div class="option-section">
        <div class="option-section-title">■ 繰り返し生成</div>
        <div class="option-row">
          <label>繰り返し回数:</label>
          <input type="number" id="repeat-count" value="10" min="1" max="10000" style="max-width:80px;">
          <label>1行あたりの個数:</label>
          <input type="number" id="repeat-per-row" value="1" min="1" max="1000" style="max-width:80px;">
        </div>
        <div class="option-row">
          <label>区切り文字:</label>
          <input type="text" id="repeat-separator" value="" placeholder="空欄で直接連結" style="max-width:100px;">
          <label>
            <input type="checkbox" id="repeat-each-line"> 各行を個別に繰り返す
          </label>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeLineOps('repeat')">繰り返し生成</button>
        </div>
      </div>
    </div>
  </div>

  <!-- SQL Format Tool (SQL整形) -->
  <div class="tool-panel" id="panel-sql-format">
    <div class="tool-options">
      <div class="tool-options-title">SQL整形</div>
      
      <div class="option-section">
        <div class="option-section-title">■ 整形オプション</div>
        <div class="option-row">
          <label>インデント:</label>
          <select id="sql-indent-type" style="max-width:120px;">
            <option value="  ">スペース2個</option>
            <option value="    " selected>スペース4個</option>
            <option value="\t">タブ</option>
          </select>
        </div>
        <div class="option-row">
          <label>
            <input type="checkbox" id="sql-uppercase-keywords" checked> キーワードを大文字に
          </label>
          <label>
            <input type="checkbox" id="sql-newline-before-and"> AND/ORの前で改行
          </label>
        </div>
        <div class="option-row">
          <label>
            <input type="checkbox" id="sql-newline-after-comma"> カンマの後で改行（SELECT句）
          </label>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeSqlFormat('format')">SQL整形</button>
          <button class="btn-primary btn-small" onclick="executeSqlFormat('minify')">圧縮（1行化）</button>
        </div>
      </div>
      
      <div class="option-section">
        <div class="option-section-title">■ 変換</div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeSqlFormat('toInsert')">値リスト→INSERT文</button>
          <button class="btn-primary btn-small" onclick="executeSqlFormat('toInClause')">値リスト→IN句</button>
        </div>
        <div class="option-row">
          <label>テーブル名:</label>
          <input type="text" id="sql-table-name" value="table_name" style="max-width:150px;">
          <label>カラム名:</label>
          <input type="text" id="sql-column-name" value="column_name" style="max-width:150px;">
        </div>
        <div class="option-row">
          <label>
            <input type="checkbox" id="sql-quote-values" checked> 値をクォートで囲む
          </label>
          <label>クォート文字:</label>
          <select id="sql-quote-char" style="max-width:80px;">
            <option value="'" selected>シングル '</option>
            <option value="&quot;">ダブル "</option>
          </select>
        </div>
      </div>
    </div>
  </div>

  <!-- Regex Tester Tool (正規表現テスター) -->
  <div class="tool-panel" id="panel-regex-tester">
    <div class="tool-options">
      <div class="tool-options-title">正規表現テスター</div>
      
      <div class="option-section">
        <div class="option-section-title">■ 正規表現</div>
        <div class="option-row">
          <label>パターン:</label>
          <input type="text" id="regex-pattern" placeholder="例: \d+|[a-z]+" style="flex:1; min-width:200px;">
        </div>
        <div class="option-row">
          <label>フラグ:</label>
          <label><input type="checkbox" id="regex-flag-g" checked> g (全体)</label>
          <label><input type="checkbox" id="regex-flag-i"> i (大小無視)</label>
          <label><input type="checkbox" id="regex-flag-m"> m (複数行)</label>
          <label><input type="checkbox" id="regex-flag-s"> s (dotAll)</label>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeRegexTest()">テスト実行</button>
          <button class="btn-primary btn-small" onclick="executeRegexExtract()">マッチ抽出</button>
          <button class="btn-primary btn-small" onclick="executeRegexReplace()">置換実行</button>
        </div>
        <div class="option-row">
          <label>置換文字列:</label>
          <input type="text" id="regex-replace" placeholder="例: [$&] や $1" style="flex:1; min-width:200px;">
        </div>
      </div>
      
      <div class="option-section">
        <div class="option-section-title">■ テスト結果</div>
        <div id="regex-result" style="padding:10px; background:#f8f9fa; border-radius:5px; min-height:60px; font-family:monospace; font-size:0.85rem; white-space:pre-wrap; word-break:break-all;"></div>
      </div>
      
      <div class="option-section">
        <div class="option-section-title">■ クイックリファレンス</div>
        <div style="font-size:0.75rem; color:#666; display:grid; grid-template-columns:repeat(auto-fit, minmax(150px, 1fr)); gap:5px;">
          <span><code>.</code> 任意の1文字</span>
          <span><code>\d</code> 数字 [0-9]</span>
          <span><code>\w</code> 単語文字</span>
          <span><code>\s</code> 空白文字</span>
          <span><code>^</code> 行頭</span>
          <span><code>$</code> 行末</span>
          <span><code>*</code> 0回以上</span>
          <span><code>+</code> 1回以上</span>
          <span><code>?</code> 0か1回</span>
          <span><code>{n,m}</code> n〜m回</span>
          <span><code>()</code> グループ</span>
          <span><code>|</code> または</span>
          <span><code>[abc]</code> 文字クラス</span>
          <span><code>[^abc]</code> 否定</span>
          <span><code>(?:)</code> 非キャプチャ</span>
          <span><code>(?=)</code> 先読み</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Markdown/HTML Tool (MD/HTML変換) -->
  <div class="tool-panel" id="panel-md-html">
    <div class="tool-options">
      <div class="tool-options-title">Markdown / HTML 変換</div>
      
      <div class="option-section">
        <div class="option-section-title">■ 変換</div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeMdHtml('mdToHtml')">Markdown → HTML</button>
          <button class="btn-primary btn-small" onclick="executeMdHtml('htmlToMd')">HTML → Markdown</button>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeMdHtml('preview')">プレビュー表示</button>
          <button class="btn-primary btn-small" onclick="closeMdPreview()">プレビューを閉じる</button>
        </div>
      </div>
      
      <div class="option-section">
        <div class="option-section-title">■ Markdownクイックリファレンス</div>
        <div style="font-size:0.75rem; color:#666; display:grid; grid-template-columns:repeat(auto-fit, minmax(180px, 1fr)); gap:5px;">
          <span><code># 見出し1</code></span>
          <span><code>## 見出し2</code></span>
          <span><code>**太字**</code></span>
          <span><code>*斜体*</code></span>
          <span><code>~~取消線~~</code></span>
          <span><code>`コード`</code></span>
          <span><code>[リンク](URL)</code></span>
          <span><code>![画像](URL)</code></span>
          <span><code>- リスト項目</code></span>
          <span><code>1. 番号リスト</code></span>
          <span><code>> 引用</code></span>
          <span><code>---</code> 水平線</span>
        </div>
      </div>
      
      <div class="option-section" id="md-preview-section" style="display:none;">
        <div class="option-section-title">■ プレビュー</div>
        <div id="md-preview" style="padding:15px; background:white; border:1px solid #ddd; border-radius:5px; min-height:100px; max-height:400px; overflow:auto;"></div>
      </div>
    </div>
  </div>

  <!-- Mail Decode Tool (メールデコード) -->
  <div class="tool-panel" id="panel-mail-decode">
    <div class="tool-options">
      <div class="tool-options-title">メールデコード</div>
      
      <div class="option-section">
        <div class="option-section-title">■ MIMEヘッダーデコード</div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeMailDecode('header')">ヘッダーデコード</button>
          <button class="btn-primary btn-small" onclick="executeMailDecode('subject')">Subject抽出・デコード</button>
        </div>
        <p style="font-size:0.75rem; color:#666; margin-top:5px;">
          =?ISO-2022-JP?B?...?= や =?UTF-8?Q?...?= 形式をデコード
        </p>
      </div>
      
      <div class="option-section">
        <div class="option-section-title">■ 本文デコード</div>
        <div class="option-row">
          <label>エンコーディング:</label>
          <select id="mail-charset" style="max-width:150px;">
            <option value="auto" selected>自動検出</option>
            <option value="iso-2022-jp">ISO-2022-JP (JIS)</option>
            <option value="shift_jis">Shift_JIS</option>
            <option value="euc-jp">EUC-JP</option>
            <option value="utf-8">UTF-8</option>
          </select>
        </div>
        <div class="option-row">
          <label>転送エンコーディング:</label>
          <select id="mail-encoding" style="max-width:150px;">
            <option value="auto" selected>自動検出</option>
            <option value="base64">Base64</option>
            <option value="quoted-printable">Quoted-Printable</option>
            <option value="none">なし（生テキスト）</option>
          </select>
        </div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeMailDecode('body')">本文デコード</button>
          <button class="btn-primary btn-small" onclick="executeMailDecode('full')">全体デコード（ヘッダー+本文）</button>
        </div>
      </div>
      
      <div class="option-section">
        <div class="option-section-title">■ 個別デコード</div>
        <div class="option-row">
          <button class="btn-primary btn-small" onclick="executeMailDecode('base64')">Base64デコード</button>
          <button class="btn-primary btn-small" onclick="executeMailDecode('qp')">Quoted-Printableデコード</button>
        </div>
        <div class="option-row">
          <label>
            <input type="checkbox" id="mail-decode-jis" checked> ISO-2022-JP (JIS) 対応
          </label>
          <label>
            <input type="checkbox" id="mail-decode-sjis"> Shift_JIS 対応
          </label>
        </div>
      </div>
    </div>
  </div>

  <div class="execute-section">
    <button class="btn-primary btn-execute" id="executeButton" onclick="execute()">実行</button>
    <button class="btn-secondary" onclick="clearAll()">クリア</button>
    <button class="btn-secondary" id="swapButton" onclick="swapTexts()">⇄ 入出力入替</button>
  </div>

  <div class="main-content">
    <div class="panel input-panel" id="inputPanel">
      <div class="panel-header">
        <span class="panel-title">入力テキスト</span>
        <div class="panel-actions">
          <button class="btn-secondary btn-small" onclick="sortInput('asc')">▲ 昇順</button>
          <button class="btn-secondary btn-small" onclick="sortInput('desc')">▼ 降順</button>
        </div>
      </div>
      <div class="panel-body">
        <textarea id="inputText" placeholder="ここにテキストを入力..."></textarea>
      </div>
      <div class="stats-bar" id="inputStats">
        <div class="stat-item">
          <span class="stat-label">文字数:</span>
          <span class="stat-value" id="input-chars">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">空白込み文字数:</span>
          <span class="stat-value" id="input-chars-with-spaces">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">改行数:</span>
          <span class="stat-value" id="input-newlines">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">改行込み文字数:</span>
          <span class="stat-value" id="input-chars-with-newlines">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">行数:</span>
          <span class="stat-value" id="input-lines">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">単語数:</span>
          <span class="stat-value" id="input-words">0</span>
        </div>
      </div>
    </div>

    <div class="panel output-panel">
      <div class="panel-header">
        <span class="panel-title">出力結果</span>
        <div class="panel-actions">
          <button class="btn-secondary btn-small" onclick="copyToClipboard()">📋 コピー</button>
          <button class="btn-secondary btn-small" onclick="downloadOutput()">📥 保存</button>
        </div>
      </div>
      <div class="panel-body">
        <textarea id="outputText" placeholder="処理結果がここに表示されます..." readonly></textarea>
      </div>
      <div class="stats-bar" id="outputStats">
        <div class="stat-item">
          <span class="stat-label">文字数:</span>
          <span class="stat-value" id="output-chars">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">空白込み文字数:</span>
          <span class="stat-value" id="output-chars-with-spaces">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">改行数:</span>
          <span class="stat-value" id="output-newlines">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">改行込み文字数:</span>
          <span class="stat-value" id="output-chars-with-newlines">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">行数:</span>
          <span class="stat-value" id="output-lines">0</span>
        </div>
        <div class="stat-item">
          <span class="stat-label">単語数:</span>
          <span class="stat-value" id="output-words">0</span>
        </div>
      </div>
    </div>
  </div>

  <footer>
    <p>このツールは通信無しでブラウザ内で動作します。</p>
  </footer>
</div>

<script>
// Current tool
let currentTool = 'prefix-suffix';

// Theme
function setTheme(theme) {
  if (theme === 'light') {
    document.documentElement.removeAttribute('data-theme');
  } else {
    document.documentElement.setAttribute('data-theme', theme);
  }
  document.querySelectorAll('.theme-btn').forEach(btn => btn.classList.remove('active'));
  document.querySelector(`.theme-btn.${theme}`).classList.add('active');
}

// Tab switching
document.querySelectorAll('.tool-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.tool-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tool-panel').forEach(p => p.classList.remove('active'));
    tab.classList.add('active');
    currentTool = tab.dataset.tool;
    document.getElementById(`panel-${currentTool}`).classList.add('active');
    
    // 入力パネル、出力パネル、入出力入替ボタン、実行ボタンの表示制御
    const inputPanel = document.getElementById('inputPanel');
    const outputPanel = document.querySelector('.output-panel');
    const mainContent = document.querySelector('.main-content');
    const swapButton = document.getElementById('swapButton');
    const executeButton = document.getElementById('executeButton');
    
    // 組み合わせ生成: 入力パネル非表示、出力全幅、入出力入替非表示
    if (currentTool === 'combination') {
      inputPanel.style.display = 'none';
      outputPanel.style.display = 'block';
      mainContent.classList.add('full-width');
      swapButton.style.display = 'none';
      executeButton.style.display = 'inline-block';
    } 
    // 列抽出: 出力パネル非表示（専用の結果エリアを使用）
    else if (currentTool === 'column-extract') {
      inputPanel.style.display = 'block';
      outputPanel.style.display = 'none';
      mainContent.classList.remove('full-width');
      swapButton.style.display = 'none';
      executeButton.style.display = 'none';
      document.getElementById('column-results').style.display = 'none';
    }
    // 改行追加/削除、文字変換、行操作: 各セクションにボタンがあるので実行ボタン非表示
    else if (currentTool === 'line-breaks' || currentTool === 'convert' || currentTool === 'line-ops') {
      inputPanel.style.display = 'block';
      outputPanel.style.display = 'block';
      mainContent.classList.remove('full-width');
      swapButton.style.display = 'inline-block';
      executeButton.style.display = 'none';
    }
    // その他: 通常表示
    else {
      inputPanel.style.display = 'block';
      outputPanel.style.display = 'block';
      mainContent.classList.remove('full-width');
      swapButton.style.display = 'inline-block';
      executeButton.style.display = 'inline-block';
    }
  });
});

// Update stats
function updateStats(textareaId, prefix) {
  const text = document.getElementById(textareaId).value;
  
  // 文字数（空白・改行除く）
  const charsNoSpaces = text.replace(/[\s　]/g, '').length;
  // 空白込み文字数（改行除く）
  const charsWithSpaces = text.replace(/\n/g, '').length;
  // 改行数
  const newlines = (text.match(/\n/g) || []).length;
  // 改行込み文字数
  const charsWithNewlines = text.length;
  // 行数
  const lines = text ? text.split('\n').length : 0;
  // 単語数
  const words = text.trim() ? text.trim().split(/\s+/).length : 0;
  
  document.getElementById(`${prefix}-chars`).textContent = charsNoSpaces.toLocaleString();
  document.getElementById(`${prefix}-chars-with-spaces`).textContent = charsWithSpaces.toLocaleString();
  document.getElementById(`${prefix}-newlines`).textContent = newlines.toLocaleString();
  document.getElementById(`${prefix}-chars-with-newlines`).textContent = charsWithNewlines.toLocaleString();
  document.getElementById(`${prefix}-lines`).textContent = lines.toLocaleString();
  document.getElementById(`${prefix}-words`).textContent = words.toLocaleString();
}

document.getElementById('inputText').addEventListener('input', () => updateStats('inputText', 'input'));
document.getElementById('outputText').addEventListener('input', () => updateStats('outputText', 'output'));

// Execute
function execute() {
  const input = document.getElementById('inputText').value;
  let output = '';
  
  switch(currentTool) {
    case 'prefix-suffix':
      output = executePrefixSuffix(input);
      break;
    case 'line-breaks':
      output = executeLineBreaks(input);
      break;
    case 'count':
      output = executeCount(input);
      break;
    case 'column-extract':
      output = executeColumnExtract(input);
      break;
    case 'find-replace':
      output = executeFindReplace(input);
      break;
    case 'combination':
      output = executeCombination(input);
      break;
    case 'remove-spaces':
      output = executeRemoveSpaces(input);
      break;
    case 'add-spaces':
      output = executeAddSpacesMain(input);
      break;
  }
  
  document.getElementById('outputText').value = output;
  updateStats('outputText', 'output');
}

// Tool implementations
function executePrefixSuffix(input) {
  const prefix = document.getElementById('prefix-text').value;
  const suffix = document.getElementById('suffix-text').value;
  const skipEmpty = document.getElementById('prefix-skip-empty').checked;
  
  return input.split('\n').map(line => {
    if (skipEmpty && line.trim() === '') return line;
    return prefix + line + suffix;
  }).join('\n');
}

// Line breaks - Remove all
function executeLineBreakRemoveAll() {
  const input = document.getElementById('inputText').value;
  const replaceWith = document.getElementById('lb-remove-replace').value;
  const output = input.replace(/\n/g, replaceWith);
  document.getElementById('outputText').value = output;
  updateStats('outputText', 'output');
}

// Line breaks - At specific text
function executeLineBreakAtText() {
  let input = document.getElementById('inputText').value;
  const targetText = document.getElementById('lb-target-text').value;
  const position = document.querySelector('input[name="lb-position"]:checked').value;
  const caseSensitive = document.getElementById('lb-case-sensitive').checked;
  const removeExisting = document.getElementById('lb-remove-existing').checked;
  
  if (!targetText) {
    alert('対象文字列を入力してください');
    return;
  }
  
  // 既存の改行を削除
  if (removeExisting) {
    input = input.replace(/\n/g, '');
  }
  
  // 改行を追加
  const flags = caseSensitive ? 'g' : 'gi';
  const escaped = targetText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regex = new RegExp(escaped, flags);
  
  let output;
  if (position === 'after') {
    output = input.replace(regex, match => match + '\n');
  } else {
    output = input.replace(regex, match => '\n' + match);
  }
  
  document.getElementById('outputText').value = output;
  updateStats('outputText', 'output');
}

// Line breaks - Every N characters
function executeLineBreakEveryN() {
  let input = document.getElementById('inputText').value;
  const n = parseInt(document.getElementById('lb-every-n').value) || 80;
  const wordwrap = document.getElementById('lb-wordwrap').checked;
  const escapeExisting = document.getElementById('lb-escape-existing').checked;
  
  // 既存の改行をエスケープ
  if (escapeExisting) {
    input = input.replace(/\n/g, '\\n');
  }
  
  let output = '';
  
  if (wordwrap) {
    // 単語の途中で切らない
    const words = input.split(/(\s+)/);
    let currentLine = '';
    
    for (const word of words) {
      if (currentLine.length + word.length > n && currentLine.length > 0) {
        output += currentLine.trimEnd() + '\n';
        currentLine = word.trimStart();
      } else {
        currentLine += word;
      }
    }
    if (currentLine) {
      output += currentLine;
    }
  } else {
    // 単純にN文字ごとに改行
    for (let i = 0; i < input.length; i += n) {
      output += input.substring(i, i + n);
      if (i + n < input.length) {
        output += '\n';
      }
    }
  }
  
  document.getElementById('outputText').value = output;
  updateStats('outputText', 'output');
}

// Line breaks - Add after each line
function executeLineBreakAddAfterEach() {
  const input = document.getElementById('inputText').value;
  const output = input.split('\n').join('\n\n');
  document.getElementById('outputText').value = output;
  updateStats('outputText', 'output');
}

// Line breaks - Add before each line
function executeLineBreakAddBeforeEach() {
  const input = document.getElementById('inputText').value;
  const output = input.split('\n').map((line, i) => i === 0 ? line : '\n' + line).join('\n');
  document.getElementById('outputText').value = output;
  updateStats('outputText', 'output');
}

// Line breaks - Merge multiple empty lines
function executeLineBreakMergeMultiple() {
  const input = document.getElementById('inputText').value;
  const output = input.replace(/\n{3,}/g, '\n\n');
  document.getElementById('outputText').value = output;
  updateStats('outputText', 'output');
}

function executeLineBreaks(input) {
  // This function is no longer used for line-breaks tool
  // Each operation has its own button now
  return input;
}

function executeCount(input) {
  const noSpaces = document.getElementById('count-no-spaces').checked;
  const noHtml = document.getElementById('count-no-html').checked;
  const linebreakAsSpace = document.getElementById('count-linebreak-space').checked;
  
  let text = input;
  
  // HTMLタグを除外
  if (noHtml) {
    text = text.replace(/<[^>]*>/g, '');
  }
  
  // 改行をスペースとしてカウント
  if (linebreakAsSpace) {
    text = text.replace(/\n/g, ' ');
  }
  
  // 文字数計算
  const charCountTotal = text.length;
  const charCountNoNewline = text.replace(/\n/g, '').length;
  const charCountNoSpace = text.replace(/[\s　]/g, '').length;
  
  // 単語数（英単語と日本語を考慮）
  const wordCount = text.trim() ? text.trim().split(/\s+/).filter(w => w).length : 0;
  
  // 文数（句点・ピリオド・感嘆符・疑問符で区切る）
  const sentences = text.split(/[.!?。！？]+/).filter(s => s.trim());
  const sentenceCount = sentences.length;
  
  // 段落数（空行で区切られたブロック）
  const paragraphs = input.split(/\n\s*\n/).filter(p => p.trim());
  const paragraphCount = paragraphs.length || (input.trim() ? 1 : 0);
  
  // 行数
  const lineCount = input.split('\n').length;
  
  // 原稿用紙（400字詰め）
  const genkoCount = Math.ceil(charCountNoSpace / 400);
  
  // 文字種別カウント
  const hiraganaCount = (text.match(/[\u3041-\u3096]/g) || []).length;
  const katakanaCount = (text.match(/[\u30A1-\u30F6\uFF66-\uFF9F]/g) || []).length;
  const kanjiCount = (text.match(/[\u4E00-\u9FFF\u3400-\u4DBF]/g) || []).length;
  const alphaCount = (text.match(/[A-Za-zＡ-Ｚａ-ｚ]/g) || []).length;
  const digitCount = (text.match(/[0-9０-９]/g) || []).length;
  const symbolCount = charCountNoSpace - hiraganaCount - katakanaCount - kanjiCount - alphaCount - digitCount;
  
  // 異体字（IVS: 異体字セレクタを含む文字）
  const variantCount = (input.match(/[\uDB40-\uDBFF][\uDD00-\uDDEF]/g) || []).length;
  
  // バイト数計算
  const utf8Bytes = new Blob([input]).size;
  const utf16Bytes = input.length * 2 + 2; // BOM含む概算
  
  // Shift-JIS概算（日本語3バイト→2バイト、ASCII1バイト）
  let sjisBytes = 0;
  for (const char of input) {
    const code = char.charCodeAt(0);
    if (code <= 0x7F) {
      sjisBytes += 1; // ASCII
    } else if (code >= 0xFF61 && code <= 0xFF9F) {
      sjisBytes += 1; // 半角カナ
    } else {
      sjisBytes += 2; // その他の日本語
    }
  }
  
  // EUC-JP概算
  let eucjpBytes = 0;
  for (const char of input) {
    const code = char.charCodeAt(0);
    if (code <= 0x7F) {
      eucjpBytes += 1;
    } else if (code >= 0xFF61 && code <= 0xFF9F) {
      eucjpBytes += 2; // 半角カナは2バイト
    } else {
      eucjpBytes += 2;
    }
  }
  
  // JIS概算（ISO-2022-JP）
  let jisBytes = eucjpBytes + Math.ceil(input.length / 10) * 3; // エスケープシーケンス概算
  
  // テーブルを更新
  document.getElementById('count-chars').innerHTML = `<strong>${charCountTotal.toLocaleString()}</strong> 文字`;
  document.getElementById('count-chars-no-newline').innerHTML = `<strong>${charCountNoNewline.toLocaleString()}</strong> 文字`;
  document.getElementById('count-chars-no-space').innerHTML = `<strong>${charCountNoSpace.toLocaleString()}</strong> 文字`;
  document.getElementById('count-lines').innerHTML = `<strong>${lineCount.toLocaleString()}</strong> 行`;
  document.getElementById('count-genko').innerHTML = `<strong>${genkoCount.toLocaleString()}</strong> 枚`;
  document.getElementById('count-variant').innerHTML = `<strong>${variantCount.toLocaleString()}</strong> 文字`;
  
  document.getElementById('count-utf8').innerHTML = `<strong>${utf8Bytes.toLocaleString()}</strong> バイト`;
  document.getElementById('count-utf16').innerHTML = `<strong>${utf16Bytes.toLocaleString()}</strong> バイト`;
  document.getElementById('count-sjis').innerHTML = `<strong>${sjisBytes.toLocaleString()}</strong> バイト`;
  document.getElementById('count-eucjp').innerHTML = `<strong>${eucjpBytes.toLocaleString()}</strong> バイト`;
  document.getElementById('count-jis').innerHTML = `<strong>${jisBytes.toLocaleString()}</strong> バイト`;
  
  // 文字種別
  document.getElementById('count-hiragana').textContent = hiraganaCount.toLocaleString();
  document.getElementById('count-katakana').textContent = katakanaCount.toLocaleString();
  document.getElementById('count-kanji').textContent = kanjiCount.toLocaleString();
  document.getElementById('count-alpha').textContent = alphaCount.toLocaleString();
  document.getElementById('count-digit').textContent = digitCount.toLocaleString();
  document.getElementById('count-symbol').textContent = Math.max(0, symbolCount).toLocaleString();
  
  // 詳細
  document.getElementById('count-words').textContent = wordCount.toLocaleString();
  document.getElementById('count-sentences').textContent = sentenceCount.toLocaleString();
  document.getElementById('count-paragraphs').textContent = paragraphCount.toLocaleString();
  
  // カスタムカウント
  updateCustomCount(input);
  
  // 出力テキスト
  let output = `=== 文字カウント結果 ===\n`;
  output += `文字数: ${charCountTotal.toLocaleString()}\n`;
  output += `改行除く: ${charCountNoNewline.toLocaleString()}\n`;
  output += `改行・空白除く: ${charCountNoSpace.toLocaleString()}\n`;
  output += `行数: ${lineCount.toLocaleString()}\n`;
  output += `原稿用紙: ${genkoCount.toLocaleString()} 枚\n`;
  output += `\n=== バイト数 ===\n`;
  output += `UTF-8: ${utf8Bytes.toLocaleString()} バイト\n`;
  output += `UTF-16: ${utf16Bytes.toLocaleString()} バイト\n`;
  output += `Shift-JIS: ${sjisBytes.toLocaleString()} バイト\n`;
  output += `EUC-JP: ${eucjpBytes.toLocaleString()} バイト\n`;
  output += `JIS: ${jisBytes.toLocaleString()} バイト\n`;
  output += `\n=== 文字種別 ===\n`;
  output += `ひらがな: ${hiraganaCount.toLocaleString()}\n`;
  output += `カタカナ: ${katakanaCount.toLocaleString()}\n`;
  output += `漢字: ${kanjiCount.toLocaleString()}\n`;
  output += `英字: ${alphaCount.toLocaleString()}\n`;
  output += `数字: ${digitCount.toLocaleString()}\n`;
  output += `記号等: ${Math.max(0, symbolCount).toLocaleString()}\n`;
  
  return output;
}

// リアルタイムカウント更新
function updateRealtimeCount() {
  const realtime = document.getElementById('count-realtime');
  if (realtime && realtime.checked && currentTool === 'count') {
    const input = document.getElementById('inputText').value;
    executeCount(input);
  }
}

function updateCustomCount(input) {
  const query = document.getElementById('count-custom-query').value;
  const caseSensitive = document.getElementById('count-custom-case').checked;
  const resultSpan = document.getElementById('count-custom-result');
  
  if (!query) {
    resultSpan.textContent = '';
    return;
  }
  
  const flags = caseSensitive ? 'g' : 'gi';
  const escaped = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const regex = new RegExp(escaped, flags);
  const matches = input.match(regex);
  const count = matches ? matches.length : 0;
  
  resultSpan.textContent = `${count} 件見つかりました`;
}

function showWordFrequency() {
  const input = document.getElementById('inputText').value;
  const resultDiv = document.getElementById('word-frequency-result');
  
  if (!input.trim()) {
    resultDiv.style.display = 'none';
    return;
  }
  
  // 単語を抽出（英単語・日本語・数字を含む）
  const words = input.toLowerCase().match(/[\p{L}\p{N}]+/gu) || [];
  const freq = {};
  words.forEach(w => freq[w] = (freq[w] || 0) + 1);
  
  const sorted = Object.entries(freq).sort((a, b) => b[1] - a[1]);
  const total = words.length;
  
  let html = `<table class="word-freq-table">
    <thead>
      <tr><th>単語</th><th>回数</th><th>頻度</th></tr>
    </thead>
    <tbody>`;
  
  sorted.slice(0, 50).forEach(([word, count]) => {
    const percent = ((count / total) * 100).toFixed(1);
    html += `<tr><td>${word}</td><td>${count}</td><td>${percent}%</td></tr>`;
  });
  
  html += `</tbody></table>`;
  html += `<p style="font-size:0.75rem; color:var(--text-muted); margin-top:8px;">総単語数: ${total} / ユニーク: ${sorted.length}</p>`;
  
  resultDiv.innerHTML = html;
  resultDiv.style.display = 'block';
}

// 文字頻度分析
function showCharFrequency() {
  const input = document.getElementById('inputText').value;
  const resultDiv = document.getElementById('word-frequency-result');
  
  if (!input.trim()) {
    resultDiv.style.display = 'none';
    return;
  }
  
  // 文字をカウント（空白・改行除く）
  const chars = input.replace(/[\s\n]/g, '').split('');
  const freq = {};
  chars.forEach(c => freq[c] = (freq[c] || 0) + 1);
  
  const sorted = Object.entries(freq).sort((a, b) => b[1] - a[1]);
  const total = chars.length;
  
  let html = `<table class="word-freq-table">
    <thead>
      <tr><th>文字</th><th>回数</th><th>頻度</th></tr>
    </thead>
    <tbody>`;
  
  sorted.slice(0, 50).forEach(([char, count]) => {
    const percent = ((count / total) * 100).toFixed(1);
    const displayChar = char === ' ' ? '(空白)' : char;
    html += `<tr><td>${displayChar}</td><td>${count}</td><td>${percent}%</td></tr>`;
  });
  
  html += `</tbody></table>`;
  html += `<p style="font-size:0.75rem; color:var(--text-muted); margin-top:8px;">総文字数: ${total} / ユニーク: ${sorted.length}</p>`;
  
  resultDiv.innerHTML = html;
  resultDiv.style.display = 'block';
}

// カスタムカウントのリアルタイム更新
document.addEventListener('DOMContentLoaded', function() {
  const customQueryInput = document.getElementById('count-custom-query');
  const customCaseCheckbox = document.getElementById('count-custom-case');
  
  if (customQueryInput) {
    customQueryInput.addEventListener('input', () => {
      const input = document.getElementById('inputText').value;
      updateCustomCount(input);
    });
  }
  
  if (customCaseCheckbox) {
    customCaseCheckbox.addEventListener('change', () => {
      const input = document.getElementById('inputText').value;
      updateCustomCount(input);
    });
  }
  
  // 入力テキストのリアルタイム更新
  const inputText = document.getElementById('inputText');
  if (inputText) {
    inputText.addEventListener('input', () => {
      updateRealtimeCount();
    });
  }
});

function executeColumnExtract(input) {
  // 旧バージョン互換用（テストで使用）
  return executeColumnExtractMulti();
}

function executeColumnExtractMulti() {
  const input = document.getElementById('inputText').value;
  let colDelimiter = document.getElementById('column-delimiter-text').value;
  
  // エスケープシーケンス対応
  colDelimiter = colDelimiter.replace(/\\t/g, '\t').replace(/\\n/g, '\n');
  
  const colCount = parseInt(document.getElementById('column-count').value) || 4;
  let rowDelimiter = document.getElementById('column-row-delimiter').value;
  rowDelimiter = rowDelimiter.replace(/\\t/g, '\t').replace(/\\n/g, '\n');
  
  const removeColDelim = document.getElementById('column-remove-col-delim').checked;
  const removeRowDelim = document.getElementById('column-remove-row-delim').checked;
  const hasTitle = document.getElementById('column-has-title').checked;
  let titleDelimiter = document.getElementById('column-title-delimiter').value;
  titleDelimiter = titleDelimiter.replace(/\\t/g, '\t').replace(/\\n/g, '\n');
  const removeEmpty = document.getElementById('column-remove-empty').checked;
  const trimValues = document.getElementById('column-trim').checked;
  
  // 行で分割
  const rows = rowDelimiter === '\n' ? input.split('\n') : input.split(rowDelimiter);
  
  // 各列のデータを格納
  const columns = Array.from({ length: colCount }, () => []);
  
  for (const row of rows) {
    if (removeEmpty && row.trim() === '') continue;
    
    let processedRow = row;
    
    // タイトル列の処理
    let title = '';
    if (hasTitle && titleDelimiter) {
      const titleIdx = processedRow.indexOf(titleDelimiter);
      if (titleIdx !== -1) {
        title = processedRow.substring(0, titleIdx);
        processedRow = processedRow.substring(titleIdx + titleDelimiter.length);
      }
    }
    
    const parts = processedRow.split(colDelimiter);
    
    for (let i = 0; i < colCount; i++) {
      let val = parts[i] !== undefined ? parts[i] : '';
      
      // 列区切り文字を削除
      if (removeColDelim && colDelimiter) {
        val = val.replace(new RegExp(escapeRegex(colDelimiter), 'g'), '');
      }
      
      // 行区切り文字を削除
      if (removeRowDelim && rowDelimiter && rowDelimiter !== '\n') {
        val = val.replace(new RegExp(escapeRegex(rowDelimiter), 'g'), '');
      }
      
      if (trimValues) val = val.trim();
      
      // タイトルを最初の列に追加
      if (hasTitle && i === 0 && title) {
        val = title + titleDelimiter + val;
      }
      
      columns[i].push(val);
    }
  }
  
  // 結果テーブルを生成
  const resultsDiv = document.getElementById('column-results');
  
  let html = '<table><tr>';
  for (let i = 0; i < colCount; i++) {
    html += `<th><div class="col-header"><span>Column #${i + 1}</span><button class="btn-copy-col" onclick="copyColumn(${i})">コピー</button></div></th>`;
  }
  html += '</tr><tr>';
  for (let i = 0; i < colCount; i++) {
    html += `<td><textarea id="col-output-${i}" readonly>${columns[i].join('\n')}</textarea></td>`;
  }
  html += '</tr></table>';
  
  resultsDiv.innerHTML = html;
  resultsDiv.style.display = 'block';
  
  return columns[0].join('\n');
}

// 正規表現エスケープ用ヘルパー
function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function copyColumn(colIndex) {
  const textarea = document.getElementById(`col-output-${colIndex}`);
  if (textarea) {
    navigator.clipboard.writeText(textarea.value).then(() => {
      const btn = event.target;
      const originalText = btn.textContent;
      btn.textContent = 'コピー完了!';
      setTimeout(() => btn.textContent = originalText, 1000);
    });
  }
}

function executeFindReplace(input) {
  const findText = document.getElementById('find-text').value;
  const replaceText = document.getElementById('replace-text').value;
  const useRegex = document.getElementById('find-regex').checked;
  const caseSensitive = document.getElementById('find-case').checked;
  
  if (!findText) return input;
  
  if (useRegex) {
    try {
      const flags = caseSensitive ? 'g' : 'gi';
      const regex = new RegExp(findText, flags);
      return input.replace(regex, replaceText);
    } catch(e) {
      return `正規表現エラー: ${e.message}`;
    }
  } else {
    if (caseSensitive) {
      return input.split(findText).join(replaceText);
    } else {
      const regex = new RegExp(findText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
      return input.replace(regex, replaceText);
    }
  }
}

// Line combine (multiple lines to one line)
// Line combination generator (all combinations from multiple lists)
let comboListCount = 3; // 初期リスト数

function updateComboCounts() {
  for (let i = 0; i < comboListCount; i++) {
    const textarea = document.getElementById(`combo-list-${i}`);
    const countSpan = document.getElementById(`combo-count-${i}`);
    if (textarea && countSpan) {
      const lines = textarea.value.split('\n').filter(line => line.trim() !== '');
      countSpan.textContent = lines.length;
    }
  }
  updateCombinationTotal();
}

function updateCombinationTotal() {
  const lists = [];
  for (let i = 0; i < comboListCount; i++) {
    const textarea = document.getElementById(`combo-list-${i}`);
    if (textarea) {
      const lines = textarea.value.split('\n').filter(line => line.trim() !== '');
      if (lines.length > 0) {
        lists.push(lines);
      }
    }
  }
  
  const total = lists.length > 0 ? lists.reduce((acc, list) => acc * list.length, 1) : 0;
  document.getElementById('combination-count').textContent = 
    total > 0 ? `${total.toLocaleString()} 組み合わせ生成予定` : '';
}

function addComboList() {
  const container = document.getElementById('combinationInputs');
  const addBtn = container.querySelector('.combo-add');
  const suffix = container.querySelector('.combo-suffix');
  
  const newIndex = comboListCount;
  
  // 新しい区切り
  const delimDiv = document.createElement('div');
  delimDiv.className = 'combo-item combo-delim';
  delimDiv.dataset.index = newIndex - 1;
  delimDiv.innerHTML = `
    <div class="combo-label">区切り</div>
    <input type="text" class="combo-field combo-delim-field" id="combo-delim-${newIndex - 1}" placeholder="">
  `;
  
  // 新しいリスト
  const listDiv = document.createElement('div');
  listDiv.className = 'combo-item combo-list';
  listDiv.dataset.index = newIndex;
  listDiv.innerHTML = `
    <div class="combo-label">リスト ${newIndex + 1}</div>
    <textarea class="combo-textarea" id="combo-list-${newIndex}" placeholder="各行に1項目"></textarea>
    <div class="combo-count"><span id="combo-count-${newIndex}">0</span> 行</div>
  `;
  
  // Suffixの前に挿入
  container.insertBefore(delimDiv, suffix);
  container.insertBefore(listDiv, suffix);
  
  // イベントリスナー追加
  document.getElementById(`combo-list-${newIndex}`).addEventListener('input', updateComboCounts);
  
  comboListCount++;
}

function clearComboInputs() {
  document.getElementById('combo-prefix').value = '';
  document.getElementById('combo-suffix').value = '';
  for (let i = 0; i < comboListCount; i++) {
    const textarea = document.getElementById(`combo-list-${i}`);
    const delim = document.getElementById(`combo-delim-${i}`);
    if (textarea) textarea.value = '';
    if (delim) delim.value = '';
  }
  updateComboCounts();
}

function executeCombination(input) {
  const prefix = document.getElementById('combo-prefix').value.replace(/\\x/g, '\n');
  const suffix = document.getElementById('combo-suffix').value.replace(/\\x/g, '\n');
  
  // リストを収集
  const lists = [];
  const delimiters = [];
  
  for (let i = 0; i < comboListCount; i++) {
    const textarea = document.getElementById(`combo-list-${i}`);
    if (textarea) {
      const lines = textarea.value.split('\n').filter(line => line.trim() !== '');
      if (lines.length > 0) {
        lists.push(lines);
        // 区切り文字を取得（\xを改行に変換）
        const delimInput = document.getElementById(`combo-delim-${i}`);
        if (delimInput) {
          delimiters.push(delimInput.value.replace(/\\x/g, '\n'));
        }
      }
    }
  }
  
  if (lists.length === 0) {
    document.getElementById('combination-count').textContent = '0 組み合わせ';
    return '';
  }
  
  // 組み合わせ数を計算
  const totalCombinations = lists.reduce((acc, list) => acc * list.length, 1);
  document.getElementById('combination-count').textContent = `${totalCombinations.toLocaleString()} 組み合わせ生成`;
  
  // 警告（大量の組み合わせ）
  if (totalCombinations > 100000) {
    if (!confirm(`${totalCombinations.toLocaleString()} 件の組み合わせが生成されます。続行しますか？`)) {
      return '';
    }
  }
  
  // 全組み合わせを生成
  function generateCombinations(lists, delimiters) {
    if (lists.length === 0) return [''];
    if (lists.length === 1) return lists[0];
    
    const result = [];
    const [first, ...rest] = lists;
    const [firstDelim, ...restDelims] = delimiters;
    const restCombinations = generateCombinations(rest, restDelims);
    
    for (const item of first) {
      for (const combo of restCombinations) {
        result.push(item + (firstDelim || '') + combo);
      }
    }
    return result;
  }
  
  const combinations = generateCombinations(lists, delimiters);
  return combinations.map(combo => prefix + combo + suffix).join('\n');
}

// 初期化時にイベントリスナーを設定
document.addEventListener('DOMContentLoaded', function() {
  for (let i = 0; i < comboListCount; i++) {
    const textarea = document.getElementById(`combo-list-${i}`);
    if (textarea) {
      textarea.addEventListener('input', updateComboCounts);
    }
  }
});

// Remove spaces
function executeRemoveSpaces(input) {
  const trim = document.getElementById('spaces-trim').checked;
  const mode = document.querySelector('input[name="spaces-remove-mode"]:checked').value;
  
  let lines = input.split('\n');
  
  lines = lines.map(line => {
    // トリム
    if (trim) {
      line = line.trim();
    }
    
    // 空白削除モード
    if (mode === 'extra') {
      // 連続する空白を1つに（半角・全角スペース、タブ）
      line = line.replace(/[ 　\t]+/g, ' ');
    } else if (mode === 'all') {
      // すべての空白を削除
      line = line.replace(/[ 　\t]/g, '');
    }
    
    return line;
  });
  
  return lines.join('\n');
}

// Add spaces (実行ボタンから呼び出し用)
function executeAddSpacesMain(input) {
  const addEveryN = document.getElementById('spaces-add-every-n').checked;
  const addAfterChar = document.getElementById('spaces-add-after-char').checked;
  const addAfterLine = document.getElementById('spaces-add-after-line').checked;
  
  let output = input;
  
  // 指定文字の後に空白を追加
  if (addAfterChar) {
    const char = document.getElementById('spaces-after-char').value;
    if (char) {
      const escaped = char.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      output = output.replace(new RegExp(escaped, 'g'), char + ' ');
    }
  }
  
  // N文字ごとに空白を追加
  if (addEveryN) {
    const n = parseInt(document.getElementById('spaces-add-n').value) || 10;
    const lines = output.split('\n');
    output = lines.map(line => {
      let result = '';
      for (let i = 0; i < line.length; i += n) {
        result += line.substring(i, i + n);
        if (i + n < line.length) {
          result += ' ';
        }
      }
      return result;
    }).join('\n');
  }
  
  // 各行の末尾に空白を追加
  if (addAfterLine) {
    output = output.split('\n').map(line => line + ' ').join('\n');
  }
  
  return output;
}

function executeRemoveSpacesOld(input) {
  // This function is no longer used
  return input;
}

// ============================================
// 文字変換関数
// ============================================
function executeConvert(mode) {
  const input = document.getElementById('inputText').value;
  let output = input;
  
  switch(mode) {
    // 大文字/小文字
    case 'lowercase':
      output = input.toLowerCase();
      break;
    case 'uppercase':
      output = input.toUpperCase();
      break;
    case 'randomcase':
      // ランダムに大文字/小文字
      output = input.split('').map(c => Math.random() > 0.5 ? c.toUpperCase() : c.toLowerCase()).join('');
      break;
    case 'studlycaps':
      // 交互に大文字/小文字（StUdLy CaPs）
      let toggle = true;
      output = input.split('').map(c => {
        if (/[a-zA-Z]/.test(c)) {
          const result = toggle ? c.toUpperCase() : c.toLowerCase();
          toggle = !toggle;
          return result;
        }
        return c;
      }).join('');
      break;
    case 'capitalizeWords':
      // 各単語の先頭を大文字
      output = input.replace(/\b\w/g, c => c.toUpperCase());
      break;
    case 'uncapitalizeWords':
      // 各単語の先頭を小文字
      output = input.replace(/\b\w/g, c => c.toLowerCase());
      break;
    case 'capitalizeSentences':
      // 各文の先頭を大文字
      output = input.replace(/(^|[.!?。！？]\s*)\w/g, c => c.toUpperCase());
      break;
    case 'uncapitalizeSentences':
      // 各文の先頭を小文字
      output = input.replace(/(^|[.!?。！？]\s*)\w/g, c => c.toLowerCase());
      break;
    case 'snakeCase':
      // snake_case（行ごとに処理）
      output = input.split('\n').map(line => 
        line
          .replace(/([a-z])([A-Z])/g, '$1_$2')
          .replace(/[\s\-]+/g, '_')
          .toLowerCase()
      ).join('\n');
      break;
    case 'kebabCase':
      // kebab-case（行ごとに処理）
      output = input.split('\n').map(line =>
        line
          .replace(/([a-z])([A-Z])/g, '$1-$2')
          .replace(/[\s_]+/g, '-')
          .toLowerCase()
      ).join('\n');
      break;
    case 'camelCase':
      // camelCase（行ごとに処理）
      output = input.split('\n').map(line =>
        line
          .replace(/[\s_\-]+(.)/g, (_, c) => c.toUpperCase())
          .replace(/^./, c => c.toLowerCase())
      ).join('\n');
      break;
    case 'pascalCase':
      // PascalCase（行ごとに処理）
      output = input.split('\n').map(line =>
        line
          .replace(/[\s_\-]+(.)/g, (_, c) => c.toUpperCase())
          .replace(/^./, c => c.toUpperCase())
      ).join('\n');
      break;
    
    // 全角→半角
    case 'toFullwidth':
      output = toHalfWidth(input);
      break;
    // 半角→全角
    case 'toHalfwidth':
      output = toFullWidth(input);
      break;
    
    // 半角＋ひら→全角・カタカナ
    case 'hiraToFullKata':
      output = toFullWidth(hiraganaToKatakana(input));
      break;
    // 半角＋全カタ→全角・ひらがな
    case 'hiraToHalfKata':
      output = toFullWidth(katakanaToHiragana(input));
      break;
    
    // 全角英数→半角英数
    case 'alphaToFull':
      output = fullAlphaNumToHalf(input);
      break;
    // 半角英数→全角英数
    case 'alphaToHalf':
      output = halfAlphaNumToFull(input);
      break;
    
    // 全角カタカナ→半角カタカナ
    case 'kataToFull':
      output = fullKatakanaToHalf(input);
      break;
    // 半角カタカナ→全角カタカナ
    case 'kataToHalf':
      output = halfKatakanaToFull(input);
      break;
    
    // ひらがな⇔カタカナ
    case 'hiraToKata':
      output = hiraganaToKatakana(input);
      break;
    case 'kataToHira':
      output = katakanaToHiragana(input);
      break;
    
    // ローマ字変換
    case 'romaToHira':
      output = romajiToHiragana(input);
      break;
    case 'romaToKata':
      output = hiraganaToKatakana(romajiToHiragana(input));
      break;
    case 'hiraToRoma':
      output = hiraganaToRomaji(input);
      break;
    
    // TAB⇔空白
    case 'tabToSpace': {
      const tabSpaces = parseInt(document.getElementById('convert-tab-spaces').value) || 4;
      output = input.replace(/\t/g, ' '.repeat(tabSpaces));
      break;
    }
    case 'spaceToTab': {
      const numSpaces = parseInt(document.getElementById('convert-tab-spaces').value) || 4;
      const spaceRegex = new RegExp(' {' + numSpaces + '}', 'g');
      output = input.replace(spaceRegex, '\t');
      break;
    }
    
    // Base64
    case 'base64Encode':
      try {
        // UTF-8対応
        output = btoa(unescape(encodeURIComponent(input)));
      } catch (e) {
        output = 'エンコードエラー: ' + e.message;
      }
      break;
    case 'base64Decode':
      try {
        // UTF-8対応
        output = decodeURIComponent(escape(atob(input.trim())));
      } catch (e) {
        output = 'デコードエラー: 不正なBase64文字列です';
      }
      break;
    
    // Quoted-Printable
    case 'quotedPrintableEncode':
      output = quotedPrintableEncode(input);
      break;
    case 'quotedPrintableDecode':
      output = quotedPrintableDecode(input);
      break;
    
    // URL エンコード
    case 'urlEncode':
      try {
        output = encodeURIComponent(input);
      } catch (e) {
        output = 'エンコードエラー: ' + e.message;
      }
      break;
    case 'urlDecode':
      try {
        output = decodeURIComponent(input);
      } catch (e) {
        output = 'デコードエラー: 不正なURL文字列です';
      }
      break;
    
    // HTMLエンティティ
    case 'htmlEntityEncode':
      output = input
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
      break;
    case 'htmlEntityDecode':
      output = input
        .replace(/&amp;/g, '&')
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/&#x([0-9A-Fa-f]+);/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)))
        .replace(/&#(\d+);/g, (_, dec) => String.fromCharCode(parseInt(dec, 10)));
      break;
  }
  
  document.getElementById('outputText').value = output;
  updateStats('outputText', 'output');
}

// Quoted-Printable エンコード
function quotedPrintableEncode(str) {
  const utf8Bytes = new TextEncoder().encode(str);
  let result = '';
  let lineLen = 0;
  
  for (const byte of utf8Bytes) {
    let encoded;
    // 印刷可能なASCII文字（33-126、ただし=は除く）はそのまま
    if ((byte >= 33 && byte <= 126 && byte !== 61) || byte === 9 || byte === 32) {
      encoded = String.fromCharCode(byte);
    } else {
      encoded = '=' + byte.toString(16).toUpperCase().padStart(2, '0');
    }
    
    // 76文字で折り返し
    if (lineLen + encoded.length > 76) {
      result += '=\r\n';
      lineLen = 0;
    }
    
    result += encoded;
    lineLen += encoded.length;
  }
  
  return result;
}

// Quoted-Printable デコード（エンコーディング指定対応）
function quotedPrintableDecode(str, charset = 'utf-8') {
  try {
    // ソフト改行を削除
    let normalized = str.replace(/=\r?\n/g, '');
    
    // =XX をバイト値に置換して収集
    const bytes = [];
    
    // 正規表現で =XX パターンを処理
    let lastIndex = 0;
    const pattern = /=([0-9A-Fa-f]{2})/g;
    let match;
    
    while ((match = pattern.exec(normalized)) !== null) {
      // マッチ前の通常文字をバイトとして追加
      for (let i = lastIndex; i < match.index; i++) {
        bytes.push(normalized.charCodeAt(i));
      }
      // エンコードされたバイトを追加
      bytes.push(parseInt(match[1], 16));
      lastIndex = match.index + 3;
    }
    
    // 残りの文字を追加
    for (let i = lastIndex; i < normalized.length; i++) {
      bytes.push(normalized.charCodeAt(i));
    }
    
    return decodeBytes(new Uint8Array(bytes), charset);
  } catch (e) {
    return 'デコードエラー: ' + e.message;
  }
}

// バイト配列を指定エンコーディングでデコード
function decodeBytes(bytes, charset = 'utf-8') {
  charset = charset.toLowerCase();
  
  // encoding-japanese ライブラリがある場合はそれを使用
  if (typeof Encoding !== 'undefined') {
    let encoding;
    if (charset === 'iso-2022-jp' || charset === 'jis') {
      encoding = 'JIS';
    } else if (charset === 'shift_jis' || charset === 'sjis' || charset === 'x-sjis') {
      encoding = 'SJIS';
    } else if (charset === 'euc-jp') {
      encoding = 'EUCJP';
    } else {
      encoding = 'UTF8';
    }
    
    try {
      const unicodeArray = Encoding.convert(bytes, {
        to: 'UNICODE',
        from: encoding
      });
      return Encoding.codeToString(unicodeArray);
    } catch (e) {
      // フォールバック
    }
  }
  
  // フォールバック：TextDecoderを使用
  try {
    // ISO-2022-JPはTextDecoderでサポートされていないのでUTF-8で試す
    if (charset === 'iso-2022-jp') {
      return decodeISO2022JP(bytes);
    }
    const decoder = new TextDecoder(charset);
    return decoder.decode(bytes);
  } catch (e) {
    // 最終フォールバック：UTF-8
    return new TextDecoder('utf-8').decode(bytes);
  }
}

// ISO-2022-JP (JIS) デコード（簡易実装）
function decodeISO2022JP(bytes) {
  let result = '';
  let mode = 'ascii'; // 'ascii', 'jisx0208', 'jisx0201'
  let i = 0;
  
  while (i < bytes.length) {
    // エスケープシーケンスの検出
    if (bytes[i] === 0x1B) { // ESC
      if (i + 2 < bytes.length) {
        if (bytes[i + 1] === 0x28 && bytes[i + 2] === 0x42) { // ESC ( B - ASCII
          mode = 'ascii';
          i += 3;
          continue;
        } else if (bytes[i + 1] === 0x28 && bytes[i + 2] === 0x4A) { // ESC ( J - JIS X 0201 Roman
          mode = 'ascii';
          i += 3;
          continue;
        } else if (bytes[i + 1] === 0x24 && bytes[i + 2] === 0x42) { // ESC $ B - JIS X 0208-1983
          mode = 'jisx0208';
          i += 3;
          continue;
        } else if (bytes[i + 1] === 0x24 && bytes[i + 2] === 0x40) { // ESC $ @ - JIS X 0208-1978
          mode = 'jisx0208';
          i += 3;
          continue;
        }
      }
    }
    
    if (mode === 'ascii') {
      result += String.fromCharCode(bytes[i]);
      i++;
    } else if (mode === 'jisx0208') {
      if (i + 1 < bytes.length) {
        const byte1 = bytes[i];
        const byte2 = bytes[i + 1];
        // JIS → Shift_JIS → Unicode 変換
        const sjis = jisToShiftJIS(byte1, byte2);
        const unicode = shiftJISToUnicode(sjis[0], sjis[1]);
        if (unicode) {
          result += unicode;
        } else {
          result += '?';
        }
        i += 2;
      } else {
        i++;
      }
    } else {
      result += String.fromCharCode(bytes[i]);
      i++;
    }
  }
  
  return result;
}

// JIS → Shift_JIS 変換
function jisToShiftJIS(byte1, byte2) {
  let s1, s2;
  if (byte1 % 2 === 1) {
    s1 = Math.floor((byte1 + 1) / 2) + (byte1 < 0x5F ? 0x70 : 0xB0);
    s2 = byte2 + (byte2 < 0x60 ? 0x1F : 0x20);
  } else {
    s1 = Math.floor(byte1 / 2) + (byte1 < 0x5F ? 0x70 : 0xB0);
    s2 = byte2 + 0x7E;
  }
  return [s1, s2];
}

// Shift_JIS → Unicode 変換テーブル（主要な範囲のみ）
function shiftJISToUnicode(byte1, byte2) {
  // encoding-japanese ライブラリを使用（利用可能な場合）
  if (typeof Encoding !== 'undefined') {
    try {
      const bytes = new Uint8Array([byte1, byte2]);
      const unicodeArray = Encoding.convert(bytes, {
        to: 'UNICODE',
        from: 'SJIS'
      });
      return Encoding.codeToString(unicodeArray);
    } catch (e) {
      return null;
    }
  }
  
  // フォールバック：TextDecoderを使用
  try {
    const bytes = new Uint8Array([byte1, byte2]);
    const decoder = new TextDecoder('shift_jis');
    return decoder.decode(bytes);
  } catch (e) {
    return null;
  }
}

// ============================================
// メールデコード機能
// ============================================
function executeMailDecode(mode) {
  const input = document.getElementById('inputText').value;
  let output = '';
  
  switch(mode) {
    case 'header':
      output = decodeMimeHeader(input);
      break;
    case 'subject':
      output = extractAndDecodeSubject(input);
      break;
    case 'body':
      output = decodeMailBody(input);
      break;
    case 'full':
      output = decodeFullMail(input);
      break;
    case 'base64':
      output = decodeBase64Mail(input);
      break;
    case 'qp':
      output = decodeQPMail(input);
      break;
  }
  
  document.getElementById('outputText').value = output;
  updateStats('outputText', 'output');
}

// MIMEエンコードされたヘッダーをデコード
function decodeMimeHeader(str) {
  // =?charset?encoding?encoded_text?= 形式をデコード
  return str.replace(/=\?([^?]+)\?([BQ])\?([^?]*)\?=/gi, (match, charset, encoding, encodedText) => {
    try {
      if (encoding.toUpperCase() === 'B') {
        // Base64
        const binaryStr = atob(encodedText);
        const bytes = new Uint8Array(binaryStr.length);
        for (let i = 0; i < binaryStr.length; i++) {
          bytes[i] = binaryStr.charCodeAt(i);
        }
        return decodeBytes(bytes, charset);
      } else {
        // Quoted-Printable (Q encoding)
        // _ を空白に置換
        const qpText = encodedText.replace(/_/g, ' ');
        return quotedPrintableDecode(qpText, charset);
      }
    } catch (e) {
      return match; // デコード失敗時は元のまま
    }
  });
}

// Subjectヘッダーを抽出してデコード
function extractAndDecodeSubject(str) {
  const lines = str.split(/\r?\n/);
  let subjectLines = [];
  let inSubject = false;
  
  for (const line of lines) {
    if (/^Subject:\s*/i.test(line)) {
      inSubject = true;
      subjectLines.push(line.replace(/^Subject:\s*/i, ''));
    } else if (inSubject) {
      if (/^\s/.test(line)) {
        // 継続行
        subjectLines.push(line.trim());
      } else {
        break;
      }
    }
  }
  
  if (subjectLines.length === 0) {
    return 'Subjectヘッダーが見つかりません';
  }
  
  const subject = subjectLines.join('');
  return decodeMimeHeader(subject);
}

// メール本文をデコード
function decodeMailBody(str) {
  const charsetSelect = document.getElementById('mail-charset').value;
  const encodingSelect = document.getElementById('mail-encoding').value;
  
  let charset = charsetSelect;
  let encoding = encodingSelect;
  
  // 自動検出
  if (charset === 'auto' || encoding === 'auto') {
    const detected = detectMailEncoding(str);
    if (charset === 'auto') charset = detected.charset;
    if (encoding === 'auto') encoding = detected.encoding;
  }
  
  // 転送エンコーディングに応じてデコード
  if (encoding === 'base64') {
    try {
      const cleaned = str.replace(/\s/g, '');
      const binaryStr = atob(cleaned);
      const bytes = new Uint8Array(binaryStr.length);
      for (let i = 0; i < binaryStr.length; i++) {
        bytes[i] = binaryStr.charCodeAt(i);
      }
      return decodeBytes(bytes, charset);
    } catch (e) {
      return 'Base64デコードエラー: ' + e.message;
    }
  } else if (encoding === 'quoted-printable') {
    return quotedPrintableDecode(str, charset);
  } else {
    return decodeBytes(new TextEncoder().encode(str), charset);
  }
}

// メール全体をデコード（ヘッダー + 本文）
function decodeFullMail(str) {
  const lines = str.split(/\r?\n/);
  let headerEnd = 0;
  
  // ヘッダーと本文の境界を探す
  for (let i = 0; i < lines.length; i++) {
    if (lines[i].trim() === '') {
      headerEnd = i;
      break;
    }
  }
  
  const headerPart = lines.slice(0, headerEnd).join('\n');
  const bodyPart = lines.slice(headerEnd + 1).join('\n');
  
  // ヘッダーからContent-TypeとContent-Transfer-Encodingを抽出
  let charset = 'utf-8';
  let encoding = 'none';
  
  const charsetMatch = headerPart.match(/charset=["']?([^"'\s;]+)/i);
  if (charsetMatch) charset = charsetMatch[1];
  
  const encodingMatch = headerPart.match(/Content-Transfer-Encoding:\s*(\S+)/i);
  if (encodingMatch) encoding = encodingMatch[1].toLowerCase();
  
  // ヘッダーをデコード
  const decodedHeader = decodeMimeHeader(headerPart);
  
  // 本文をデコード
  let decodedBody = bodyPart;
  if (encoding === 'base64') {
    try {
      const cleaned = bodyPart.replace(/\s/g, '');
      const binaryStr = atob(cleaned);
      const bytes = new Uint8Array(binaryStr.length);
      for (let i = 0; i < binaryStr.length; i++) {
        bytes[i] = binaryStr.charCodeAt(i);
      }
      decodedBody = decodeBytes(bytes, charset);
    } catch (e) {
      decodedBody = '[Base64デコードエラー]\n' + bodyPart;
    }
  } else if (encoding === 'quoted-printable') {
    decodedBody = quotedPrintableDecode(bodyPart, charset);
  }
  
  return decodedHeader + '\n\n' + decodedBody;
}

// エンコーディング自動検出
function detectMailEncoding(str) {
  let charset = 'utf-8';
  let encoding = 'none';
  
  // Base64っぽいか確認
  if (/^[A-Za-z0-9+/=\s]+$/.test(str.trim()) && str.length > 20) {
    const cleaned = str.replace(/\s/g, '');
    if (cleaned.length % 4 === 0) {
      encoding = 'base64';
    }
  }
  
  // Quoted-Printableっぽいか確認
  if (/=[0-9A-Fa-f]{2}/.test(str)) {
    encoding = 'quoted-printable';
  }
  
  // JISエスケープシーケンスを検出
  if (/\x1B\$[@B]/.test(str) || /\x1B\(B/.test(str)) {
    charset = 'iso-2022-jp';
    encoding = 'none';
  }
  
  return { charset, encoding };
}

// Base64デコード（メール用、エンコーディング指定対応）
function decodeBase64Mail(str) {
  const jisEnabled = document.getElementById('mail-decode-jis').checked;
  const sjisEnabled = document.getElementById('mail-decode-sjis').checked;
  
  try {
    const cleaned = str.replace(/\s/g, '');
    const binaryStr = atob(cleaned);
    const bytes = new Uint8Array(binaryStr.length);
    for (let i = 0; i < binaryStr.length; i++) {
      bytes[i] = binaryStr.charCodeAt(i);
    }
    
    // エンコーディング自動判定
    let charset = 'utf-8';
    
    // JISエスケープシーケンスを検出
    if (jisEnabled) {
      for (let i = 0; i < bytes.length - 2; i++) {
        if (bytes[i] === 0x1B && bytes[i + 1] === 0x24 && (bytes[i + 2] === 0x40 || bytes[i + 2] === 0x42)) {
          charset = 'iso-2022-jp';
          break;
        }
      }
    }
    
    // Shift_JISパターンを検出（先頭がJISでない場合）
    if (charset === 'utf-8' && sjisEnabled) {
      let sjisScore = 0;
      for (let i = 0; i < bytes.length - 1; i++) {
        const b1 = bytes[i];
        const b2 = bytes[i + 1];
        if ((b1 >= 0x81 && b1 <= 0x9F) || (b1 >= 0xE0 && b1 <= 0xFC)) {
          if ((b2 >= 0x40 && b2 <= 0x7E) || (b2 >= 0x80 && b2 <= 0xFC)) {
            sjisScore++;
            i++;
          }
        }
      }
      if (sjisScore > 5) {
        charset = 'shift_jis';
      }
    }
    
    return decodeBytes(bytes, charset);
  } catch (e) {
    return 'Base64デコードエラー: ' + e.message;
  }
}

// Quoted-Printableデコード（メール用）
function decodeQPMail(str) {
  const jisEnabled = document.getElementById('mail-decode-jis').checked;
  const sjisEnabled = document.getElementById('mail-decode-sjis').checked;
  
  // まずバイト配列に戻す（正規表現ベース）
  const normalized = str.replace(/=\r?\n/g, '');
  const bytes = [];
  
  let lastIndex = 0;
  const pattern = /=([0-9A-Fa-f]{2})/g;
  let match;
  
  while ((match = pattern.exec(normalized)) !== null) {
    // マッチ前の通常文字をバイトとして追加
    for (let i = lastIndex; i < match.index; i++) {
      bytes.push(normalized.charCodeAt(i));
    }
    // エンコードされたバイトを追加
    bytes.push(parseInt(match[1], 16));
    lastIndex = match.index + 3;
  }
  
  // 残りの文字を追加
  for (let i = lastIndex; i < normalized.length; i++) {
    bytes.push(normalized.charCodeAt(i));
  }
  
  const byteArray = new Uint8Array(bytes);
  
  // エンコーディング判定
  let charset = 'utf-8';
  
  // JIS検出
  if (jisEnabled) {
    for (let i = 0; i < byteArray.length - 2; i++) {
      if (byteArray[i] === 0x1B && byteArray[i + 1] === 0x24 && (byteArray[i + 2] === 0x40 || byteArray[i + 2] === 0x42)) {
        charset = 'iso-2022-jp';
        break;
      }
    }
  }
  
  // Shift_JIS検出
  if (charset === 'utf-8' && sjisEnabled) {
    let sjisScore = 0;
    for (let i = 0; i < byteArray.length - 1; i++) {
      const b1 = byteArray[i];
      const b2 = byteArray[i + 1];
      if ((b1 >= 0x81 && b1 <= 0x9F) || (b1 >= 0xE0 && b1 <= 0xFC)) {
        if ((b2 >= 0x40 && b2 <= 0x7E) || (b2 >= 0x80 && b2 <= 0xFC)) {
          sjisScore++;
          i++;
        }
      }
    }
    if (sjisScore > 5) {
      charset = 'shift_jis';
    }
  }
  
  return decodeBytes(byteArray, charset);
}

// 全角→半角変換
function toHalfWidth(str) {
  return str
    // 全角英数字→半角
    .replace(/[Ａ-Ｚａ-ｚ０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0))
    // 全角スペース→半角
    .replace(/　/g, ' ')
    // 全角記号→半角
    .replace(/[！-～]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
}

// 半角→全角変換
function toFullWidth(str) {
  return str
    // 半角英数字→全角
    .replace(/[A-Za-z0-9]/g, s => String.fromCharCode(s.charCodeAt(0) + 0xFEE0))
    // 半角スペース→全角
    .replace(/ /g, '　')
    // 半角記号→全角
    .replace(/[!-~]/g, s => String.fromCharCode(s.charCodeAt(0) + 0xFEE0));
}

// ひらがな→カタカナ
function hiraganaToKatakana(str) {
  return str.replace(/[\u3041-\u3096]/g, s => String.fromCharCode(s.charCodeAt(0) + 0x60));
}

// カタカナ→ひらがな
function katakanaToHiragana(str) {
  return str.replace(/[\u30A1-\u30F6]/g, s => String.fromCharCode(s.charCodeAt(0) - 0x60));
}

// ローマ字→ひらがな変換
function romajiToHiragana(str) {
  const romajiMap = {
    // 基本
    'a': 'あ', 'i': 'い', 'u': 'う', 'e': 'え', 'o': 'お',
    'ka': 'か', 'ki': 'き', 'ku': 'く', 'ke': 'け', 'ko': 'こ',
    'sa': 'さ', 'si': 'し', 'shi': 'し', 'su': 'す', 'se': 'せ', 'so': 'そ',
    'ta': 'た', 'ti': 'ち', 'chi': 'ち', 'tu': 'つ', 'tsu': 'つ', 'te': 'て', 'to': 'と',
    'na': 'な', 'ni': 'に', 'nu': 'ぬ', 'ne': 'ね', 'no': 'の',
    'ha': 'は', 'hi': 'ひ', 'hu': 'ふ', 'fu': 'ふ', 'he': 'へ', 'ho': 'ほ',
    'ma': 'ま', 'mi': 'み', 'mu': 'む', 'me': 'め', 'mo': 'も',
    'ya': 'や', 'yu': 'ゆ', 'yo': 'よ',
    'ra': 'ら', 'ri': 'り', 'ru': 'る', 're': 'れ', 'ro': 'ろ',
    'wa': 'わ', 'wi': 'ゐ', 'we': 'ゑ', 'wo': 'を',
    'n': 'ん', "n'": 'ん',
    // 濁音
    'ga': 'が', 'gi': 'ぎ', 'gu': 'ぐ', 'ge': 'げ', 'go': 'ご',
    'za': 'ざ', 'zi': 'じ', 'ji': 'じ', 'zu': 'ず', 'ze': 'ぜ', 'zo': 'ぞ',
    'da': 'だ', 'di': 'ぢ', 'du': 'づ', 'de': 'で', 'do': 'ど',
    'ba': 'ば', 'bi': 'び', 'bu': 'ぶ', 'be': 'べ', 'bo': 'ぼ',
    // 半濁音
    'pa': 'ぱ', 'pi': 'ぴ', 'pu': 'ぷ', 'pe': 'ぺ', 'po': 'ぽ',
    // 拗音
    'kya': 'きゃ', 'kyu': 'きゅ', 'kyo': 'きょ',
    'sha': 'しゃ', 'shu': 'しゅ', 'sho': 'しょ', 'sya': 'しゃ', 'syu': 'しゅ', 'syo': 'しょ',
    'cha': 'ちゃ', 'chu': 'ちゅ', 'cho': 'ちょ', 'tya': 'ちゃ', 'tyu': 'ちゅ', 'tyo': 'ちょ',
    'nya': 'にゃ', 'nyu': 'にゅ', 'nyo': 'にょ',
    'hya': 'ひゃ', 'hyu': 'ひゅ', 'hyo': 'ひょ',
    'mya': 'みゃ', 'myu': 'みゅ', 'myo': 'みょ',
    'rya': 'りゃ', 'ryu': 'りゅ', 'ryo': 'りょ',
    'gya': 'ぎゃ', 'gyu': 'ぎゅ', 'gyo': 'ぎょ',
    'ja': 'じゃ', 'ju': 'じゅ', 'jo': 'じょ', 'jya': 'じゃ', 'jyu': 'じゅ', 'jyo': 'じょ',
    'bya': 'びゃ', 'byu': 'びゅ', 'byo': 'びょ',
    'pya': 'ぴゃ', 'pyu': 'ぴゅ', 'pyo': 'ぴょ',
    // 小文字
    'xa': 'ぁ', 'xi': 'ぃ', 'xu': 'ぅ', 'xe': 'ぇ', 'xo': 'ぉ',
    'la': 'ぁ', 'li': 'ぃ', 'lu': 'ぅ', 'le': 'ぇ', 'lo': 'ぉ',
    'xya': 'ゃ', 'xyu': 'ゅ', 'xyo': 'ょ',
    'lya': 'ゃ', 'lyu': 'ゅ', 'lyo': 'ょ',
    'xtu': 'っ', 'xtsu': 'っ', 'ltu': 'っ', 'ltsu': 'っ',
    // 特殊
    'fa': 'ふぁ', 'fi': 'ふぃ', 'fe': 'ふぇ', 'fo': 'ふぉ',
    'ti': 'てぃ', 'di': 'でぃ',
    'va': 'ゔぁ', 'vi': 'ゔぃ', 'vu': 'ゔ', 've': 'ゔぇ', 'vo': 'ゔぉ',
    '-': 'ー'
  };
  
  let result = str.toLowerCase();
  
  // 促音処理（子音の重なり）
  result = result.replace(/([kstcnhfmyrwgzdbp])\1/g, 'っ$1');
  // tch → っch
  result = result.replace(/tch/g, 'っch');
  
  // 長い順にソートしてマッチング
  const sortedKeys = Object.keys(romajiMap).sort((a, b) => b.length - a.length);
  
  for (const romaji of sortedKeys) {
    const regex = new RegExp(romaji, 'g');
    result = result.replace(regex, romajiMap[romaji]);
  }
  
  // 残った 'n' を処理（母音や'y'の前以外）
  result = result.replace(/n(?![aiueoy])/g, 'ん');
  
  return result;
}

// ひらがな→ローマ字変換
function hiraganaToRomaji(str) {
  const hiraganaMap = {
    'あ': 'a', 'い': 'i', 'う': 'u', 'え': 'e', 'お': 'o',
    'か': 'ka', 'き': 'ki', 'く': 'ku', 'け': 'ke', 'こ': 'ko',
    'さ': 'sa', 'し': 'shi', 'す': 'su', 'せ': 'se', 'そ': 'so',
    'た': 'ta', 'ち': 'chi', 'つ': 'tsu', 'て': 'te', 'と': 'to',
    'な': 'na', 'に': 'ni', 'ぬ': 'nu', 'ね': 'ne', 'の': 'no',
    'は': 'ha', 'ひ': 'hi', 'ふ': 'fu', 'へ': 'he', 'ほ': 'ho',
    'ま': 'ma', 'み': 'mi', 'む': 'mu', 'め': 'me', 'も': 'mo',
    'や': 'ya', 'ゆ': 'yu', 'よ': 'yo',
    'ら': 'ra', 'り': 'ri', 'る': 'ru', 'れ': 're', 'ろ': 'ro',
    'わ': 'wa', 'ゐ': 'wi', 'ゑ': 'we', 'を': 'wo',
    'ん': 'n',
    'が': 'ga', 'ぎ': 'gi', 'ぐ': 'gu', 'げ': 'ge', 'ご': 'go',
    'ざ': 'za', 'じ': 'ji', 'ず': 'zu', 'ぜ': 'ze', 'ぞ': 'zo',
    'だ': 'da', 'ぢ': 'di', 'づ': 'du', 'で': 'de', 'ど': 'do',
    'ば': 'ba', 'び': 'bi', 'ぶ': 'bu', 'べ': 'be', 'ぼ': 'bo',
    'ぱ': 'pa', 'ぴ': 'pi', 'ぷ': 'pu', 'ぺ': 'pe', 'ぽ': 'po',
    // 拗音
    'きゃ': 'kya', 'きゅ': 'kyu', 'きょ': 'kyo',
    'しゃ': 'sha', 'しゅ': 'shu', 'しょ': 'sho',
    'ちゃ': 'cha', 'ちゅ': 'chu', 'ちょ': 'cho',
    'にゃ': 'nya', 'にゅ': 'nyu', 'にょ': 'nyo',
    'ひゃ': 'hya', 'ひゅ': 'hyu', 'ひょ': 'hyo',
    'みゃ': 'mya', 'みゅ': 'myu', 'みょ': 'myo',
    'りゃ': 'rya', 'りゅ': 'ryu', 'りょ': 'ryo',
    'ぎゃ': 'gya', 'ぎゅ': 'gyu', 'ぎょ': 'gyo',
    'じゃ': 'ja', 'じゅ': 'ju', 'じょ': 'jo',
    'びゃ': 'bya', 'びゅ': 'byu', 'びょ': 'byo',
    'ぴゃ': 'pya', 'ぴゅ': 'pyu', 'ぴょ': 'pyo',
    // 小文字
    'ぁ': 'a', 'ぃ': 'i', 'ぅ': 'u', 'ぇ': 'e', 'ぉ': 'o',
    'ゃ': 'ya', 'ゅ': 'yu', 'ょ': 'yo',
    'っ': '',
    // 特殊
    'ふぁ': 'fa', 'ふぃ': 'fi', 'ふぇ': 'fe', 'ふぉ': 'fo',
    'てぃ': 'ti', 'でぃ': 'di',
    'ゔ': 'vu',
    'ー': '-'
  };
  
  // カタカナをひらがなに変換
  let result = katakanaToHiragana(str);
  
  // 長い順にソートしてマッチング（拗音を先に処理）
  const sortedKeys = Object.keys(hiraganaMap).sort((a, b) => b.length - a.length);
  
  for (const hira of sortedKeys) {
    const regex = new RegExp(hira, 'g');
    result = result.replace(regex, hiraganaMap[hira]);
  }
  
  // 促音処理（次の子音を重ねる）
  result = result.replace(/っ([kstcnhfmyrwgzdbpj])/g, '$1$1');
  result = result.replace(/っ/g, '');  // 残った促音を削除
  
  // 'n' の後に母音や 'y' が来る場合は "n'" に
  result = result.replace(/n([aiueoy])/g, "n'$1");
  
  return result;
}

// 全角英数→半角英数
function fullAlphaNumToHalf(str) {
  return str.replace(/[Ａ-Ｚａ-ｚ０-９]/g, s => String.fromCharCode(s.charCodeAt(0) - 0xFEE0));
}

// 半角英数→全角英数
function halfAlphaNumToFull(str) {
  return str.replace(/[A-Za-z0-9]/g, s => String.fromCharCode(s.charCodeAt(0) + 0xFEE0));
}

// 全角カタカナ→半角カタカナ
function fullKatakanaToHalf(str) {
  const kanaMap = {
    'ア': 'ｱ', 'イ': 'ｲ', 'ウ': 'ｳ', 'エ': 'ｴ', 'オ': 'ｵ',
    'カ': 'ｶ', 'キ': 'ｷ', 'ク': 'ｸ', 'ケ': 'ｹ', 'コ': 'ｺ',
    'サ': 'ｻ', 'シ': 'ｼ', 'ス': 'ｽ', 'セ': 'ｾ', 'ソ': 'ｿ',
    'タ': 'ﾀ', 'チ': 'ﾁ', 'ツ': 'ﾂ', 'テ': 'ﾃ', 'ト': 'ﾄ',
    'ナ': 'ﾅ', 'ニ': 'ﾆ', 'ヌ': 'ﾇ', 'ネ': 'ﾈ', 'ノ': 'ﾉ',
    'ハ': 'ﾊ', 'ヒ': 'ﾋ', 'フ': 'ﾌ', 'ヘ': 'ﾍ', 'ホ': 'ﾎ',
    'マ': 'ﾏ', 'ミ': 'ﾐ', 'ム': 'ﾑ', 'メ': 'ﾒ', 'モ': 'ﾓ',
    'ヤ': 'ﾔ', 'ユ': 'ﾕ', 'ヨ': 'ﾖ',
    'ラ': 'ﾗ', 'リ': 'ﾘ', 'ル': 'ﾙ', 'レ': 'ﾚ', 'ロ': 'ﾛ',
    'ワ': 'ﾜ', 'ヲ': 'ｦ', 'ン': 'ﾝ',
    'ァ': 'ｧ', 'ィ': 'ｨ', 'ゥ': 'ｩ', 'ェ': 'ｪ', 'ォ': 'ｫ',
    'ッ': 'ｯ', 'ャ': 'ｬ', 'ュ': 'ｭ', 'ョ': 'ｮ',
    'ガ': 'ｶﾞ', 'ギ': 'ｷﾞ', 'グ': 'ｸﾞ', 'ゲ': 'ｹﾞ', 'ゴ': 'ｺﾞ',
    'ザ': 'ｻﾞ', 'ジ': 'ｼﾞ', 'ズ': 'ｽﾞ', 'ゼ': 'ｾﾞ', 'ゾ': 'ｿﾞ',
    'ダ': 'ﾀﾞ', 'ヂ': 'ﾁﾞ', 'ヅ': 'ﾂﾞ', 'デ': 'ﾃﾞ', 'ド': 'ﾄﾞ',
    'バ': 'ﾊﾞ', 'ビ': 'ﾋﾞ', 'ブ': 'ﾌﾞ', 'ベ': 'ﾍﾞ', 'ボ': 'ﾎﾞ',
    'パ': 'ﾊﾟ', 'ピ': 'ﾋﾟ', 'プ': 'ﾌﾟ', 'ペ': 'ﾍﾟ', 'ポ': 'ﾎﾟ',
    'ヴ': 'ｳﾞ', 'ー': 'ｰ', '。': '｡', '、': '､', '「': '｢', '」': '｣'
  };
  return str.replace(/[ア-ヴー。、「」]/g, s => kanaMap[s] || s);
}

// 半角カタカナ→全角カタカナ
function halfKatakanaToFull(str) {
  const kanaMap = {
    'ｱ': 'ア', 'ｲ': 'イ', 'ｳ': 'ウ', 'ｴ': 'エ', 'ｵ': 'オ',
    'ｶ': 'カ', 'ｷ': 'キ', 'ｸ': 'ク', 'ｹ': 'ケ', 'ｺ': 'コ',
    'ｻ': 'サ', 'ｼ': 'シ', 'ｽ': 'ス', 'ｾ': 'セ', 'ｿ': 'ソ',
    'ﾀ': 'タ', 'ﾁ': 'チ', 'ﾂ': 'ツ', 'ﾃ': 'テ', 'ﾄ': 'ト',
    'ﾅ': 'ナ', 'ﾆ': 'ニ', 'ﾇ': 'ヌ', 'ﾈ': 'ネ', 'ﾉ': 'ノ',
    'ﾊ': 'ハ', 'ﾋ': 'ヒ', 'ﾌ': 'フ', 'ﾍ': 'ヘ', 'ﾎ': 'ホ',
    'ﾏ': 'マ', 'ﾐ': 'ミ', 'ﾑ': 'ム', 'ﾒ': 'メ', 'ﾓ': 'モ',
    'ﾔ': 'ヤ', 'ﾕ': 'ユ', 'ﾖ': 'ヨ',
    'ﾗ': 'ラ', 'ﾘ': 'リ', 'ﾙ': 'ル', 'ﾚ': 'レ', 'ﾛ': 'ロ',
    'ﾜ': 'ワ', 'ｦ': 'ヲ', 'ﾝ': 'ン',
    'ｧ': 'ァ', 'ｨ': 'ィ', 'ｩ': 'ゥ', 'ｪ': 'ェ', 'ｫ': 'ォ',
    'ｯ': 'ッ', 'ｬ': 'ャ', 'ｭ': 'ュ', 'ｮ': 'ョ',
    'ｰ': 'ー', '｡': '。', '､': '、', '｢': '「', '｣': '」'
  };
  // 濁点・半濁点の処理
  return str
    .replace(/ｶﾞ/g, 'ガ').replace(/ｷﾞ/g, 'ギ').replace(/ｸﾞ/g, 'グ').replace(/ｹﾞ/g, 'ゲ').replace(/ｺﾞ/g, 'ゴ')
    .replace(/ｻﾞ/g, 'ザ').replace(/ｼﾞ/g, 'ジ').replace(/ｽﾞ/g, 'ズ').replace(/ｾﾞ/g, 'ゼ').replace(/ｿﾞ/g, 'ゾ')
    .replace(/ﾀﾞ/g, 'ダ').replace(/ﾁﾞ/g, 'ヂ').replace(/ﾂﾞ/g, 'ヅ').replace(/ﾃﾞ/g, 'デ').replace(/ﾄﾞ/g, 'ド')
    .replace(/ﾊﾞ/g, 'バ').replace(/ﾋﾞ/g, 'ビ').replace(/ﾌﾞ/g, 'ブ').replace(/ﾍﾞ/g, 'ベ').replace(/ﾎﾞ/g, 'ボ')
    .replace(/ﾊﾟ/g, 'パ').replace(/ﾋﾟ/g, 'ピ').replace(/ﾌﾟ/g, 'プ').replace(/ﾍﾟ/g, 'ペ').replace(/ﾎﾟ/g, 'ポ')
    .replace(/ｳﾞ/g, 'ヴ')
    .replace(/[ｱ-ﾝｧ-ｮｰ｡､｢｣]/g, s => kanaMap[s] || s);
}

// ============================================
// 正規表現テスター
// ============================================
function getRegexFlags() {
  let flags = '';
  if (document.getElementById('regex-flag-g').checked) flags += 'g';
  if (document.getElementById('regex-flag-i').checked) flags += 'i';
  if (document.getElementById('regex-flag-m').checked) flags += 'm';
  if (document.getElementById('regex-flag-s').checked) flags += 's';
  return flags;
}

function executeRegexTest() {
  const input = document.getElementById('inputText').value;
  const pattern = document.getElementById('regex-pattern').value;
  const resultDiv = document.getElementById('regex-result');
  
  if (!pattern) {
    resultDiv.innerHTML = '<span style="color:#888">パターンを入力してください</span>';
    return;
  }
  
  try {
    const flags = getRegexFlags();
    const regex = new RegExp(pattern, flags);
    const matches = input.match(regex);
    
    if (matches) {
      resultDiv.innerHTML = `<span style="color:green">✓ ${matches.length}件のマッチ</span>\n\n`;
      
      // マッチ位置を表示
      let highlightedText = input;
      const globalRegex = new RegExp(pattern, flags.includes('g') ? flags : flags + 'g');
      let match;
      const matchList = [];
      
      while ((match = globalRegex.exec(input)) !== null) {
        matchList.push({
          text: match[0],
          index: match.index,
          groups: match.slice(1)
        });
        if (!flags.includes('g')) break;
      }
      
      resultDiv.innerHTML += `<strong>マッチ一覧:</strong>\n`;
      matchList.forEach((m, i) => {
        resultDiv.innerHTML += `${i + 1}. "${m.text}" (位置: ${m.index})`;
        if (m.groups.length > 0) {
          resultDiv.innerHTML += ` グループ: [${m.groups.map((g, j) => `$${j+1}="${g || ''}"`).join(', ')}]`;
        }
        resultDiv.innerHTML += '\n';
      });
    } else {
      resultDiv.innerHTML = '<span style="color:#c44">✗ マッチなし</span>';
    }
  } catch (e) {
    resultDiv.innerHTML = `<span style="color:red">エラー: ${e.message}</span>`;
  }
}

function executeRegexExtract() {
  const input = document.getElementById('inputText').value;
  const pattern = document.getElementById('regex-pattern').value;
  
  if (!pattern) {
    document.getElementById('regex-result').innerHTML = '<span style="color:#888">パターンを入力してください</span>';
    return;
  }
  
  try {
    const flags = getRegexFlags();
    const regex = new RegExp(pattern, flags.includes('g') ? flags : flags + 'g');
    const matches = input.match(regex);
    
    if (matches) {
      document.getElementById('outputText').value = matches.join('\n');
      updateStats('outputText', 'output');
      document.getElementById('regex-result').innerHTML = `<span style="color:green">✓ ${matches.length}件を抽出しました</span>`;
    } else {
      document.getElementById('regex-result').innerHTML = '<span style="color:#c44">✗ マッチなし</span>';
    }
  } catch (e) {
    document.getElementById('regex-result').innerHTML = `<span style="color:red">エラー: ${e.message}</span>`;
  }
}

function executeRegexReplace() {
  const input = document.getElementById('inputText').value;
  const pattern = document.getElementById('regex-pattern').value;
  const replacement = document.getElementById('regex-replace').value;
  
  if (!pattern) {
    document.getElementById('regex-result').innerHTML = '<span style="color:#888">パターンを入力してください</span>';
    return;
  }
  
  try {
    const flags = getRegexFlags();
    const regex = new RegExp(pattern, flags);
    const result = input.replace(regex, replacement);
    const matchCount = (input.match(new RegExp(pattern, flags.includes('g') ? flags : flags + 'g')) || []).length;
    
    document.getElementById('outputText').value = result;
    updateStats('outputText', 'output');
    document.getElementById('regex-result').innerHTML = `<span style="color:green">✓ ${matchCount}件を置換しました</span>`;
  } catch (e) {
    document.getElementById('regex-result').innerHTML = `<span style="color:red">エラー: ${e.message}</span>`;
  }
}

// ============================================
// Markdown/HTML変換
// ============================================
function executeMdHtml(mode) {
  const input = document.getElementById('inputText').value;
  let output = '';
  
  switch(mode) {
    case 'mdToHtml':
      output = markdownToHtml(input);
      break;
    case 'htmlToMd':
      output = htmlToMarkdown(input);
      break;
    case 'preview':
      const html = markdownToHtml(input);
      document.getElementById('md-preview').innerHTML = html;
      document.getElementById('md-preview-section').style.display = 'block';
      return;
  }
  
  document.getElementById('outputText').value = output;
  updateStats('outputText', 'output');
}

function closeMdPreview() {
  document.getElementById('md-preview-section').style.display = 'none';
}

function markdownToHtml(md) {
  let html = md;
  
  // コードブロック（先に処理）
  html = html.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code class="language-$1">$2</code></pre>');
  
  // 見出し
  html = html.replace(/^###### (.+)$/gm, '<h6>$1</h6>');
  html = html.replace(/^##### (.+)$/gm, '<h5>$1</h5>');
  html = html.replace(/^#### (.+)$/gm, '<h4>$1</h4>');
  html = html.replace(/^### (.+)$/gm, '<h3>$1</h3>');
  html = html.replace(/^## (.+)$/gm, '<h2>$1</h2>');
  html = html.replace(/^# (.+)$/gm, '<h1>$1</h1>');
  
  // 水平線
  html = html.replace(/^(-{3,}|\*{3,}|_{3,})$/gm, '<hr>');
  
  // 太字・斜体・取消線
  html = html.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
  html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
  html = html.replace(/~~(.+?)~~/g, '<del>$1</del>');
  html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
  
  // リンクと画像
  html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1">');
  html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
  
  // 引用
  html = html.replace(/^> (.+)$/gm, '<blockquote>$1</blockquote>');
  html = html.replace(/<\/blockquote>\n<blockquote>/g, '\n');
  
  // リスト
  html = html.replace(/^\* (.+)$/gm, '<li>$1</li>');
  html = html.replace(/^- (.+)$/gm, '<li>$1</li>');
  html = html.replace(/^\d+\. (.+)$/gm, '<li>$1</li>');
  html = html.replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>');
  
  // 段落
  html = html.replace(/\n\n+/g, '</p><p>');
  html = '<p>' + html + '</p>';
  html = html.replace(/<p><(h[1-6]|ul|ol|blockquote|pre|hr)/g, '<$1');
  html = html.replace(/<\/(h[1-6]|ul|ol|blockquote|pre)><\/p>/g, '</$1>');
  html = html.replace(/<hr><\/p>/g, '<hr>');
  html = html.replace(/<p><\/p>/g, '');
  
  return html;
}

function htmlToMarkdown(html) {
  let md = html;
  
  // 改行を正規化
  md = md.replace(/\r\n/g, '\n');
  
  // 見出し
  md = md.replace(/<h1[^>]*>(.+?)<\/h1>/gi, '# $1\n');
  md = md.replace(/<h2[^>]*>(.+?)<\/h2>/gi, '## $1\n');
  md = md.replace(/<h3[^>]*>(.+?)<\/h3>/gi, '### $1\n');
  md = md.replace(/<h4[^>]*>(.+?)<\/h4>/gi, '#### $1\n');
  md = md.replace(/<h5[^>]*>(.+?)<\/h5>/gi, '##### $1\n');
  md = md.replace(/<h6[^>]*>(.+?)<\/h6>/gi, '###### $1\n');
  
  // 太字・斜体
  md = md.replace(/<strong[^>]*>(.+?)<\/strong>/gi, '**$1**');
  md = md.replace(/<b[^>]*>(.+?)<\/b>/gi, '**$1**');
  md = md.replace(/<em[^>]*>(.+?)<\/em>/gi, '*$1*');
  md = md.replace(/<i[^>]*>(.+?)<\/i>/gi, '*$1*');
  md = md.replace(/<del[^>]*>(.+?)<\/del>/gi, '~~$1~~');
  md = md.replace(/<s[^>]*>(.+?)<\/s>/gi, '~~$1~~');
  
  // コード
  md = md.replace(/<code[^>]*>(.+?)<\/code>/gi, '`$1`');
  md = md.replace(/<pre[^>]*><code[^>]*>([\s\S]*?)<\/code><\/pre>/gi, '```\n$1\n```');
  
  // リンクと画像
  md = md.replace(/<a[^>]*href="([^"]*)"[^>]*>(.+?)<\/a>/gi, '[$2]($1)');
  md = md.replace(/<img[^>]*src="([^"]*)"[^>]*alt="([^"]*)"[^>]*\/?>/gi, '![$2]($1)');
  md = md.replace(/<img[^>]*alt="([^"]*)"[^>]*src="([^"]*)"[^>]*\/?>/gi, '![$1]($2)');
  
  // リスト
  md = md.replace(/<li[^>]*>(.+?)<\/li>/gi, '- $1\n');
  md = md.replace(/<\/?[uo]l[^>]*>/gi, '');
  
  // 引用
  md = md.replace(/<blockquote[^>]*>([\s\S]*?)<\/blockquote>/gi, (_, content) => {
    return content.split('\n').map(line => '> ' + line.trim()).join('\n') + '\n';
  });
  
  // 水平線
  md = md.replace(/<hr[^>]*\/?>/gi, '---\n');
  
  // 段落とその他のタグを削除
  md = md.replace(/<p[^>]*>/gi, '');
  md = md.replace(/<\/p>/gi, '\n\n');
  md = md.replace(/<br[^>]*\/?>/gi, '\n');
  md = md.replace(/<[^>]+>/g, '');
  
  // HTMLエンティティをデコード
  md = md.replace(/&lt;/g, '<');
  md = md.replace(/&gt;/g, '>');
  md = md.replace(/&amp;/g, '&');
  md = md.replace(/&quot;/g, '"');
  md = md.replace(/&#39;/g, "'");
  
  // 余分な空行を整理
  md = md.replace(/\n{3,}/g, '\n\n');
  md = md.trim();
  
  return md;
}

// ============================================
// SQL整形関数
// ============================================
function executeSqlFormat(mode) {
  const input = document.getElementById('inputText').value;
  let output = '';
  
  const indentType = document.getElementById('sql-indent-type').value.replace('\\t', '\t');
  const uppercaseKeywords = document.getElementById('sql-uppercase-keywords').checked;
  const newlineBeforeAnd = document.getElementById('sql-newline-before-and').checked;
  const newlineAfterComma = document.getElementById('sql-newline-after-comma').checked;
  
  switch(mode) {
    case 'format':
      output = formatSql(input, {
        indent: indentType,
        uppercaseKeywords,
        newlineBeforeAnd,
        newlineAfterComma
      });
      break;
    case 'minify':
      output = minifySql(input);
      break;
    case 'toInsert':
      output = valuesToInsert(input);
      break;
    case 'toInClause':
      output = valuesToInClause(input);
      break;
  }
  
  document.getElementById('outputText').value = output;
  updateStats('outputText', 'output');
}

// SQLキーワード
const SQL_KEYWORDS = [
  'SELECT', 'FROM', 'WHERE', 'AND', 'OR', 'NOT', 'IN', 'IS', 'NULL',
  'JOIN', 'LEFT', 'RIGHT', 'INNER', 'OUTER', 'FULL', 'CROSS', 'ON',
  'GROUP', 'BY', 'HAVING', 'ORDER', 'ASC', 'DESC', 'LIMIT', 'OFFSET',
  'INSERT', 'INTO', 'VALUES', 'UPDATE', 'SET', 'DELETE',
  'CREATE', 'TABLE', 'DROP', 'ALTER', 'ADD', 'COLUMN',
  'PRIMARY', 'KEY', 'FOREIGN', 'REFERENCES', 'INDEX', 'UNIQUE',
  'AS', 'DISTINCT', 'ALL', 'UNION', 'EXCEPT', 'INTERSECT',
  'CASE', 'WHEN', 'THEN', 'ELSE', 'END', 'BETWEEN', 'LIKE', 'EXISTS',
  'COUNT', 'SUM', 'AVG', 'MIN', 'MAX', 'COALESCE', 'NULLIF',
  'CAST', 'CONVERT', 'SUBSTRING', 'TRIM', 'UPPER', 'LOWER'
];

// 主要キーワード（改行を入れる）
const MAJOR_KEYWORDS = [
  'SELECT', 'FROM', 'WHERE', 'JOIN', 'LEFT JOIN', 'RIGHT JOIN', 
  'INNER JOIN', 'OUTER JOIN', 'FULL JOIN', 'CROSS JOIN',
  'GROUP BY', 'HAVING', 'ORDER BY', 'LIMIT', 'OFFSET',
  'INSERT INTO', 'VALUES', 'UPDATE', 'SET', 'DELETE FROM',
  'UNION', 'UNION ALL', 'EXCEPT', 'INTERSECT'
];

function formatSql(sql, options) {
  let formatted = sql.trim();
  
  // 複数の空白を1つに
  formatted = formatted.replace(/\s+/g, ' ');
  
  // キーワードを大文字に
  if (options.uppercaseKeywords) {
    SQL_KEYWORDS.forEach(kw => {
      const regex = new RegExp('\\b' + kw + '\\b', 'gi');
      formatted = formatted.replace(regex, kw);
    });
  }
  
  // 主要キーワードの前で改行
  MAJOR_KEYWORDS.forEach(kw => {
    const regex = new RegExp('\\s+(' + kw.replace(' ', '\\s+') + ')\\b', 'gi');
    formatted = formatted.replace(regex, '\n$1');
  });
  
  // AND/ORの前で改行
  if (options.newlineBeforeAnd) {
    formatted = formatted.replace(/\s+(AND|OR)\s+/gi, (match, kw) => {
      return '\n' + options.indent + (options.uppercaseKeywords ? kw.toUpperCase() : kw) + ' ';
    });
  }
  
  // カンマの後で改行（SELECT句）
  if (options.newlineAfterComma) {
    // SELECT と FROM の間のカンマを処理
    formatted = formatted.replace(/SELECT\s+([\s\S]*?)\s+FROM/gi, (match, cols) => {
      const formattedCols = cols.replace(/,\s*/g, ',\n' + options.indent);
      return 'SELECT ' + formattedCols + '\nFROM';
    });
  }
  
  // インデント追加
  const lines = formatted.split('\n');
  let indentLevel = 0;
  const result = lines.map(line => {
    line = line.trim();
    
    // 閉じ括弧でインデント減少
    const closeBrackets = (line.match(/\)/g) || []).length;
    const openBrackets = (line.match(/\(/g) || []).length;
    
    if (closeBrackets > openBrackets) {
      indentLevel = Math.max(0, indentLevel - (closeBrackets - openBrackets));
    }
    
    const indentedLine = options.indent.repeat(indentLevel) + line;
    
    // 開き括弧でインデント増加
    if (openBrackets > closeBrackets) {
      indentLevel += (openBrackets - closeBrackets);
    }
    
    return indentedLine;
  });
  
  return result.join('\n');
}

function minifySql(sql) {
  return sql
    .replace(/--.*$/gm, '')  // 単一行コメント削除
    .replace(/\/\*[\s\S]*?\*\//g, '')  // 複数行コメント削除
    .replace(/\s+/g, ' ')  // 複数空白を1つに
    .replace(/\s*([,()])\s*/g, '$1')  // 括弧・カンマ周りの空白削除
    .replace(/\s*([=<>!]+)\s*/g, ' $1 ')  // 演算子周りは1つの空白
    .trim();
}

function valuesToInsert(input) {
  const tableName = document.getElementById('sql-table-name').value || 'table_name';
  const quoteValues = document.getElementById('sql-quote-values').checked;
  const quoteChar = document.getElementById('sql-quote-char').value;
  
  const lines = input.split('\n').filter(l => l.trim());
  
  if (lines.length === 0) return '';
  
  const values = lines.map(line => {
    const val = line.trim();
    if (quoteValues) {
      // クォート文字をエスケープ
      const escaped = val.replace(new RegExp(quoteChar, 'g'), quoteChar + quoteChar);
      return quoteChar + escaped + quoteChar;
    }
    return val;
  });
  
  return `INSERT INTO ${tableName} VALUES\n(${values.join('),\n(')});`;
}

function valuesToInClause(input) {
  const columnName = document.getElementById('sql-column-name').value || 'column_name';
  const quoteValues = document.getElementById('sql-quote-values').checked;
  const quoteChar = document.getElementById('sql-quote-char').value;
  
  const lines = input.split('\n').filter(l => l.trim());
  
  if (lines.length === 0) return '';
  
  const values = lines.map(line => {
    const val = line.trim();
    if (quoteValues) {
      const escaped = val.replace(new RegExp(quoteChar, 'g'), quoteChar + quoteChar);
      return quoteChar + escaped + quoteChar;
    }
    return val;
  });
  
  return `${columnName} IN (\n  ${values.join(',\n  ')}\n)`;
}

// ============================================
// 行操作関数
// ============================================
function executeLineOps(mode) {
  const input = document.getElementById('inputText').value;
  let lines = input.split('\n');
  let output = '';
  
  switch(mode) {
    case 'trimLeft':
      output = lines.map(line => line.replace(/^[\s　]+/, '')).join('\n');
      break;
    case 'trimRight':
      output = lines.map(line => line.replace(/[\s　]+$/, '')).join('\n');
      break;
    
    // ソート機能
    case 'sortAlpha':
    case 'sortAlphaCase':
    case 'sortNatural':
    case 'sortNaturalCase':
    case 'sortLength':
    case 'sortRandom':
    case 'sortReverse':
    case 'sortAsc':
    case 'sortDesc': {
      const delimiter = document.getElementById('sort-delimiter').value;
      const colNum = parseInt(document.getElementById('sort-column').value) - 1 || 0;
      const desc = document.getElementById('sort-desc').checked;
      
      // ソート用のキーを取得する関数
      const getKey = (line) => {
        if (delimiter) {
          const parts = line.split(delimiter);
          return parts[colNum] !== undefined ? parts[colNum] : line;
        }
        return line;
      };
      
      let sortFn;
      
      switch (mode) {
        case 'sortAlpha':
        case 'sortAsc':
          // アルファベット順（大文字小文字区別なし）
          sortFn = (a, b) => getKey(a).localeCompare(getKey(b), 'ja', { sensitivity: 'base' });
          break;
        case 'sortAlphaCase':
          // アルファベット順（大文字小文字区別あり）- ASCII順
          sortFn = (a, b) => {
            const keyA = getKey(a), keyB = getKey(b);
            return keyA < keyB ? -1 : keyA > keyB ? 1 : 0;
          };
          break;
        case 'sortNatural':
          // 自然順ソート（大文字小文字区別なし）- 数字を数値として扱う
          sortFn = (a, b) => getKey(a).localeCompare(getKey(b), 'ja', { numeric: true, sensitivity: 'base' });
          break;
        case 'sortNaturalCase':
          // 自然順ソート（大文字小文字区別あり）- 数字を数値として扱い、ASCII順
          sortFn = (a, b) => {
            const keyA = getKey(a), keyB = getKey(b);
            const re = /(\d+)|(\D+)/g;
            const aParts = keyA.match(re) || [];
            const bParts = keyB.match(re) || [];
            
            for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
              const aPart = aParts[i] || '';
              const bPart = bParts[i] || '';
              
              const aNum = parseInt(aPart);
              const bNum = parseInt(bPart);
              
              if (!isNaN(aNum) && !isNaN(bNum)) {
                if (aNum !== bNum) return aNum - bNum;
              } else {
                if (aPart !== bPart) return aPart < bPart ? -1 : 1;
              }
            }
            return 0;
          };
          break;
        case 'sortLength':
          // 文字数順
          sortFn = (a, b) => getKey(a).length - getKey(b).length;
          break;
        case 'sortRandom':
          // ランダム
          sortFn = () => Math.random() - 0.5;
          break;
        case 'sortReverse':
          // 逆順（現在の順序を反転）
          output = lines.reverse().join('\n');
          break;
        case 'sortDesc':
          // 降順（後方互換）
          sortFn = (a, b) => getKey(b).localeCompare(getKey(a), 'ja', { numeric: true });
          break;
      }
      
      if (mode !== 'sortReverse') {
        lines.sort(sortFn);
        // 降順オプションがONの場合は結果を反転（ランダム以外）
        if (desc && mode !== 'sortRandom') {
          lines.reverse();
        }
        output = lines.join('\n');
      }
      break;
    }
    
    case 'uniq':
      // 連続した重複行のみ削除（unixのuniqコマンドと同様）
      output = lines.filter((line, i) => i === 0 || line !== lines[i - 1]).join('\n');
      break;
    case 'combine': {
      // 行結合
      const delimiter = document.getElementById('combine-delimiter').value;
      const skipEmpty = document.getElementById('combine-skip-empty').checked;
      let targetLines = lines;
      if (skipEmpty) {
        targetLines = lines.filter(line => line.trim() !== '');
      }
      output = targetLines.join(delimiter);
      break;
    }
    case 'removeEmpty': {
      // 空行削除
      const removeWhitespaceOnly = document.getElementById('empty-whitespace').checked;
      if (removeWhitespaceOnly) {
        output = lines.filter(line => line.trim() !== '').join('\n');
      } else {
        output = lines.filter(line => line !== '').join('\n');
      }
      break;
    }
    case 'filterContaining':
    case 'filterNotContaining': {
      // 指定文字列を含む/含まない行を削除
      const filterText = document.getElementById('filter-text').value;
      const caseSensitive = document.getElementById('filter-case').checked;
      const useRegex = document.getElementById('filter-regex').checked;
      const showRemoved = document.getElementById('filter-show-removed').checked;
      const countDiv = document.getElementById('filter-removed-count');
      const isContaining = (mode === 'filterContaining');
      
      if (!filterText) {
        output = input;
        countDiv.textContent = '検索文字列を入力してください';
        break;
      }
      
      let matcher;
      try {
        if (useRegex) {
          const flags = caseSensitive ? 'g' : 'gi';
          matcher = new RegExp(filterText, flags);
        } else {
          const escaped = filterText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
          const flags = caseSensitive ? '' : 'i';
          matcher = new RegExp(escaped, flags);
        }
      } catch (e) {
        output = input;
        countDiv.textContent = '正規表現エラー: ' + e.message;
        break;
      }
      
      const kept = [];
      const removed = [];
      
      for (const line of lines) {
        const matches = matcher.test(line);
        // Reset lastIndex for global regex
        matcher.lastIndex = 0;
        
        // filterContaining: 含む行を削除 → マッチしたら削除
        // filterNotContaining: 含まない行を削除 → マッチしなかったら削除
        const shouldRemove = isContaining ? matches : !matches;
        
        if (shouldRemove) {
          removed.push(line);
        } else {
          kept.push(line);
        }
      }
      
      output = kept.join('\n');
      
      // 削除された行数を表示
      const modeText = isContaining ? '含む' : '含まない';
      countDiv.textContent = `${removed.length} 行を削除しました（"${filterText}" を${modeText}行）`;
      
      // 削除された行を表示する場合
      if (showRemoved && removed.length > 0) {
        output += '\n\n--- 削除された行 (' + removed.length + '行) ---\n' + removed.join('\n');
      }
      break;
    }
    case 'removeDuplicates': {
      // すべての重複行を削除
      const caseSensitive = document.getElementById('dup-case').checked;
      const trim = document.getElementById('dup-trim').checked;
      const keepOrder = document.getElementById('dup-keep-order').checked;
      const seen = new Set();
      const result = [];
      
      for (const line of lines) {
        let key = trim ? line.trim() : line;
        if (!caseSensitive) key = key.toLowerCase();
        
        if (!seen.has(key)) {
          seen.add(key);
          result.push(line);
        }
      }
      
      if (!keepOrder) {
        result.sort((a, b) => a.localeCompare(b, 'ja'));
      }
      
      output = result.join('\n');
      break;
    }
    case 'repeat': {
      // 繰り返し生成
      const repeatCount = parseInt(document.getElementById('repeat-count').value) || 10;
      const perRow = parseInt(document.getElementById('repeat-per-row').value) || 1;
      const separator = document.getElementById('repeat-separator').value;
      const eachLine = document.getElementById('repeat-each-line').checked;
      
      if (eachLine) {
        // 各行を個別に繰り返す
        const resultLines = [];
        for (const line of lines) {
          if (line.trim() === '') {
            resultLines.push(line);
            continue;
          }
          const repeated = [];
          for (let i = 0; i < repeatCount; i++) {
            repeated.push(line);
          }
          // perRowごとに行を分割
          const chunks = [];
          for (let i = 0; i < repeated.length; i += perRow) {
            chunks.push(repeated.slice(i, i + perRow).join(separator));
          }
          resultLines.push(chunks.join('\n'));
        }
        output = resultLines.join('\n');
      } else {
        // 入力全体を1つのテキストとして繰り返す
        const text = input;
        const repeated = [];
        for (let i = 0; i < repeatCount; i++) {
          repeated.push(text);
        }
        // perRowごとに行を分割
        const chunks = [];
        for (let i = 0; i < repeated.length; i += perRow) {
          chunks.push(repeated.slice(i, i + perRow).join(separator));
        }
        output = chunks.join('\n');
      }
      break;
    }
  }
  
  document.getElementById('outputText').value = output;
  updateStats('outputText', 'output');
}

// Utilities
function clearAll() {
  document.getElementById('inputText').value = '';
  document.getElementById('outputText').value = '';
  updateStats('inputText', 'input');
  updateStats('outputText', 'output');
}

function swapTexts() {
  const input = document.getElementById('inputText');
  const output = document.getElementById('outputText');
  const temp = input.value;
  input.value = output.value;
  output.value = temp;
  updateStats('inputText', 'input');
  updateStats('outputText', 'output');
}

function sortInput(order) {
  const textarea = document.getElementById('inputText');
  const lines = textarea.value.split('\n');
  lines.sort((a, b) => {
    const result = a.localeCompare(b, 'ja');
    return order === 'asc' ? result : -result;
  });
  textarea.value = lines.join('\n');
  updateStats('inputText', 'input');
}

async function copyToClipboard() {
  const text = document.getElementById('outputText').value;
  await navigator.clipboard.writeText(text);
}

function downloadOutput() {
  const text = document.getElementById('outputText').value;
  const blob = new Blob([text], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  const now = new Date();
  const timestamp = now.toISOString().slice(0, 19).replace(/[-:]/g, '').replace('T', '_');
  a.href = url;
  a.download = `TextTools_${timestamp}.txt`;
  a.click();
  URL.revokeObjectURL(url);
}

// Keyboard shortcut
document.addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
    e.preventDefault();
    execute();
  }
});

// Initial stats
updateStats('inputText', 'input');
updateStats('outputText', 'output');

// ============================================
// ファイル読み込み機能（SJIS/EUC-JP/UTF-8自動判別）
// ============================================

const MAX_FILE_SIZE = 1 * 1024 * 1024; // 1MB
const WARN_FILE_SIZE = 500 * 1024; // 500KB

const DEFAULT_EXTENSIONS = [
  '.txt', '.md', '.html', '.htm', '.xht', '.xhtml', 
  '.css', '.js', '.json', '.xml', '.csv', '.tsv',
  '.java', '.properties', '.gradle', '.kt', '.scala', '.groovy', 
  '.yml', '.yaml', '.pom', '.log', '.ini', '.conf'
];

function getAllowedExtensions() {
  const urlParams = new URLSearchParams(window.location.search);
  const extraExts = urlParams.get('ext');
  const allowed = [...DEFAULT_EXTENSIONS];
  if (extraExts) {
    extraExts.split(',').forEach(ext => {
      const e = ext.startsWith('.') ? ext : '.' + ext;
      if (!allowed.includes(e.toLowerCase())) {
        allowed.push(e.toLowerCase());
      }
    });
  }
  return allowed;
}

function getFileExtension(filename) {
  const lastDot = filename.lastIndexOf('.');
  return lastDot >= 0 ? filename.slice(lastDot).toLowerCase() : '';
}

function checkFileType(file) {
  const ext = getFileExtension(file.name);
  const allowed = getAllowedExtensions();
  
  if (!ext) {
    return confirm('拡張子のないファイルです。テキストファイルとして読み込みますか？');
  }
  
  if (!allowed.includes(ext)) {
    const proceed = confirm(
      `未対応の形式です（${ext}）。\n\nテキストファイルとして読み込みますか？\n\n` +
      `OKを押すと、このURLでは次回から確認なしで読み込めます。`
    );
    if (proceed) {
      addExtensionToUrl(ext);
    }
    return proceed;
  }
  return true;
}

function addExtensionToUrl(ext) {
  const url = new URL(window.location);
  const currentExts = url.searchParams.get('ext');
  const extWithoutDot = ext.startsWith('.') ? ext.slice(1) : ext;
  
  if (currentExts) {
    const extList = currentExts.split(',');
    if (!extList.includes(extWithoutDot)) {
      extList.push(extWithoutDot);
      url.searchParams.set('ext', extList.join(','));
    }
  } else {
    url.searchParams.set('ext', extWithoutDot);
  }
  window.history.replaceState({}, '', url);
}

function checkFileSize(file) {
  if (file.size > MAX_FILE_SIZE) {
    alert(`ファイルが大きすぎます（${formatFileSize(file.size)}）。\n1MB以下のファイルを選択してください。`);
    return false;
  }
  if (file.size > WARN_FILE_SIZE) {
    return confirm(`ファイルサイズが大きいです（${formatFileSize(file.size)}）。\n処理に時間がかかる場合があります。続行しますか？`);
  }
  return true;
}

function formatFileSize(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}

// ファイルを読み込んでテキストエリアにセット（SJIS/EUC-JP/UTF-8自動判別）
function readFile(file, textareaId) {
  const reader = new FileReader();
  reader.onload = (e) => {
    const arrayBuffer = e.target.result;
    const uint8Array = new Uint8Array(arrayBuffer);
    
    // エンコーディングを自動検出
    const detectedEncoding = Encoding.detect(uint8Array);
    
    // Unicode配列に変換
    const unicodeArray = Encoding.convert(uint8Array, {
      to: 'UNICODE',
      from: detectedEncoding
    });
    
    // 文字列に変換
    const text = Encoding.codeToString(unicodeArray);
    document.getElementById(textareaId).value = text;
    updateStats(textareaId, textareaId === 'inputText' ? 'input' : 'output');
  };
  reader.readAsArrayBuffer(file);
}

// ドラッグ&ドロップのセットアップ
function setupDragDrop(panelId, textareaId) {
  const panel = document.getElementById(panelId);
  const textarea = document.getElementById(textareaId);
  
  if (!panel || !textarea) return;
  
  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    panel.addEventListener(eventName, (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
  });
  
  ['dragenter', 'dragover'].forEach(eventName => {
    panel.addEventListener(eventName, () => {
      panel.classList.add('drag-over');
    });
  });
  
  ['dragleave', 'drop'].forEach(eventName => {
    panel.addEventListener(eventName, () => {
      panel.classList.remove('drag-over');
    });
  });
  
  panel.addEventListener('drop', (e) => {
    const files = e.dataTransfer.files;
    if (files.length > 0) {
      const file = files[0];
      if (checkFileSize(file) && checkFileType(file)) {
        readFile(file, textareaId);
      }
    }
  });
  
  // ファイルペースト対応
  textarea.addEventListener('paste', (e) => {
    const items = e.clipboardData.items;
    for (const item of items) {
      if (item.kind === 'file') {
        e.preventDefault();
        const file = item.getAsFile();
        if (file && checkFileSize(file) && checkFileType(file)) {
          readFile(file, textareaId);
        }
        return;
      }
    }
  });
}

// ドラッグ&ドロップ初期化
setupDragDrop('inputPanel', 'inputText');

// ============================================
// テスト関数 - コンソールで runAllTests() を実行
// ============================================
function runAllTests() {
  console.log('========================================');
  console.log('TextTools 全機能テスト開始');
  console.log('========================================');
  
  let passed = 0;
  let failed = 0;
  
  function test(name, fn) {
    try {
      const result = fn();
      if (result === true) {
        console.log(`✅ PASS: ${name}`);
        passed++;
      } else {
        console.log(`❌ FAIL: ${name} - 結果: ${result}`);
        failed++;
      }
    } catch (e) {
      console.log(`❌ ERROR: ${name} - ${e.message}`);
      failed++;
    }
  }
  
  // 1. 行頭/行末追加
  test('行頭/行末追加 - Prefix追加', () => {
    document.getElementById('prefix-text').value = '> ';
    document.getElementById('suffix-text').value = '';
    document.getElementById('prefix-skip-empty').checked = false;
    const result = executePrefixSuffix('line1\nline2\nline3');
    return result === '> line1\n> line2\n> line3';
  });
  
  test('行頭/行末追加 - Suffix追加', () => {
    document.getElementById('prefix-text').value = '';
    document.getElementById('suffix-text').value = '!';
    const result = executePrefixSuffix('a\nb\nc');
    return result === 'a!\nb!\nc!';
  });
  
  test('行頭/行末追加 - Prefix+Suffix同時', () => {
    document.getElementById('prefix-text').value = '[';
    document.getElementById('suffix-text').value = ']';
    document.getElementById('prefix-skip-empty').checked = false;
    const result = executePrefixSuffix('a\nb');
    return result === '[a]\n[b]';
  });
  
  test('行頭/行末追加 - 空行スキップON', () => {
    document.getElementById('prefix-text').value = '- ';
    document.getElementById('suffix-text').value = '';
    document.getElementById('prefix-skip-empty').checked = true;
    const result = executePrefixSuffix('a\n\nb');
    return result === '- a\n\n- b';
  });
  
  test('行頭/行末追加 - 空行スキップOFF', () => {
    document.getElementById('prefix-text').value = '- ';
    document.getElementById('suffix-text').value = '';
    document.getElementById('prefix-skip-empty').checked = false;
    const result = executePrefixSuffix('a\n\nb');
    return result === '- a\n- \n- b';
  });
  
  // 2. 改行追加/削除
  test('改行削除 - すべて削除', () => {
    document.getElementById('inputText').value = 'a\nb\nc';
    document.getElementById('lb-remove-replace').value = '';
    executeLineBreakRemoveAll();
    return document.getElementById('outputText').value === 'abc';
  });
  
  test('改行削除 - スペースで置換', () => {
    document.getElementById('inputText').value = 'a\nb\nc';
    document.getElementById('lb-remove-replace').value = ' ';
    executeLineBreakRemoveAll();
    return document.getElementById('outputText').value === 'a b c';
  });
  
  test('改行削除 - カンマで置換', () => {
    document.getElementById('inputText').value = 'a\nb\nc';
    document.getElementById('lb-remove-replace').value = ',';
    executeLineBreakRemoveAll();
    return document.getElementById('outputText').value === 'a,b,c';
  });
  
  test('改行追加 - 指定文字の後', () => {
    document.getElementById('inputText').value = 'a.b.c';
    document.getElementById('lb-target-text').value = '.';
    document.querySelector('input[name="lb-position"][value="after"]').checked = true;
    document.getElementById('lb-case-sensitive').checked = false;
    document.getElementById('lb-remove-existing').checked = false;
    executeLineBreakAtText();
    return document.getElementById('outputText').value === 'a.\nb.\nc';
  });
  
  test('改行追加 - 指定文字の前', () => {
    document.getElementById('inputText').value = 'a.b.c';
    document.getElementById('lb-target-text').value = '.';
    document.querySelector('input[name="lb-position"][value="before"]').checked = true;
    document.getElementById('lb-case-sensitive').checked = false;
    document.getElementById('lb-remove-existing').checked = false;
    executeLineBreakAtText();
    return document.getElementById('outputText').value === 'a\n.b\n.c';
  });
  
  test('改行追加 - 大文字小文字区別ON', () => {
    document.getElementById('inputText').value = 'aAbAa';
    document.getElementById('lb-target-text').value = 'A';
    document.querySelector('input[name="lb-position"][value="after"]').checked = true;
    document.getElementById('lb-case-sensitive').checked = true;
    document.getElementById('lb-remove-existing').checked = false;
    executeLineBreakAtText();
    return document.getElementById('outputText').value === 'aA\nbA\na';
  });
  
  test('改行追加 - N文字ごと', () => {
    document.getElementById('inputText').value = 'abcdefghij';
    document.getElementById('lb-every-n').value = '3';
    document.getElementById('lb-wordwrap').checked = false;
    document.getElementById('lb-escape-existing').checked = false;
    executeLineBreakEveryN();
    return document.getElementById('outputText').value === 'abc\ndef\nghi\nj';
  });
  
  test('改行追加 - N文字ごと（ワードラップ）', () => {
    document.getElementById('inputText').value = 'hello world test';
    document.getElementById('lb-every-n').value = '8';
    document.getElementById('lb-wordwrap').checked = true;
    document.getElementById('lb-escape-existing').checked = false;
    executeLineBreakEveryN();
    const output = document.getElementById('outputText').value;
    return output.includes('hello') && output.includes('\n');
  });
  
  test('改行追加 - N文字ごと（既存改行エスケープ）', () => {
    document.getElementById('inputText').value = 'ab\ncd';
    document.getElementById('lb-every-n').value = '5';
    document.getElementById('lb-wordwrap').checked = false;
    document.getElementById('lb-escape-existing').checked = true;
    executeLineBreakEveryN();
    return document.getElementById('outputText').value === 'ab\\nc\nd';
  });
  
  test('改行追加 - 各行の後に空行', () => {
    document.getElementById('inputText').value = 'a\nb';
    executeLineBreakAddAfterEach();
    return document.getElementById('outputText').value === 'a\n\nb';
  });
  
  test('改行追加 - 各行の前に空行', () => {
    document.getElementById('inputText').value = 'a\nb';
    executeLineBreakAddBeforeEach();
    return document.getElementById('outputText').value === 'a\n\nb';
  });
  
  test('改行追加 - 連続空行を1つに', () => {
    document.getElementById('inputText').value = 'a\n\n\nb\n\nc';
    executeLineBreakMergeMultiple();
    return document.getElementById('outputText').value === 'a\n\nb\n\nc';
  });
  
  // 3. 文字カウント
  test('文字カウント - 基本', () => {
    document.getElementById('count-no-spaces').checked = false;
    document.getElementById('count-no-html').checked = false;
    document.getElementById('count-linebreak-space').checked = false;
    const result = executeCount('Hello World');
    return result.includes('11');
  });
  
  test('文字カウント - スペース除外', () => {
    document.getElementById('count-no-spaces').checked = true;
    document.getElementById('count-no-html').checked = false;
    const result = executeCount('Hello World');
    return result.includes('10');
  });
  
  test('文字カウント - HTMLタグ除外', () => {
    document.getElementById('count-no-spaces').checked = false;
    document.getElementById('count-no-html').checked = true;
    const result = executeCount('<p>Hello</p>');
    return result.includes('5');
  });
  
  test('文字カウント - 改行をスペースとして', () => {
    document.getElementById('count-no-spaces').checked = false;
    document.getElementById('count-no-html').checked = false;
    document.getElementById('count-linebreak-space').checked = true;
    const result = executeCount('a\nb');
    return result.includes('3');
  });
  
  // 4. 列抽出
  test('列抽出 - カンマ区切り', () => {
    document.getElementById('inputText').value = 'a,b,c\n1,2,3';
    document.getElementById('column-delimiter-text').value = ',';
    document.getElementById('column-count').value = '3';
    document.getElementById('column-row-delimiter').value = '\\n';
    document.getElementById('column-remove-empty').checked = false;
    document.getElementById('column-trim').checked = false;
    executeColumnExtractMulti();
    const col1 = document.getElementById('col-output-0').value;
    return col1 === 'a\n1';
  });
  
  test('列抽出 - タブ区切り', () => {
    document.getElementById('inputText').value = 'a\tb\tc\n1\t2\t3';
    document.getElementById('column-delimiter-text').value = '\\t';
    document.getElementById('column-count').value = '3';
    executeColumnExtractMulti();
    const col2 = document.getElementById('col-output-1').value;
    return col2 === 'b\n2';
  });
  
  test('列抽出 - トリムON', () => {
    document.getElementById('inputText').value = '  a  ,  b  ,c';
    document.getElementById('column-delimiter-text').value = ',';
    document.getElementById('column-count').value = '3';
    document.getElementById('column-trim').checked = true;
    executeColumnExtractMulti();
    const col1 = document.getElementById('col-output-0').value;
    document.getElementById('column-trim').checked = false;
    return col1 === 'a';
  });
  
  test('列抽出 - 空行削除', () => {
    document.getElementById('inputText').value = 'a,b\n\nc,d';
    document.getElementById('column-delimiter-text').value = ',';
    document.getElementById('column-count').value = '2';
    document.getElementById('column-remove-empty').checked = true;
    executeColumnExtractMulti();
    const col1 = document.getElementById('col-output-0').value;
    document.getElementById('column-remove-empty').checked = false;
    return col1 === 'a\nc';
  });
  
  // 5. 検索と置換
  test('検索と置換 - 単純置換', () => {
    document.getElementById('find-text').value = 'cat';
    document.getElementById('replace-text').value = 'dog';
    document.getElementById('find-regex').checked = false;
    document.getElementById('find-case').checked = false;
    const result = executeFindReplace('I have a cat');
    return result === 'I have a dog';
  });
  
  test('検索と置換 - 大文字小文字区別ON', () => {
    document.getElementById('find-text').value = 'Cat';
    document.getElementById('replace-text').value = 'dog';
    document.getElementById('find-regex').checked = false;
    document.getElementById('find-case').checked = true;
    const result = executeFindReplace('cat Cat CAT');
    return result === 'cat dog CAT';
  });
  
  test('検索と置換 - 大文字小文字区別OFF', () => {
    document.getElementById('find-text').value = 'cat';
    document.getElementById('replace-text').value = 'dog';
    document.getElementById('find-regex').checked = false;
    document.getElementById('find-case').checked = false;
    const result = executeFindReplace('cat Cat CAT');
    return result === 'dog dog dog';
  });
  
  test('検索と置換 - 正規表現', () => {
    document.getElementById('find-text').value = '\\d+';
    document.getElementById('replace-text').value = 'X';
    document.getElementById('find-regex').checked = true;
    const result = executeFindReplace('abc123def456');
    return result === 'abcXdefX';
  });
  
  test('検索と置換 - 正規表現グループ', () => {
    document.getElementById('find-text').value = '(\\w+)@(\\w+)';
    document.getElementById('replace-text').value = '$2:$1';
    document.getElementById('find-regex').checked = true;
    const result = executeFindReplace('user@domain');
    return result === 'domain:user';
  });
  
  // 6. 行結合（行操作に統合）
  test('行操作 - 行結合 - カンマで結合', () => {
    document.getElementById('combine-delimiter').value = ',';
    document.getElementById('combine-skip-empty').checked = true;
    document.getElementById('inputText').value = 'a\nb\nc';
    executeLineOps('combine');
    return document.getElementById('outputText').value === 'a,b,c';
  });
  
  test('行操作 - 行結合 - 空欄で直接結合', () => {
    document.getElementById('combine-delimiter').value = '';
    document.getElementById('combine-skip-empty').checked = true;
    document.getElementById('inputText').value = 'a\nb\nc';
    executeLineOps('combine');
    return document.getElementById('outputText').value === 'abc';
  });
  
  test('行操作 - 行結合 - 空行スキップON', () => {
    document.getElementById('combine-delimiter').value = '-';
    document.getElementById('combine-skip-empty').checked = true;
    document.getElementById('inputText').value = 'a\n\nb';
    executeLineOps('combine');
    return document.getElementById('outputText').value === 'a-b';
  });
  
  test('行操作 - 行結合 - 空行スキップOFF', () => {
    document.getElementById('combine-delimiter').value = '-';
    document.getElementById('combine-skip-empty').checked = false;
    document.getElementById('inputText').value = 'a\n\nb';
    executeLineOps('combine');
    return document.getElementById('outputText').value === 'a--b';
  });
  
  // 7. 組み合わせ生成
  test('組み合わせ生成 - 2リスト', () => {
    document.getElementById('combo-list-0').value = 'A\nB';
    document.getElementById('combo-list-1').value = '1\n2';
    document.getElementById('combo-list-2').value = '';
    document.getElementById('combo-delim-0').value = '';
    document.getElementById('combo-delim-1').value = '';
    document.getElementById('combo-prefix').value = '';
    document.getElementById('combo-suffix').value = '';
    const result = executeCombination('');
    return result === 'A1\nA2\nB1\nB2';
  });
  
  test('組み合わせ生成 - 3リスト', () => {
    document.getElementById('combo-list-0').value = 'A';
    document.getElementById('combo-list-1').value = '1';
    document.getElementById('combo-list-2').value = 'X\nY';
    document.getElementById('combo-delim-0').value = '';
    document.getElementById('combo-delim-1').value = '';
    document.getElementById('combo-prefix').value = '';
    document.getElementById('combo-suffix').value = '';
    const result = executeCombination('');
    return result === 'A1X\nA1Y';
  });
  
  test('組み合わせ生成 - 区切り付き', () => {
    document.getElementById('combo-list-0').value = 'X\nY';
    document.getElementById('combo-list-1').value = '1';
    document.getElementById('combo-list-2').value = '';
    document.getElementById('combo-delim-0').value = '-';
    document.getElementById('combo-prefix').value = '[';
    document.getElementById('combo-suffix').value = ']';
    const result = executeCombination('');
    return result === '[X-1]\n[Y-1]';
  });
  
  // 8. 重複行削除（行操作に統合）
  test('行操作 - 重複行削除 - 基本', () => {
    document.getElementById('dup-case').checked = false;
    document.getElementById('dup-trim').checked = false;
    document.getElementById('dup-keep-order').checked = true;
    document.getElementById('inputText').value = 'a\nb\na\nc\nb';
    executeLineOps('removeDuplicates');
    return document.getElementById('outputText').value === 'a\nb\nc';
  });
  
  test('行操作 - 重複行削除 - 大文字小文字区別ON', () => {
    document.getElementById('dup-case').checked = true;
    document.getElementById('dup-trim').checked = false;
    document.getElementById('dup-keep-order').checked = true;
    document.getElementById('inputText').value = 'A\na\nA';
    executeLineOps('removeDuplicates');
    return document.getElementById('outputText').value === 'A\na';
  });
  
  test('行操作 - 重複行削除 - 大文字小文字区別OFF', () => {
    document.getElementById('dup-case').checked = false;
    document.getElementById('dup-trim').checked = false;
    document.getElementById('dup-keep-order').checked = true;
    document.getElementById('inputText').value = 'A\na\nA';
    executeLineOps('removeDuplicates');
    return document.getElementById('outputText').value === 'A';
  });
  
  test('行操作 - 重複行削除 - 前後の空白を無視ON', () => {
    document.getElementById('dup-case').checked = true;
    document.getElementById('dup-trim').checked = true;
    document.getElementById('dup-keep-order').checked = true;
    document.getElementById('inputText').value = 'a\n a \na';
    executeLineOps('removeDuplicates');
    return document.getElementById('outputText').value === 'a';
  });
  
  test('行操作 - 重複行削除 - 出現順序を保持OFF', () => {
    document.getElementById('dup-case').checked = true;
    document.getElementById('dup-trim').checked = false;
    document.getElementById('dup-keep-order').checked = false;
    document.getElementById('inputText').value = 'c\na\nb\na';
    executeLineOps('removeDuplicates');
    return document.getElementById('outputText').value === 'a\nb\nc';
  });
  
  // 9. 空行削除（行操作に統合）
  test('行操作 - 空行削除 - 完全な空行のみ', () => {
    document.getElementById('empty-whitespace').checked = false;
    document.getElementById('inputText').value = 'a\n\nb\n   \nc';
    executeLineOps('removeEmpty');
    return document.getElementById('outputText').value === 'a\nb\n   \nc';
  });
  
  test('行操作 - 空行削除 - 空白のみの行も削除', () => {
    document.getElementById('empty-whitespace').checked = true;
    document.getElementById('inputText').value = 'a\n   \nb';
    executeLineOps('removeEmpty');
    return document.getElementById('outputText').value === 'a\nb';
  });
  
  // 10. 空白削除
  test('空白削除 - トリムのみ', () => {
    document.getElementById('spaces-trim').checked = true;
    document.querySelector('input[name="spaces-remove-mode"][value="none"]').checked = true;
    const result = executeRemoveSpaces('  hello  \n  world  ');
    return result === 'hello\nworld';
  });
  
  test('空白削除 - 連続空白を1つに', () => {
    document.getElementById('spaces-trim').checked = false;
    document.querySelector('input[name="spaces-remove-mode"][value="extra"]').checked = true;
    const result = executeRemoveSpaces('a   b    c');
    return result === 'a b c';
  });
  
  test('空白削除 - すべて削除', () => {
    document.getElementById('spaces-trim').checked = false;
    document.querySelector('input[name="spaces-remove-mode"][value="all"]').checked = true;
    const result = executeRemoveSpaces('a b c');
    return result === 'abc';
  });
  
  test('空白削除 - トリム+連続空白を1つに', () => {
    document.getElementById('spaces-trim').checked = true;
    document.querySelector('input[name="spaces-remove-mode"][value="extra"]').checked = true;
    const result = executeRemoveSpaces('  a   b  ');
    return result === 'a b';
  });
  
  // 11. 空白追加
  test('空白追加 - N文字ごと', () => {
    document.getElementById('spaces-add-every-n').checked = true;
    document.getElementById('spaces-add-n').value = '3';
    document.getElementById('spaces-add-after-char').checked = false;
    document.getElementById('spaces-add-after-line').checked = false;
    const result = executeAddSpacesMain('abcdefghi');
    return result === 'abc def ghi';
  });
  
  test('空白追加 - 指定文字の後', () => {
    document.getElementById('spaces-add-every-n').checked = false;
    document.getElementById('spaces-add-after-char').checked = true;
    document.getElementById('spaces-after-char').value = '.';
    document.getElementById('spaces-add-after-line').checked = false;
    const result = executeAddSpacesMain('a.b.c');
    return result === 'a. b. c';
  });
  
  test('空白追加 - 各行末尾', () => {
    document.getElementById('spaces-add-every-n').checked = false;
    document.getElementById('spaces-add-after-char').checked = false;
    document.getElementById('spaces-add-after-line').checked = true;
    const result = executeAddSpacesMain('a\nb');
    return result === 'a \nb ';
  });
  
  test('空白追加 - 複合（N文字ごと+行末尾）', () => {
    document.getElementById('spaces-add-every-n').checked = true;
    document.getElementById('spaces-add-n').value = '2';
    document.getElementById('spaces-add-after-char').checked = false;
    document.getElementById('spaces-add-after-line').checked = true;
    const result = executeAddSpacesMain('abcd');
    return result === 'ab cd ';
  });
  
  // 12. 文字変換
  test('文字変換 - 小文字に変換', () => {
    document.getElementById('inputText').value = 'HELLO World';
    executeConvert('lowercase');
    return document.getElementById('outputText').value === 'hello world';
  });
  
  test('文字変換 - 大文字に変換', () => {
    document.getElementById('inputText').value = 'Hello World';
    executeConvert('uppercase');
    return document.getElementById('outputText').value === 'HELLO WORLD';
  });
  
  test('文字変換 - 各単語の先頭を大文字', () => {
    document.getElementById('inputText').value = 'hello world test';
    executeConvert('capitalizeWords');
    return document.getElementById('outputText').value === 'Hello World Test';
  });
  
  test('文字変換 - 各単語の先頭を小文字', () => {
    document.getElementById('inputText').value = 'Hello World Test';
    executeConvert('uncapitalizeWords');
    return document.getElementById('outputText').value === 'hello world test';
  });
  
  test('文字変換 - 各文の先頭を大文字', () => {
    document.getElementById('inputText').value = 'hello. world. test';
    executeConvert('capitalizeSentences');
    return document.getElementById('outputText').value === 'Hello. World. Test';
  });
  
  test('文字変換 - snake_case', () => {
    document.getElementById('inputText').value = 'Hello World Test';
    executeConvert('snakeCase');
    return document.getElementById('outputText').value === 'hello_world_test';
  });
  
  test('文字変換 - snake_case（複数行）', () => {
    document.getElementById('inputText').value = 'Hello World\nFoo Bar';
    executeConvert('snakeCase');
    return document.getElementById('outputText').value === 'hello_world\nfoo_bar';
  });
  
  test('文字変換 - kebab-case', () => {
    document.getElementById('inputText').value = 'Hello World Test';
    executeConvert('kebabCase');
    return document.getElementById('outputText').value === 'hello-world-test';
  });
  
  test('文字変換 - camelCase', () => {
    document.getElementById('inputText').value = 'hello world test';
    executeConvert('camelCase');
    return document.getElementById('outputText').value === 'helloWorldTest';
  });
  
  test('文字変換 - camelCase（複数行）', () => {
    document.getElementById('inputText').value = 'hello world\nfoo bar';
    executeConvert('camelCase');
    return document.getElementById('outputText').value === 'helloWorld\nfooBar';
  });
  
  test('文字変換 - PascalCase', () => {
    document.getElementById('inputText').value = 'hello world test';
    executeConvert('pascalCase');
    return document.getElementById('outputText').value === 'HelloWorldTest';
  });
  
  test('文字変換 - ひらがな→カタカナ', () => {
    document.getElementById('inputText').value = 'あいうえお';
    executeConvert('hiraToKata');
    return document.getElementById('outputText').value === 'アイウエオ';
  });
  
  test('文字変換 - カタカナ→ひらがな', () => {
    document.getElementById('inputText').value = 'アイウエオ';
    executeConvert('kataToHira');
    return document.getElementById('outputText').value === 'あいうえお';
  });
  
  test('文字変換 - ローマ字→ひらがな（基本）', () => {
    document.getElementById('inputText').value = 'aiueo';
    executeConvert('romaToHira');
    return document.getElementById('outputText').value === 'あいうえお';
  });
  
  test('文字変換 - ローマ字→ひらがな（拗音）', () => {
    document.getElementById('inputText').value = 'shimbashi';
    executeConvert('romaToHira');
    return document.getElementById('outputText').value === 'しんばし';
  });
  
  test('文字変換 - ローマ字→ひらがな（促音）', () => {
    document.getElementById('inputText').value = 'kitte';
    executeConvert('romaToHira');
    return document.getElementById('outputText').value === 'きって';
  });
  
  test('文字変換 - ローマ字→カタカナ', () => {
    document.getElementById('inputText').value = 'tokyo';
    executeConvert('romaToKata');
    return document.getElementById('outputText').value === 'トウキョウ';
  });
  
  test('文字変換 - ひらがな→ローマ字（基本）', () => {
    document.getElementById('inputText').value = 'あいうえお';
    executeConvert('hiraToRoma');
    return document.getElementById('outputText').value === 'aiueo';
  });
  
  test('文字変換 - ひらがな→ローマ字（拗音）', () => {
    document.getElementById('inputText').value = 'とうきょう';
    executeConvert('hiraToRoma');
    return document.getElementById('outputText').value === 'toukyou';
  });
  
  test('文字変換 - ひらがな→ローマ字（促音）', () => {
    document.getElementById('inputText').value = 'きって';
    executeConvert('hiraToRoma');
    return document.getElementById('outputText').value === 'kitte';
  });
  
  test('文字変換 - 全角英数→半角英数', () => {
    document.getElementById('inputText').value = 'ＡＢＣ１２３';
    executeConvert('alphaToFull');
    return document.getElementById('outputText').value === 'ABC123';
  });
  
  test('文字変換 - 半角英数→全角英数', () => {
    document.getElementById('inputText').value = 'ABC123';
    executeConvert('alphaToHalf');
    return document.getElementById('outputText').value === 'ＡＢＣ１２３';
  });
  
  test('文字変換 - 全角カタカナ→半角カタカナ', () => {
    document.getElementById('inputText').value = 'アイウ';
    executeConvert('kataToFull');
    return document.getElementById('outputText').value === 'ｱｲｳ';
  });
  
  test('文字変換 - 半角カタカナ→全角カタカナ', () => {
    document.getElementById('inputText').value = 'ｱｲｳ';
    executeConvert('kataToHalf');
    return document.getElementById('outputText').value === 'アイウ';
  });
  
  test('文字変換 - 全角→半角（混在）', () => {
    document.getElementById('inputText').value = 'Ａｂｃ１２３';
    executeConvert('toFullwidth');
    return document.getElementById('outputText').value === 'Abc123';
  });
  
  test('文字変換 - 半角→全角（混在）', () => {
    document.getElementById('inputText').value = 'Abc123';
    executeConvert('toHalfwidth');
    return document.getElementById('outputText').value === 'Ａｂｃ１２３';
  });
  
  test('文字変換 - TAB→空白', () => {
    document.getElementById('inputText').value = 'a\tb';
    document.getElementById('convert-tab-spaces').value = '4';
    executeConvert('tabToSpace');
    return document.getElementById('outputText').value === 'a    b';
  });
  
  test('文字変換 - 空白→TAB', () => {
    document.getElementById('inputText').value = 'a    b';
    document.getElementById('convert-tab-spaces').value = '4';
    executeConvert('spaceToTab');
    return document.getElementById('outputText').value === 'a\tb';
  });
  
  test('文字変換 - TAB→空白（スペース数変更）', () => {
    document.getElementById('inputText').value = 'a\tb';
    document.getElementById('convert-tab-spaces').value = '2';
    executeConvert('tabToSpace');
    return document.getElementById('outputText').value === 'a  b';
  });
  
  // 13. 行操作
  test('行操作 - 左の空白を削除', () => {
    document.getElementById('inputText').value = '  hello\n  world';
    executeLineOps('trimLeft');
    return document.getElementById('outputText').value === 'hello\nworld';
  });
  
  test('行操作 - 右の空白を削除', () => {
    document.getElementById('inputText').value = 'hello  \nworld  ';
    executeLineOps('trimRight');
    return document.getElementById('outputText').value === 'hello\nworld';
  });
  
  test('行操作 - 左の空白を削除（全角空白）', () => {
    document.getElementById('inputText').value = '　　hello';
    executeLineOps('trimLeft');
    return document.getElementById('outputText').value === 'hello';
  });
  
  test('行操作 - 右の空白を削除（全角空白）', () => {
    document.getElementById('inputText').value = 'hello　　';
    executeLineOps('trimRight');
    return document.getElementById('outputText').value === 'hello';
  });
  
  test('行操作 - アルファベット順ソート', () => {
    document.getElementById('sort-delimiter').value = '';
    document.getElementById('sort-desc').checked = false;
    document.getElementById('inputText').value = 'c\na\nb';
    executeLineOps('sortAlpha');
    return document.getElementById('outputText').value === 'a\nb\nc';
  });
  
  test('行操作 - アルファベット順ソート（降順）', () => {
    document.getElementById('sort-delimiter').value = '';
    document.getElementById('sort-desc').checked = true;
    document.getElementById('inputText').value = 'a\nc\nb';
    executeLineOps('sortAlpha');
    document.getElementById('sort-desc').checked = false;
    return document.getElementById('outputText').value === 'c\nb\na';
  });
  
  test('行操作 - アルファベット順ソート（大文字小文字区別なし）', () => {
    document.getElementById('sort-delimiter').value = '';
    document.getElementById('sort-desc').checked = false;
    document.getElementById('inputText').value = 'B\na\nC';
    executeLineOps('sortAlpha');
    const result = document.getElementById('outputText').value;
    return result === 'a\nB\nC' || result === 'a\nC\nB'; // 大文字小文字区別なしなのでaが先頭
  });
  
  test('行操作 - アルファベット順ソート（大文字小文字区別あり）', () => {
    document.getElementById('sort-delimiter').value = '';
    document.getElementById('sort-desc').checked = false;
    document.getElementById('inputText').value = 'b\nA\nB\na';
    executeLineOps('sortAlphaCase');
    // ASCII順: A(65), B(66), a(97), b(98)
    return document.getElementById('outputText').value === 'A\nB\na\nb';
  });
  
  test('行操作 - 自然順ソート（数値対応）', () => {
    document.getElementById('sort-delimiter').value = '';
    document.getElementById('sort-desc').checked = false;
    document.getElementById('inputText').value = '1\n10\n2\n15\n3';
    executeLineOps('sortNatural');
    return document.getElementById('outputText').value === '1\n2\n3\n10\n15';
  });
  
  test('行操作 - 自然順ソート（ファイル名）', () => {
    document.getElementById('sort-delimiter').value = '';
    document.getElementById('sort-desc').checked = false;
    document.getElementById('inputText').value = 'file10.txt\nfile2.txt\nfile1.txt';
    executeLineOps('sortNatural');
    return document.getElementById('outputText').value === 'file1.txt\nfile2.txt\nfile10.txt';
  });
  
  test('行操作 - 自然順ソート（大文字小文字区別あり）', () => {
    document.getElementById('sort-delimiter').value = '';
    document.getElementById('sort-desc').checked = false;
    document.getElementById('inputText').value = 'B2\na1\nA10';
    executeLineOps('sortNaturalCase');
    // ASCII順 + 数値順: A10, B2, a1
    return document.getElementById('outputText').value === 'A10\nB2\na1';
  });
  
  test('行操作 - 文字数順ソート', () => {
    document.getElementById('sort-delimiter').value = '';
    document.getElementById('sort-desc').checked = false;
    document.getElementById('inputText').value = 'aaa\na\naa';
    executeLineOps('sortLength');
    return document.getElementById('outputText').value === 'a\naa\naaa';
  });
  
  test('行操作 - 文字数順ソート（降順）', () => {
    document.getElementById('sort-delimiter').value = '';
    document.getElementById('sort-desc').checked = true;
    document.getElementById('inputText').value = 'a\naaa\naa';
    executeLineOps('sortLength');
    document.getElementById('sort-desc').checked = false;
    return document.getElementById('outputText').value === 'aaa\naa\na';
  });
  
  test('行操作 - 逆順', () => {
    document.getElementById('inputText').value = 'a\nb\nc';
    executeLineOps('sortReverse');
    return document.getElementById('outputText').value === 'c\nb\na';
  });
  
  test('行操作 - ランダムソート', () => {
    document.getElementById('inputText').value = 'a\nb\nc\nd\ne';
    executeLineOps('sortRandom');
    const result = document.getElementById('outputText').value;
    // ランダムなので、行数が同じで同じ要素を含むことを確認
    const lines = result.split('\n').sort();
    return lines.join('\n') === 'a\nb\nc\nd\ne';
  });
  
  test('行操作 - 区切り文字指定ソート', () => {
    document.getElementById('sort-delimiter').value = ',';
    document.getElementById('sort-column').value = '2';
    document.getElementById('sort-desc').checked = false;
    document.getElementById('inputText').value = 'x,3\ny,1\nz,2';
    executeLineOps('sortNatural');
    document.getElementById('sort-delimiter').value = '';
    document.getElementById('sort-column').value = '1';
    return document.getElementById('outputText').value === 'y,1\nz,2\nx,3';
  });
  
  test('行操作 - 区切り文字指定ソート（3列目）', () => {
    document.getElementById('sort-delimiter').value = '\t';
    document.getElementById('sort-column').value = '3';
    document.getElementById('sort-desc').checked = false;
    document.getElementById('inputText').value = 'a\t1\tc\nb\t2\ta\nc\t3\tb';
    executeLineOps('sortAlpha');
    document.getElementById('sort-delimiter').value = '';
    document.getElementById('sort-column').value = '1';
    return document.getElementById('outputText').value === 'b\t2\ta\nc\t3\tb\na\t1\tc';
  });
  
  test('行操作 - 日本語ソート', () => {
    document.getElementById('sort-delimiter').value = '';
    document.getElementById('sort-desc').checked = false;
    document.getElementById('inputText').value = 'か\nあ\nさ';
    executeLineOps('sortAlpha');
    return document.getElementById('outputText').value === 'あ\nか\nさ';
  });
  
  test('行操作 - uniq (連続重複削除)', () => {
    document.getElementById('inputText').value = 'a\na\nb\nb\na';
    executeLineOps('uniq');
    return document.getElementById('outputText').value === 'a\nb\na';
  });
  
  // 14. 行フィルタ
  test('行操作 - 含む行を削除', () => {
    document.getElementById('inputText').value = 'apple\nbanana\napricot\ncherry';
    document.getElementById('filter-text').value = 'ap';
    document.getElementById('filter-case').checked = false;
    document.getElementById('filter-regex').checked = false;
    document.getElementById('filter-show-removed').checked = false;
    executeLineOps('filterContaining');
    return document.getElementById('outputText').value === 'banana\ncherry';
  });
  
  test('行操作 - 含まない行を削除', () => {
    document.getElementById('inputText').value = 'apple\nbanana\napricot\ncherry';
    document.getElementById('filter-text').value = 'ap';
    document.getElementById('filter-case').checked = false;
    document.getElementById('filter-regex').checked = false;
    document.getElementById('filter-show-removed').checked = false;
    executeLineOps('filterNotContaining');
    return document.getElementById('outputText').value === 'apple\napricot';
  });
  
  test('行操作 - 含む行を削除（大文字小文字区別）', () => {
    document.getElementById('inputText').value = 'Apple\napple\nAPPLE';
    document.getElementById('filter-text').value = 'Apple';
    document.getElementById('filter-case').checked = true;
    document.getElementById('filter-regex').checked = false;
    document.getElementById('filter-show-removed').checked = false;
    executeLineOps('filterContaining');
    document.getElementById('filter-case').checked = false;
    return document.getElementById('outputText').value === 'apple\nAPPLE';
  });
  
  test('行操作 - 正規表現でフィルタ', () => {
    document.getElementById('inputText').value = 'test1\ntest2\nhello\ntest10';
    document.getElementById('filter-text').value = '^test\\d+$';
    document.getElementById('filter-case').checked = false;
    document.getElementById('filter-regex').checked = true;
    document.getElementById('filter-show-removed').checked = false;
    executeLineOps('filterContaining');
    document.getElementById('filter-regex').checked = false;
    return document.getElementById('outputText').value === 'hello';
  });
  
  // 15. 繰り返し生成
  test('行操作 - 繰り返し生成（基本）', () => {
    document.getElementById('inputText').value = 'abc';
    document.getElementById('repeat-count').value = '3';
    document.getElementById('repeat-per-row').value = '1';
    document.getElementById('repeat-separator').value = '';
    document.getElementById('repeat-each-line').checked = false;
    executeLineOps('repeat');
    return document.getElementById('outputText').value === 'abc\nabc\nabc';
  });
  
  test('行操作 - 繰り返し生成（1行に複数）', () => {
    document.getElementById('inputText').value = 'x';
    document.getElementById('repeat-count').value = '6';
    document.getElementById('repeat-per-row').value = '3';
    document.getElementById('repeat-separator').value = ',';
    document.getElementById('repeat-each-line').checked = false;
    executeLineOps('repeat');
    return document.getElementById('outputText').value === 'x,x,x\nx,x,x';
  });
  
  test('行操作 - 繰り返し生成（各行個別）', () => {
    document.getElementById('inputText').value = 'a\nb';
    document.getElementById('repeat-count').value = '2';
    document.getElementById('repeat-per-row').value = '1';
    document.getElementById('repeat-separator').value = '';
    document.getElementById('repeat-each-line').checked = true;
    executeLineOps('repeat');
    document.getElementById('repeat-each-line').checked = false;
    return document.getElementById('outputText').value === 'a\na\nb\nb';
  });
  
  // ============================================
  // 追加テスト - 文字変換
  // ============================================
  
  test('文字変換 - ランダムケース', () => {
    document.getElementById('inputText').value = 'hello';
    executeConvert('randomcase');
    const result = document.getElementById('outputText').value;
    return result.toLowerCase() === 'hello' && result.length === 5;
  });
  
  test('文字変換 - 交互大小文字', () => {
    document.getElementById('inputText').value = 'hello';
    executeConvert('studlycaps');
    return document.getElementById('outputText').value === 'HeLlO';
  });
  
  test('文字変換 - 各文の先頭を小文字', () => {
    document.getElementById('inputText').value = 'Hello. World. Test';
    executeConvert('uncapitalizeSentences');
    return document.getElementById('outputText').value === 'hello. world. test';
  });
  
  test('文字変換 - camelCase（ハイフン区切り）', () => {
    document.getElementById('inputText').value = 'hello-world-test';
    executeConvert('camelCase');
    return document.getElementById('outputText').value === 'helloWorldTest';
  });
  
  test('文字変換 - snake_case（キャメルケースから）', () => {
    document.getElementById('inputText').value = 'helloWorldTest';
    executeConvert('snakeCase');
    return document.getElementById('outputText').value === 'hello_world_test';
  });
  
  test('文字変換 - kebab-case（キャメルケースから）', () => {
    document.getElementById('inputText').value = 'helloWorldTest';
    executeConvert('kebabCase');
    return document.getElementById('outputText').value === 'hello-world-test';
  });
  
  // ============================================
  // 追加テスト - 列抽出
  // ============================================
  
  test('列抽出 - 列数が少ない場合', () => {
    document.getElementById('inputText').value = 'a,b\nc';
    document.getElementById('column-delimiter-text').value = ',';
    document.getElementById('column-count').value = '2';
    document.getElementById('column-trim').checked = false;
    document.getElementById('column-remove-empty').checked = false;
    executeColumnExtractMulti();
    const col1 = document.getElementById('col-output-0').value;
    const col2 = document.getElementById('col-output-1').value;
    return col1 === 'a\nc' && col2 === 'b\n';
  });
  
  // ============================================
  // 追加テスト - 検索と置換
  // ============================================
  
  test('検索と置換 - 複数回置換', () => {
    document.getElementById('inputText').value = 'aaa';
    document.getElementById('find-text').value = 'a';
    document.getElementById('replace-text').value = 'b';
    document.getElementById('find-case').checked = false;
    document.getElementById('find-regex').checked = false;
    executeFindReplace();
    return document.getElementById('outputText').value === 'bbb';
  });
  
  test('検索と置換 - 空文字への置換（削除）', () => {
    document.getElementById('inputText').value = 'hello world';
    document.getElementById('find-text').value = ' ';
    document.getElementById('replace-text').value = '';
    document.getElementById('find-case').checked = false;
    document.getElementById('find-regex').checked = false;
    executeFindReplace();
    return document.getElementById('outputText').value === 'helloworld';
  });
  
  test('検索と置換 - 正規表現で数字を削除', () => {
    document.getElementById('inputText').value = 'abc123def456';
    document.getElementById('find-text').value = '\\d+';
    document.getElementById('replace-text').value = '';
    document.getElementById('find-case').checked = false;
    document.getElementById('find-regex').checked = true;
    executeFindReplace();
    document.getElementById('find-regex').checked = false;
    return document.getElementById('outputText').value === 'abcdef';
  });
  
  // ============================================
  // 追加テスト - 行操作 フィルタ
  // ============================================
  
  test('行操作 - フィルタ（削除行を表示）', () => {
    document.getElementById('inputText').value = 'apple\nbanana';
    document.getElementById('filter-text').value = 'apple';
    document.getElementById('filter-case').checked = false;
    document.getElementById('filter-regex').checked = false;
    document.getElementById('filter-show-removed').checked = true;
    executeLineOps('filterContaining');
    document.getElementById('filter-show-removed').checked = false;
    const result = document.getElementById('outputText').value;
    return result.includes('banana') && result.includes('削除された行') && result.includes('apple');
  });
  
  // ============================================
  // 追加テスト - 行頭/行末
  // ============================================
  
  test('行頭/行末追加 - 日本語文字', () => {
    document.getElementById('inputText').value = 'あ\nい\nう';
    document.getElementById('prefix-text').value = '【';
    document.getElementById('suffix-text').value = '】';
    document.getElementById('prefix-skip-empty').checked = false;
    const output = executePrefixSuffix(document.getElementById('inputText').value);
    return output === '【あ】\n【い】\n【う】';
  });
  
  test('行頭/行末追加 - 特殊文字', () => {
    document.getElementById('inputText').value = 'line1\nline2';
    document.getElementById('prefix-text').value = '> ';
    document.getElementById('suffix-text').value = ' <';
    document.getElementById('prefix-skip-empty').checked = false;
    const output = executePrefixSuffix(document.getElementById('inputText').value);
    return output === '> line1 <\n> line2 <';
  });
  
  // ============================================
  // 追加テスト - 組み合わせ生成
  // ============================================
  
  test('組み合わせ生成 - 空のリスト', () => {
    document.getElementById('combo-list1').value = '';
    document.getElementById('combo-list2').value = 'a\nb';
    document.getElementById('combo-list3').value = '';
    document.getElementById('combo-separator').value = '';
    document.getElementById('inputText').value = '';
    executeCombination();
    // 空リストは結果に影響しない
    const result = document.getElementById('outputText').value;
    return result === 'a\nb' || result === '';
  });
  
  // ============================================
  // 追加テスト - ソート詳細
  // ============================================
  
  test('行操作 - 空行を含むソート', () => {
    document.getElementById('sort-delimiter').value = '';
    document.getElementById('sort-desc').checked = false;
    document.getElementById('inputText').value = 'c\n\na\nb';
    executeLineOps('sortAlpha');
    return document.getElementById('outputText').value === '\na\nb\nc';
  });
  
  test('行操作 - 日本語自然順ソート', () => {
    document.getElementById('sort-delimiter').value = '';
    document.getElementById('sort-desc').checked = false;
    document.getElementById('inputText').value = 'ファイル10\nファイル2\nファイル1';
    executeLineOps('sortNatural');
    return document.getElementById('outputText').value === 'ファイル1\nファイル2\nファイル10';
  });
  
  // ============================================
  // 追加テスト - 重複削除詳細
  // ============================================
  
  test('行操作 - 重複行削除（複数重複）', () => {
    document.getElementById('inputText').value = 'a\nb\na\nc\nb\na';
    document.getElementById('dup-case').checked = true;
    document.getElementById('dup-trim').checked = false;
    document.getElementById('dup-keep-order').checked = true;
    executeLineOps('removeDuplicates');
    return document.getElementById('outputText').value === 'a\nb\nc';
  });
  
  // ============================================
  // 追加テスト - 改行操作詳細
  // ============================================
  
  test('改行追加 - 日本語文字で改行', () => {
    document.getElementById('inputText').value = 'あいう。かきく。';
    document.getElementById('lb-target-text').value = '。';
    document.querySelector('input[name="lb-position"][value="after"]').checked = true;
    document.getElementById('lb-case-sensitive').checked = false;
    document.getElementById('lb-remove-existing').checked = false;
    executeLineBreakAtText();
    const result = document.getElementById('outputText').value;
    return result === 'あいう。\nかきく。\n' || result === 'あいう。\nかきく。';
  });
  
  test('改行削除 - 改行のみの行', () => {
    document.getElementById('inputText').value = 'a\n\nb\n\nc';
    document.getElementById('lb-remove-replace').value = ' ';
    executeLineBreakRemoveAll();
    return document.getElementById('outputText').value === 'a  b  c';
  });
  
  // ============================================
  // 追加テスト - 空白操作詳細
  // ============================================
  
  test('空白削除 - 全角スペースのみ', () => {
    document.getElementById('inputText').value = '　あ　い　う　';
    document.getElementById('space-remove-trim').checked = true;
    document.getElementById('space-remove-consecutive').checked = true;
    document.getElementById('space-remove-all').checked = false;
    executeRemoveSpaces();
    const result = document.getElementById('outputText').value;
    return result === 'あ い う' || result === 'あ　い　う';
  });
  
  // ============================================
  // 追加テスト - 文字カウント詳細
  // ============================================
  
  test('文字カウント - 空文字', () => {
    document.getElementById('inputText').value = '';
    document.getElementById('count-exclude-spaces').checked = false;
    document.getElementById('count-exclude-html').checked = false;
    document.getElementById('count-newline-as-space').checked = false;
    executeCount(document.getElementById('inputText').value);
    const output = document.getElementById('outputText').value;
    return output.includes('0');
  });
  
  test('文字カウント - 絵文字', () => {
    document.getElementById('inputText').value = '👍🎉';
    document.getElementById('count-exclude-spaces').checked = false;
    document.getElementById('count-exclude-html').checked = false;
    document.getElementById('count-newline-as-space').checked = false;
    executeCount(document.getElementById('inputText').value);
    const output = document.getElementById('outputText').value;
    return output.includes('文字');
  });
  
  // ============================================
  // 追加テスト - エッジケース
  // ============================================
  
  test('エッジケース - 空入力でソート', () => {
    document.getElementById('sort-delimiter').value = '';
    document.getElementById('sort-desc').checked = false;
    document.getElementById('inputText').value = '';
    executeLineOps('sortAlpha');
    return document.getElementById('outputText').value === '';
  });
  
  test('エッジケース - 1行のみでソート', () => {
    document.getElementById('sort-delimiter').value = '';
    document.getElementById('sort-desc').checked = false;
    document.getElementById('inputText').value = 'single';
    executeLineOps('sortAlpha');
    return document.getElementById('outputText').value === 'single';
  });
  
  test('エッジケース - 大文字小文字変換（日本語）', () => {
    document.getElementById('inputText').value = 'あいうえお';
    executeConvert('uppercase');
    return document.getElementById('outputText').value === 'あいうえお';
  });
  
  test('エッジケース - 空入力で重複削除', () => {
    document.getElementById('inputText').value = '';
    document.getElementById('dup-case').checked = true;
    document.getElementById('dup-trim').checked = false;
    document.getElementById('dup-keep-order').checked = true;
    executeLineOps('removeDuplicates');
    return document.getElementById('outputText').value === '';
  });
  
  test('エッジケース - 全て同じ行で重複削除', () => {
    document.getElementById('inputText').value = 'a\na\na\na';
    document.getElementById('dup-case').checked = true;
    document.getElementById('dup-trim').checked = false;
    document.getElementById('dup-keep-order').checked = true;
    executeLineOps('removeDuplicates');
    return document.getElementById('outputText').value === 'a';
  });
  
  test('エッジケース - 特殊文字を含む検索', () => {
    document.getElementById('inputText').value = 'a.b*c?d';
    document.getElementById('find-text').value = '.';
    document.getElementById('replace-text').value = '_';
    document.getElementById('find-case').checked = false;
    document.getElementById('find-regex').checked = false;
    executeFindReplace();
    return document.getElementById('outputText').value === 'a_b*c?d';
  });
  
  test('エッジケース - 正規表現特殊文字を含む検索', () => {
    document.getElementById('inputText').value = 'a[b]c';
    document.getElementById('find-text').value = '[b]';
    document.getElementById('replace-text').value = 'X';
    document.getElementById('find-case').checked = false;
    document.getElementById('find-regex').checked = false;
    executeFindReplace();
    return document.getElementById('outputText').value === 'aXc';
  });
  
  // ============================================
  // エンコード/デコード テスト
  // ============================================
  
  test('Base64 エンコード - ASCII', () => {
    document.getElementById('inputText').value = 'Hello World';
    executeConvert('base64Encode');
    return document.getElementById('outputText').value === 'SGVsbG8gV29ybGQ=';
  });
  
  test('Base64 デコード - ASCII', () => {
    document.getElementById('inputText').value = 'SGVsbG8gV29ybGQ=';
    executeConvert('base64Decode');
    return document.getElementById('outputText').value === 'Hello World';
  });
  
  test('Base64 エンコード - 日本語', () => {
    document.getElementById('inputText').value = 'こんにちは';
    executeConvert('base64Encode');
    const encoded = document.getElementById('outputText').value;
    // デコードして元に戻るか確認
    document.getElementById('inputText').value = encoded;
    executeConvert('base64Decode');
    return document.getElementById('outputText').value === 'こんにちは';
  });
  
  test('Base64 デコード - 不正な入力', () => {
    document.getElementById('inputText').value = '!!!invalid!!!';
    executeConvert('base64Decode');
    return document.getElementById('outputText').value.includes('エラー');
  });
  
  test('Quoted-Printable エンコード', () => {
    document.getElementById('inputText').value = 'Hello=World';
    executeConvert('quotedPrintableEncode');
    return document.getElementById('outputText').value.includes('=3D');
  });
  
  test('Quoted-Printable デコード', () => {
    document.getElementById('inputText').value = 'Hello=3DWorld';
    executeConvert('quotedPrintableDecode');
    return document.getElementById('outputText').value === 'Hello=World';
  });
  
  test('Quoted-Printable エンコード - 日本語', () => {
    document.getElementById('inputText').value = 'あ';
    executeConvert('quotedPrintableEncode');
    const encoded = document.getElementById('outputText').value;
    // デコードして元に戻るか確認
    document.getElementById('inputText').value = encoded;
    executeConvert('quotedPrintableDecode');
    return document.getElementById('outputText').value === 'あ';
  });
  
  test('URLエンコード', () => {
    document.getElementById('inputText').value = 'Hello World!';
    executeConvert('urlEncode');
    return document.getElementById('outputText').value === 'Hello%20World!';
  });
  
  test('URLデコード', () => {
    document.getElementById('inputText').value = 'Hello%20World!';
    executeConvert('urlDecode');
    return document.getElementById('outputText').value === 'Hello World!';
  });
  
  test('URLエンコード - 日本語', () => {
    document.getElementById('inputText').value = 'こんにちは';
    executeConvert('urlEncode');
    const encoded = document.getElementById('outputText').value;
    document.getElementById('inputText').value = encoded;
    executeConvert('urlDecode');
    return document.getElementById('outputText').value === 'こんにちは';
  });
  
  test('HTMLエンティティ エンコード', () => {
    document.getElementById('inputText').value = '\x3Cscript\x3Ealert("test")\x3C/script\x3E';
    executeConvert('htmlEntityEncode');
    return document.getElementById('outputText').value === '&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt;';
  });
  
  test('HTMLエンティティ デコード', () => {
    document.getElementById('inputText').value = '&lt;script&gt;alert(&quot;test&quot;)&lt;/script&gt;';
    executeConvert('htmlEntityDecode');
    return document.getElementById('outputText').value === '\x3Cscript\x3Ealert("test")\x3C/script\x3E';
  });
  
  test('HTMLエンティティ デコード - 数値参照', () => {
    document.getElementById('inputText').value = '&#65;&#66;&#67;';
    executeConvert('htmlEntityDecode');
    return document.getElementById('outputText').value === 'ABC';
  });
  
  test('HTMLエンティティ デコード - 16進参照', () => {
    document.getElementById('inputText').value = '&#x41;&#x42;&#x43;';
    executeConvert('htmlEntityDecode');
    return document.getElementById('outputText').value === 'ABC';
  });
  
  // ============================================
  // SQL整形 テスト
  // ============================================
  
  test('SQL整形 - 基本整形', () => {
    document.getElementById('inputText').value = 'select * from users where id = 1';
    document.getElementById('sql-uppercase-keywords').checked = true;
    document.getElementById('sql-newline-before-and').checked = false;
    document.getElementById('sql-newline-after-comma').checked = false;
    executeSqlFormat('format');
    const result = document.getElementById('outputText').value;
    return result.includes('SELECT') && result.includes('FROM') && result.includes('WHERE');
  });
  
  test('SQL整形 - 圧縮', () => {
    document.getElementById('inputText').value = 'SELECT  *  \n  FROM  users  \n  WHERE  id = 1';
    executeSqlFormat('minify');
    const result = document.getElementById('outputText').value;
    return !result.includes('\n') && result.includes('SELECT') && result.includes('FROM');
  });
  
  test('SQL整形 - 値リスト→INSERT文', () => {
    document.getElementById('inputText').value = 'apple\nbanana\ncherry';
    document.getElementById('sql-table-name').value = 'fruits';
    document.getElementById('sql-quote-values').checked = true;
    document.getElementById('sql-quote-char').value = "'";
    executeSqlFormat('toInsert');
    const result = document.getElementById('outputText').value;
    return result.includes('INSERT INTO fruits') && result.includes("'apple'") && result.includes("'banana'");
  });
  
  test('SQL整形 - 値リスト→IN句', () => {
    document.getElementById('inputText').value = '1\n2\n3';
    document.getElementById('sql-column-name').value = 'id';
    document.getElementById('sql-quote-values').checked = false;
    executeSqlFormat('toInClause');
    const result = document.getElementById('outputText').value;
    return result.includes('id IN') && result.includes('1') && result.includes('2') && result.includes('3');
  });
  
  test('SQL整形 - キーワード大文字', () => {
    document.getElementById('inputText').value = 'select count(*) from users group by status';
    document.getElementById('sql-uppercase-keywords').checked = true;
    executeSqlFormat('format');
    const result = document.getElementById('outputText').value;
    return result.includes('SELECT') && result.includes('COUNT') && result.includes('GROUP BY');
  });
  
  test('SQL整形 - AND/ORで改行', () => {
    document.getElementById('inputText').value = 'SELECT * FROM users WHERE id = 1 AND name = "test" OR status = 1';
    document.getElementById('sql-uppercase-keywords').checked = true;
    document.getElementById('sql-newline-before-and').checked = true;
    executeSqlFormat('format');
    document.getElementById('sql-newline-before-and').checked = false;
    const result = document.getElementById('outputText').value;
    const lines = result.split('\n');
    return lines.some(l => l.trim().startsWith('AND')) || lines.some(l => l.trim().startsWith('OR'));
  });
  
  // ============================================
  // 正規表現テスター テスト
  // ============================================
  
  test('正規表現 - マッチ抽出', () => {
    document.getElementById('inputText').value = 'abc123def456ghi789';
    document.getElementById('regex-pattern').value = '\\d+';
    document.getElementById('regex-flag-g').checked = true;
    document.getElementById('regex-flag-i').checked = false;
    executeRegexExtract();
    return document.getElementById('outputText').value === '123\n456\n789';
  });
  
  test('正規表現 - 置換', () => {
    document.getElementById('inputText').value = 'hello world';
    document.getElementById('regex-pattern').value = 'world';
    document.getElementById('regex-replace').value = 'universe';
    document.getElementById('regex-flag-g').checked = true;
    executeRegexReplace();
    return document.getElementById('outputText').value === 'hello universe';
  });
  
  test('正規表現 - グループ置換', () => {
    document.getElementById('inputText').value = 'John Smith';
    document.getElementById('regex-pattern').value = '(\\w+) (\\w+)';
    document.getElementById('regex-replace').value = '$2, $1';
    document.getElementById('regex-flag-g').checked = true;
    executeRegexReplace();
    return document.getElementById('outputText').value === 'Smith, John';
  });
  
  test('正規表現 - 大文字小文字無視フラグ', () => {
    document.getElementById('inputText').value = 'Hello HELLO hello';
    document.getElementById('regex-pattern').value = 'hello';
    document.getElementById('regex-flag-g').checked = true;
    document.getElementById('regex-flag-i').checked = true;
    executeRegexExtract();
    document.getElementById('regex-flag-i').checked = false;
    return document.getElementById('outputText').value === 'Hello\nHELLO\nhello';
  });
  
  // ============================================
  // Markdown/HTML変換 テスト
  // ============================================
  
  test('MD→HTML - 見出し', () => {
    document.getElementById('inputText').value = '# 見出し1\n## 見出し2';
    executeMdHtml('mdToHtml');
    const result = document.getElementById('outputText').value;
    return result.includes('<h1>見出し1</h1>') && result.includes('<h2>見出し2</h2>');
  });
  
  test('MD→HTML - 太字・斜体', () => {
    document.getElementById('inputText').value = '**太字** *斜体* ~~取消~~';
    executeMdHtml('mdToHtml');
    const result = document.getElementById('outputText').value;
    return result.includes('<strong>太字</strong>') && result.includes('<em>斜体</em>') && result.includes('<del>取消</del>');
  });
  
  test('MD→HTML - リンク', () => {
    document.getElementById('inputText').value = '[リンク](https://example.com)';
    executeMdHtml('mdToHtml');
    const result = document.getElementById('outputText').value;
    return result.includes('<a href="https://example.com">リンク</a>');
  });
  
  test('MD→HTML - リスト', () => {
    document.getElementById('inputText').value = '- 項目1\n- 項目2';
    executeMdHtml('mdToHtml');
    const result = document.getElementById('outputText').value;
    return result.includes('<li>項目1</li>') && result.includes('<li>項目2</li>');
  });
  
  test('HTML→MD - 見出し', () => {
    document.getElementById('inputText').value = '<h1>見出し1</h1><h2>見出し2</h2>';
    executeMdHtml('htmlToMd');
    const result = document.getElementById('outputText').value;
    return result.includes('# 見出し1') && result.includes('## 見出し2');
  });
  
  test('HTML→MD - 太字・斜体', () => {
    document.getElementById('inputText').value = '<strong>太字</strong> <em>斜体</em>';
    executeMdHtml('htmlToMd');
    const result = document.getElementById('outputText').value;
    return result.includes('**太字**') && result.includes('*斜体*');
  });
  
  test('HTML→MD - リンク', () => {
    document.getElementById('inputText').value = '<a href="https://example.com">リンク</a>';
    executeMdHtml('htmlToMd');
    const result = document.getElementById('outputText').value;
    return result.includes('[リンク](https://example.com)');
  });
  
  // ============================================
  // メールデコード テスト
  // ============================================
  
  test('メールデコード - MIMEヘッダー（Base64/UTF-8）', () => {
    document.getElementById('inputText').value = '=?UTF-8?B?44GT44KT44Gr44Gh44Gv?=';
    executeMailDecode('header');
    return document.getElementById('outputText').value === 'こんにちは';
  });
  
  test('メールデコード - MIMEヘッダー（Quoted-Printable）', () => {
    document.getElementById('inputText').value = '=?UTF-8?Q?Hello_World?=';
    executeMailDecode('header');
    return document.getElementById('outputText').value === 'Hello World';
  });
  
  test('メールデコード - Base64本文', () => {
    document.getElementById('inputText').value = 'SGVsbG8gV29ybGQ=';
    document.getElementById('mail-decode-jis').checked = false;
    document.getElementById('mail-decode-sjis').checked = false;
    executeMailDecode('base64');
    document.getElementById('mail-decode-jis').checked = true;
    return document.getElementById('outputText').value === 'Hello World';
  });
  
  // 結果サマリー
  console.log('========================================');
  console.log(`テスト完了: ${passed} 成功, ${failed} 失敗`);
  console.log('========================================');
  
  return { passed, failed };
}

// コンソールから実行できるようにグローバルに公開
window.runAllTests = runAllTests;
</script>
</body>
</html>

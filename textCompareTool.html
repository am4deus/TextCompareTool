<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DiffViewã€Šï¾ƒï¾ï½¨ï¾Œï¾‹ï¾ï½­ï½°ã€‹- ãƒ†ã‚­ã‚¹ãƒˆæ¯”è¼ƒãƒ„ãƒ¼ãƒ«</title>

<!-- Favicon (single-file) -->
<link id="favicon" rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NCA2NCI+CiAgPGRlZnM+CiAgICA8bGluZWFyR3JhZGllbnQgaWQ9InRleHRHcmFkIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIxMDAlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3RvcC1jb2xvcj0iIzAwNzdjYyIvPgogICAgICA8c3RvcCBvZmZzZXQ9IjEwMCUiIHN0b3AtY29sb3I9IiMwMGZmY2MiLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgPC9kZWZzPgogIDxyZWN0IHdpZHRoPSI2NCIgaGVpZ2h0PSI2NCIgcng9IjEyIiBmaWxsPSIjZjVmNWY3Ii8+CiAgPHRleHQgeD0iMzEiIHk9IjQ4IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIgogICAgICAgIGZvbnQtZmFtaWx5PSJCYWhuc2NocmlmdCwgJ1NlZ29lIFVJJywgc2Fucy1zZXJpZiIKICAgICAgICBmb250LXNpemU9IjQ0IiBmb250LXdlaWdodD0iNTAwIiBsZXR0ZXItc3BhY2luZz0iMCIKICAgICAgICBmaWxsPSJ1cmwoI3RleHRHcmFkKSI+REY8L3RleHQ+Cjwvc3ZnPgo=">

<script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.4.0/exceljs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/encoding-japanese/2.0.0/encoding.min.js"></script>
<style>
:root {
  --bg: #f5f5f7;
  --surface: #ffffff;
  --surface-raised: #f0f0f2;
  --border: #d0d0d8;
  --text: #1a1a2e;
  --text-muted: #666680;
  --accent: #0077cc;
  --accent-glow: rgba(0, 119, 204, 0.1);
  --delete: #d63031;
  --delete-bg: rgba(214, 48, 49, 0.12);
  --insert: #00a86b;
  --insert-bg: rgba(0, 168, 107, 0.12);
  --change: #e67e22;
  --change-bg: rgba(230, 126, 34, 0.12);
  --grid-color: rgba(0, 119, 204, 0.05);
}

/* Dark theme */
[data-theme="dark"] {
  --bg: #0a0a0f;
  --surface: #12121a;
  --surface-raised: #1a1a26;
  --border: #2a2a3a;
  --text: #e8e8f0;
  --text-muted: #8888a0;
  --accent: #00d4ff;
  --accent-glow: rgba(0, 212, 255, 0.15);
  --delete: #ff6b8a;
  --delete-bg: rgba(255, 107, 138, 0.15);
  --insert: #7dffb3;
  --insert-bg: rgba(125, 255, 179, 0.15);
  --change: #ffcc4d;
  --change-bg: rgba(255, 204, 77, 0.15);
  --grid-color: rgba(0, 212, 255, 0.03);
}

/* Sepia theme */
[data-theme="sepia"] {
  --bg: #f4ecd8;
  --surface: #faf6eb;
  --surface-raised: #efe9d9;
  --border: #d4c9a8;
  --text: #433422;
  --text-muted: #7a6a50;
  --accent: #8b4513;
  --accent-glow: rgba(139, 69, 19, 0.1);
  --delete: #a0522d;
  --delete-bg: rgba(160, 82, 45, 0.15);
  --insert: #228b22;
  --insert-bg: rgba(34, 139, 34, 0.15);
  --change: #b8860b;
  --change-bg: rgba(184, 134, 11, 0.15);
  --grid-color: rgba(139, 69, 19, 0.04);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
  line-height: 1.6;
}

/* Subtle grid background */
body::before {
  content: '';
  position: fixed;
  inset: 0;
  background-image: 
    linear-gradient(var(--grid-color) 1px, transparent 1px),
    linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
  background-size: 50px 50px;
  pointer-events: none;
  z-index: -1;
}

.container {
  max-width: none;
  margin: 0;
  padding: 16px;
}

/* Header */
header {
  text-align: center;
  margin-bottom: 16px;
  animation: fadeInDown 0.6s ease-out;
}

@keyframes fadeInDown {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

h1 {
  font-size: 1.5rem;
  font-weight: 700;
  letter-spacing: -0.02em;
  margin-bottom: 0;
}

h1 span.tool-name {
  background: linear-gradient(135deg, var(--accent), #00ffcc);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

h1 span.katakana {
  font-size: 1rem;
  color: var(--text-muted);
  -webkit-text-fill-color: var(--text-muted);
  margin-left: 8px;
  font-weight: 400;
}

.tagline {
  display: none;
}

/* Input Section */
.input-section {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
  margin-bottom: 16px;
  animation: fadeIn 0.6s ease-out 0.1s both;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.input-panel {
  display: flex;
  flex-direction: column;
}

.input-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
  flex-shrink: 0;
}

.input-label {
  font-family: monospace;
  font-size: 0.75rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  gap: 8px;
}

.file-input {
  cursor: pointer;
}

.file-input input {
  display: none;
}

.file-input span {
  font-size: 0.75rem;
  color: var(--text-muted);
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  transition: all 0.2s;
}

.file-input:hover span {
  color: var(--text);
  border-color: var(--accent);
}

.input-actions {
  display: flex;
  align-items: center;
  gap: 4px;
}

.sort-input-btn {
  background: transparent;
  border: 1px solid var(--border);
  color: var(--text-muted);
  font-size: 0.7rem;
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s;
}

.sort-input-btn:hover {
  border-color: var(--accent);
  color: var(--accent);
  background: var(--accent-glow);
}

.input-panel.drag-over textarea {
  border-color: var(--accent);
  background: var(--accent-glow);
}

.input-label::before {
  content: '';
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 2px;
  background: var(--accent);
}

.input-panel:last-child .input-label::before {
  background: linear-gradient(135deg, #00ffcc, #00d4ff);
}

textarea {
  min-height: 200px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px 12px;
  font-family: monospace;
  font-size: 0.8rem;
  color: var(--text);
  resize: vertical;
  transition: border-color 0.2s, box-shadow 0.2s;
}

textarea:focus {
  outline: none;
  border-color: var(--accent);
  box-shadow: 0 0 0 3px var(--accent-glow);
}

textarea::placeholder {
  color: var(--text-muted);
  opacity: 0.6;
}

/* Actions */
.actions {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  margin-bottom: 16px;
  animation: fadeIn 0.6s ease-out 0.2s both;
  flex-wrap: wrap;
}

button {
  font-family: sans-serif;
  font-size: 0.85rem;
  font-weight: 600;
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-primary {
  background: var(--accent);
  color: var(--bg);
  border: none;
  box-shadow: 0 4px 20px var(--accent-glow);
}

.btn-primary:hover {
  transform: translateY(-2px);
  filter: brightness(1.1);
}

.btn-primary:active {
  transform: translateY(0);
}

.btn-secondary {
  background: transparent;
  color: var(--text-muted);
  border: 1px solid var(--border);
}

.btn-secondary:hover {
  border-color: var(--text-muted);
  color: var(--text);
}

.btn-secondary.is-active {
  border-color: var(--accent);
  color: var(--text);
  box-shadow: 0 0 0 2px var(--accent-glow);
}

/* Diff-only mode: hide rows without diffs */
#results.diff-only-mode #diffBody tr.no-diff-row {
  display: none;
}

/* Result-only mode: hide everything except results */
body.result-only-mode header,
body.result-only-mode .input-section,
body.result-only-mode .actions,
body.result-only-mode footer,
body.result-only-mode .results-title {
  display: none !important;
}

body.result-only-mode .results-header {
  border-bottom: none;
  margin-bottom: 8px;
  padding-bottom: 0;
}

body.result-only-mode .container {
  padding: 8px;
}

body.result-only-mode .results-section {
  animation: none;
}

/* å°åˆ·æ™‚ã®è¨­å®š */
@media print {
  /* å°åˆ·æ™‚ã¯ãƒ©ã‚¤ãƒˆãƒ¢ãƒ¼ãƒ‰ã®è‰²ã‚’å¼·åˆ¶ */
  :root, [data-theme="dark"], [data-theme="sepia"] {
    --bg: #ffffff;
    --surface: #ffffff;
    --surface-raised: #f0f0f2;
    --border: #d0d0d8;
    --text: #1a1a2e;
    --text-muted: #666680;
    --delete: #d63031;
    --delete-bg: rgba(214, 48, 49, 0.15);
    --insert: #00a86b;
    --insert-bg: rgba(0, 168, 107, 0.15);
    --change: #e67e22;
    --change-bg: rgba(230, 126, 34, 0.15);
  }
  
  header,
  .input-section,
  .actions,
  footer,
  .results-title,
  .results-actions {
    display: none !important;
  }
  
  .results-header {
    border-bottom: none;
    margin-bottom: 8px;
    padding-bottom: 0;
  }
  
  .results-info {
    display: flex !important;
    gap: 24px;
  }
  
  body::before {
    display: none;
  }
  
  .container {
    padding: 0;
  }
  
  .results-section {
    display: block !important;
  }
  
  .diff-container {
    border: 1px solid #ccc;
  }
  
  /* å°åˆ·æ™‚ã‚‚ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºã‚’ç¶­æŒ */
  .diff-delete,
  .diff-delete.space-char {
    background: var(--delete-bg) !important;
    color: var(--delete) !important;
    -webkit-print-color-adjust: exact;
    print-color-adjust: exact;
  }
  
  .diff-insert,
  .diff-insert.space-char {
    background: var(--insert-bg) !important;
    color: var(--insert) !important;
    -webkit-print-color-adjust: exact;
    print-color-adjust: exact;
  }
  
  .newline-marker {
    background: var(--change-bg) !important;
    color: var(--change) !important;
    -webkit-print-color-adjust: exact;
    print-color-adjust: exact;
  }
  
  /* å·®åˆ†ã‚«ã‚¦ãƒ³ãƒˆã¯å°åˆ·æ™‚ã‚‚è¡¨ç¤º */
  .diff-stats {
    display: flex !important;
  }
}

.btn-icon {
  padding: 10px 14px;
  font-size: 1.1rem;
  display: flex;
  align-items: center;
  gap: 6px;
}

.btn-icon span {
  font-size: 0.85rem;
}

/* Theme selector */
.theme-selector {
  display: flex;
  gap: 8px;
  margin-left: 16px;
  padding-left: 16px;
  border-left: 1px solid var(--border);
}

.theme-btn {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  border: 2px solid var(--border);
  cursor: pointer;
  transition: all 0.2s;
  padding: 0;
}

.theme-btn:hover {
  transform: scale(1.1);
}

.theme-btn.active {
  border-color: var(--accent);
  box-shadow: 0 0 0 2px var(--accent-glow);
}

.theme-btn.dark {
  background: #0a0a0f;
}

.theme-btn.light {
  background: #f5f5f7;
}

.theme-btn.sepia {
  background: #f4ecd8;
}

/* Results Section */
.results-section {
  display: none;
  animation: slideUp 0.5s ease-out;
}

.results-section.visible {
  display: block;
}

@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(30px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.results-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
  flex-wrap: wrap;
  gap: 8px;
}

.results-actions {
  display: flex;
  align-items: center;
  gap: 16px;
}

.btn-small {
  padding: 4px 10px;
  font-size: 0.75rem;
}

.results-title {
  font-size: 1rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 8px;
}

.results-title::before {
  content: 'âŸ¨âŸ©';
  font-family: monospace;
  color: var(--accent);
}

.legend {
  display: flex;
  gap: 16px;
  font-size: 0.75rem;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 4px;
}

.legend-badge {
  padding: 1px 6px;
  border-radius: 3px;
  font-family: monospace;
  font-size: 0.7rem;
}

.legend-badge.delete {
  background: var(--delete-bg);
  color: var(--delete);
  border: 1px solid var(--delete);
}

.legend-badge.insert {
  background: var(--insert-bg);
  color: var(--insert);
  border: 1px solid var(--insert);
}

.legend-badge.change {
  background: var(--change-bg);
  color: var(--change);
  border: 1px solid var(--change);
}

/* Diff Table */
.diff-container {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  overflow: hidden;
}

.diff-table {
  width: 100%;
  border-collapse: collapse;
  font-size: var(--diff-font-size, 13px);
}

.diff-table th {
  background: var(--surface-raised);
  padding: 6px 12px;
  text-align: left;
  font-family: monospace;
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--text-muted);
  border-bottom: 1px solid var(--border);
}

.diff-table td {
  padding: 4px 12px;
  vertical-align: top;
  font-family: monospace;
  font-size: inherit;
  line-height: var(--diff-line-height, 1.5);
  border-bottom: 1px solid var(--border);
  white-space: pre-wrap;
  word-break: break-all;
}

.diff-table tr:last-child td {
  border-bottom: none;
}

.diff-table td:nth-child(2),
.diff-table td:nth-child(3) {
  width: 50%;
}

.diff-table td:nth-child(2) {
  border-right: 1px solid var(--border);
}

/* Diff highlights */
.diff-delete {
  background: var(--delete-bg);
  color: var(--delete);
  border-radius: 3px;
  text-decoration-color: rgba(255, 107, 138, 0.5);
}

.diff-insert {
  background: var(--insert-bg);
  color: var(--insert);
  border-radius: 3px;
}

/* Space characters - individual highlight */
.space-char {
  min-width: 0.5em;
}

.diff-change {
  background: var(--change-bg);
  color: var(--change);
  border-radius: 3px;
  padding: 1px 4px;
}

/* Newline markers */
.newline-marker {
  font-family: monospace;
  font-size: 0.85rem;
  padding: 1px 4px;
  border-radius: 3px;
  margin: 0 2px;
  background: var(--change-bg);
  color: var(--change);
  user-select: none;
}

/* Empty cell (placeholder for missing lines) */
.empty-cell {
  background: rgba(128, 128, 128, 0.1);
}

.empty-line {
  display: block;
  height: 1.2em;
}

/* Stats */
.stats-row td {
  background: var(--surface-raised);
  padding: 8px 20px;
  border-top: 1px solid var(--border);
  white-space: normal;
}

.stats {
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 2px;
  font-size: 0.75rem;
}

.stats-line {
  display: flex;
  align-items: center;
  gap: 4px;
}

.stats dt {
  color: var(--text-muted);
}

.stats dt::after {
  content: ':';
}

.stats dd {
  margin: 0 12px 0 0;
  font-weight: 600;
  color: var(--text);
  font-variant-numeric: tabular-nums;
}

/* No differences */
.no-diff {
  text-align: center;
  padding: 40px 20px;
  color: var(--text-muted);
}

.no-diff-icon {
  font-size: 2rem;
  margin-bottom: 12px;
  opacity: 0.5;
}

/* Line number column */
.line-num-col {
  width: 50px;
  min-width: 50px;
  text-align: center;
}

.line-num {
  color: var(--text-muted);
  font-size: 0.7rem;
  text-align: center;
  padding: 4px 8px !important;
  border-right: 1px solid var(--border);
  user-select: none;
  width: 50px;
  min-width: 50px;
  white-space: nowrap;
}

/* Results info (diff-stats + legend) */
.results-info {
  display: flex;
  align-items: center;
  gap: 24px;
}

/* Diff stats */
.diff-stats {
  font-size: 0.8rem;
  color: var(--text-muted);
  display: flex;
  gap: 12px;
}

.diff-stats .stat-delete {
  color: var(--delete);
  font-weight: 600;
}

.diff-stats .stat-insert {
  color: var(--insert);
  font-weight: 600;
}

/* Font size control */
.text-settings {
  position: relative;
}

.text-popup {
  display: none;
  position: absolute;
  top: 100%;
  right: 0;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 12px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.15);
  z-index: 100;
  min-width: 200px;
}

.text-popup.visible {
  display: block;
}

.setting-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 10px;
}

.setting-row label {
  font-size: 0.8rem;
  color: var(--text);
  min-width: 70px;
}

.setting-row input[type="range"] {
  flex: 1;
  cursor: pointer;
}

.setting-row span {
  font-size: 0.75rem;
  color: var(--text-muted);
  min-width: 36px;
  text-align: right;
}

.setting-row input[type="color"] {
  width: 32px;
  height: 24px;
  border: 1px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
  padding: 0;
}

.setting-section {
  margin-bottom: 12px;
  padding-bottom: 12px;
  border-bottom: 1px solid var(--border);
}

.setting-section:last-of-type {
  margin-bottom: 0;
  padding-bottom: 0;
  border-bottom: none;
}

.setting-section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.setting-section-title {
  font-size: 0.75rem;
  font-weight: 600;
  color: var(--text-muted);
}

.btn-reset {
  font-size: 0.65rem;
  padding: 2px 6px;
  background: transparent;
  border: 1px solid var(--border);
  border-radius: 3px;
  color: var(--text-muted);
  cursor: pointer;
  transition: all 0.2s;
}

.btn-reset:hover {
  border-color: var(--accent);
  color: var(--text);
}

/* Footer */
footer {
  margin-top: 24px;
  text-align: center;
  color: var(--text-muted);
  font-size: 0.7rem;
  padding-top: 12px;
  border-top: 1px solid var(--border);
}

footer a {
  color: var(--accent);
  text-decoration: none;
}

footer a:hover {
  text-decoration: underline;
}

/* Responsive */
@media (max-width: 768px) {
  .input-section {
    grid-template-columns: 1fr;
  }
  
  .results-header {
    flex-direction: column;
    gap: 16px;
    align-items: flex-start;
  }
  
  .legend {
    flex-wrap: wrap;
  }
  
  h1 {
    font-size: 1.75rem;
  }
  
  h1 span.katakana {
    display: block;
    margin-left: 0;
    margin-top: 4px;
  }
}
</style>
</head>
<body>
<div class="container">
  <header>
    <h1>
      <span class="tool-name">DiffView</span>
      <span class="katakana">ã€Šï¾ƒï¾ï½¨ï¾Œï¾‹ï¾ï½­ï½°ã€‹</span>
    </h1>
    <p class="tagline">2ã¤ã®ãƒ†ã‚­ã‚¹ãƒˆã®å·®åˆ†ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤ºã™ã‚‹ãƒ„ãƒ¼ãƒ«</p>
  </header>

  <div class="input-section">
    <div class="input-panel" id="panelA">
      <div class="input-header">
        <label class="input-label">ãƒ†ã‚­ã‚¹ãƒˆ Aï¼ˆå…ƒã®ãƒ†ã‚­ã‚¹ãƒˆï¼‰</label>
        <div class="input-actions">
          <button class="sort-input-btn" onclick="sortInput('textA', 'asc')" title="æ˜‡é †ã‚½ãƒ¼ãƒˆ">â–²</button>
          <button class="sort-input-btn" onclick="sortInput('textA', 'desc')" title="é™é †ã‚½ãƒ¼ãƒˆ">â–¼</button>
          <button class="sort-input-btn" onclick="removeDuplicates('textA')" title="é‡è¤‡è¡Œã‚’å‰Šé™¤">é‡è¤‡è¡Œå‰Šé™¤</button>
          <label class="file-input">
            <input type="file" accept=".txt,.md,.html,.htm,.xht,.xhtml,.css,.js,.json,.xml,.csv,.java,.properties,.gradle,.kt,.scala,.groovy,.yml,.yaml,.pom" onchange="loadFile(event, 'textA')">
            <span>ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«</span>
          </label>
        </div>
      </div>
      <textarea id="textA" placeholder="ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã€ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—..."></textarea>
    </div>
    <div class="input-panel" id="panelB">
      <div class="input-header">
        <label class="input-label">ãƒ†ã‚­ã‚¹ãƒˆ Bï¼ˆå¤‰æ›´å¾Œã®ãƒ†ã‚­ã‚¹ãƒˆï¼‰</label>
        <div class="input-actions">
          <button class="sort-input-btn" onclick="sortInput('textB', 'asc')" title="æ˜‡é †ã‚½ãƒ¼ãƒˆ">â–²</button>
          <button class="sort-input-btn" onclick="sortInput('textB', 'desc')" title="é™é †ã‚½ãƒ¼ãƒˆ">â–¼</button>
          <button class="sort-input-btn" onclick="removeDuplicates('textB')" title="é‡è¤‡è¡Œã‚’å‰Šé™¤">é‡è¤‡è¡Œå‰Šé™¤</button>
          <label class="file-input">
            <input type="file" accept=".txt,.md,.html,.htm,.xht,.xhtml,.css,.js,.json,.xml,.csv,.java,.properties,.gradle,.kt,.scala,.groovy,.yml,.yaml,.pom" onchange="loadFile(event, 'textB')">
            <span>ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«</span>
          </label>
        </div>
      </div>
      <textarea id="textB" placeholder="ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã€ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—..."></textarea>
    </div>
  </div>

  <div class="actions">
    <button class="btn-primary" onclick="compareHybrid()">æ¯”è¼ƒã™ã‚‹ (Ctrl+Enter)</button>
    <button class="btn-secondary" onclick="compareLine()">è¡Œæ¯”è¼ƒ</button>
    <button class="btn-secondary" onclick="compareChars()">æ–‡å­—æ¯”è¼ƒ</button>
    <button class="btn-secondary" onclick="compareCharsLegacy()">æ–‡å­—æ¯”è¼ƒï¼ˆãƒ¬ã‚¬ã‚·ãƒ¼ï¼‰</button>
    <button class="btn-secondary btn-icon" onclick="swapTexts()" title="å·¦å³å…¥ã‚Œæ›¿ãˆ">â‡„<span>å…¥æ›¿</span></button>
    <button class="btn-secondary" onclick="clearAll()">ã‚¯ãƒªã‚¢</button>
    <button class="btn-secondary" onclick="loadSample()">ã‚µãƒ³ãƒ—ãƒ«</button>
    <button class="btn-secondary" onclick="loadSample2()">ã‚µãƒ³ãƒ—ãƒ«2</button>
    <div class="theme-selector">
      <button class="theme-btn dark" onclick="setTheme('dark')" title="ãƒ€ãƒ¼ã‚¯"></button>
      <button class="theme-btn light active" onclick="setTheme('light')" title="ãƒ©ã‚¤ãƒˆ"></button>
      <button class="theme-btn sepia" onclick="setTheme('sepia')" title="ã‚»ãƒ”ã‚¢"></button>
    </div>
  </div>

  <section class="results-section" id="results">
    <div class="results-header">
      <div class="results-info">
        <h2 class="results-title">æ¯”è¼ƒçµæœ</h2>
        <div class="diff-stats" id="diffStats"></div>
        <div class="legend">
          <div class="legend-item">
            <span class="legend-badge delete">å‰Šé™¤</span>
            <span>Aã®ã¿ã«å­˜åœ¨</span>
          </div>
          <div class="legend-item">
            <span class="legend-badge insert">æŒ¿å…¥</span>
            <span>Bã®ã¿ã«å­˜åœ¨</span>
          </div>
          <div class="legend-item">
            <span class="legend-badge change">â†µ</span>
            <span>æ”¹è¡Œã®å·®åˆ†</span>
          </div>
        </div>
      </div>
      <div class="results-actions">
        <button class="btn-secondary btn-small" id="toggleDiffOnlyBtn" onclick="toggleDiffOnly()">å·®åˆ†ã®ã¿è¡¨ç¤º</button>
        <button class="btn-secondary btn-small" id="toggleResultOnlyBtn" onclick="toggleResultOnly()">çµæœã®ã¿è¡¨ç¤º</button>
        <button class="btn-secondary btn-small" onclick="downloadExcel()">ğŸ“¥ Excelãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</button>
        <button class="btn-secondary btn-small" onclick="window.print()">ğŸ–¨ å°åˆ·</button>
        <div class="text-settings">
          <button class="btn-secondary btn-small" onclick="toggleTextSettings()">âš™ è¡¨ç¤ºè¨­å®š</button>
          <div class="text-popup" id="textPopup">
            <div class="setting-section">
              <div class="setting-section-header">
                <span class="setting-section-title">ğŸ“ ã‚µã‚¤ã‚º</span>
                <button class="btn-reset" onclick="resetTextSettings()">ãƒªã‚»ãƒƒãƒˆ</button>
              </div>
              <div class="setting-row">
                <label>æ–‡å­—ã‚µã‚¤ã‚º:</label>
                <input type="range" id="fontSizeSlider" min="10" max="20" value="13" onchange="setFontSize(this.value)" oninput="setFontSize(this.value)">
                <span id="fontSizeValue">13px</span>
              </div>
              <div class="setting-row">
                <label>è¡Œé–“:</label>
                <input type="range" id="lineHeightSlider" min="10" max="30" value="15" onchange="setLineHeight(this.value)" oninput="setLineHeight(this.value)">
                <span id="lineHeightValue">1.5</span>
              </div>
            </div>
            <div class="setting-section">
              <div class="setting-section-header">
                <span class="setting-section-title">ğŸ¨ ãƒã‚¤ãƒ©ã‚¤ãƒˆè‰²</span>
                <button class="btn-reset" onclick="resetColors()">ãƒªã‚»ãƒƒãƒˆ</button>
              </div>
              <div class="setting-row">
                <label>å‰Šé™¤:</label>
                <input type="color" id="colorDelete" value="#d63031" onchange="updateHighlightColor()">
              </div>
              <div class="setting-row">
                <label>æŒ¿å…¥:</label>
                <input type="color" id="colorInsert" value="#00a86b" onchange="updateHighlightColor()">
              </div>
              <div class="setting-row">
                <label>æ”¹è¡Œ:</label>
                <input type="color" id="colorChange" value="#e67e22" onchange="updateHighlightColor()">
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="diff-container">
      <table class="diff-table" id="diffTable">
        <thead>
          <tr>
            <th class="line-num-col">#</th>
            <th>ãƒ†ã‚­ã‚¹ãƒˆ A</th>
            <th>ãƒ†ã‚­ã‚¹ãƒˆ B</th>
          </tr>
        </thead>
        <tbody id="diffBody">
        </tbody>
      </table>
    </div>
  </section>

  <footer>
    <p>
      ã“ã®ãƒ„ãƒ¼ãƒ«ã¯é€šä¿¡ç„¡ã—ã§ãƒ–ãƒ©ã‚¦ã‚¶å†…ã§å‹•ä½œã—ã¾ã™ã€‚
    </p>
    <p>
      ä»¥ä¸‹ã«ã“ã®ãƒ„ãƒ¼ãƒ«ã®å…ƒã¨ãªã£ãŸãƒ„ãƒ¼ãƒ«"difff"ã®è‘—ä½œæ¨©ã¨ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã‚’è¨˜è¼‰:<br>
      Copyright &copy; 2004-2025 Yuki Naito (@meso_cacase)<br>
      <small>This software is distributed under modified BSD license.</small>
    </p>

  </footer>
</div>

<script>
// å…¥åŠ›æ¬„ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡Œå˜ä½ã§ã‚½ãƒ¼ãƒˆ
function sortInput(textareaId, order) {
  const textarea = document.getElementById(textareaId);
  if (!textarea) return;
  
  const text = textarea.value;
  if (!text.trim()) return;
  
  // è¡Œã«åˆ†å‰²
  const lines = text.split('\n');
  
  // ã‚½ãƒ¼ãƒˆï¼ˆæ—¥æœ¬èªå¯¾å¿œï¼‰
  lines.sort((a, b) => {
    const result = a.localeCompare(b, 'ja');
    return order === 'asc' ? result : -result;
  });
  
  // çµåˆã—ã¦æˆ»ã™
  textarea.value = lines.join('\n');
}

// å…¥åŠ›æ¬„ã®é‡è¤‡è¡Œã‚’å‰Šé™¤
function removeDuplicates(textareaId) {
  const textarea = document.getElementById(textareaId);
  if (!textarea) return;
  
  const text = textarea.value;
  if (!text.trim()) return;
  
  // è¡Œã«åˆ†å‰²
  const lines = text.split('\n');
  
  // é‡è¤‡ã‚’å‰Šé™¤ï¼ˆé †åºã‚’ä¿æŒï¼‰
  const seen = new Set();
  const uniqueLines = lines.filter(line => {
    if (seen.has(line)) {
      return false;
    }
    seen.add(line);
    return true;
  });
  
  // çµåˆã—ã¦æˆ»ã™
  textarea.value = uniqueLines.join('\n');
}

// ãƒ†ã‚­ã‚¹ãƒˆã‚’æ¯”è¼ƒå˜ä½ã«åˆ†å‰²ï¼ˆå˜èªã¾ãŸã¯æ–‡å­—å˜ä½ï¼‰
function tokenize(text) {
  const tokens = [];
  let i = 0;
  while (i < text.length) {
    // è‹±å˜èª
    if (/[a-zA-Z]/.test(text[i])) {
      let word = '';
      while (i < text.length && /[a-zA-Z]/.test(text[i])) {
        word += text[i];
        i++;
      }
      tokens.push(word);
    }
    // æ”¹è¡Œ
    else if (text[i] === '\n') {
      tokens.push('\n');
      i++;
    }
        // CRã¯ç„¡è¦–ï¼ˆå¿µã®ãŸã‚ï¼‰
    else if (text[i] === '\r') {
      i++;
    }
// ãã®ä»–ã®æ–‡å­—ï¼ˆæ—¥æœ¬èªå«ã‚€ï¼‰
    else {
      tokens.push(text[i]);
      i++;
    }
  }
  return tokens;
}

// æœ€é•·å…±é€šéƒ¨åˆ†åˆ—ï¼ˆLCSï¼‰ã‚’ç”¨ã„ãŸå·®åˆ†æ¤œå‡º
function computeLCS(a, b) {
  const m = a.length;
  const n = b.length;
  const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
  
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (a[i - 1] === b[j - 1]) {
        dp[i][j] = dp[i - 1][j - 1] + 1;
      } else {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
      }
    }
  }
  return dp;
}

// å·®åˆ†ã‚’ç”Ÿæˆ
function generateDiff(a, b) {
  const dp = computeLCS(a, b);
  const diff = [];
  let i = a.length;
  let j = b.length;
  
  while (i > 0 || j > 0) {
    if (i > 0 && j > 0 && a[i - 1] === b[j - 1]) {
      diff.unshift({ type: 'equal', value: a[i - 1] });
      i--;
      j--;
    } else if (j > 0 && (i === 0 || dp[i][j - 1] >= dp[i - 1][j])) {
      diff.unshift({ type: 'insert', value: b[j - 1] });
      j--;
    } else {
      diff.unshift({ type: 'delete', value: a[i - 1] });
      i--;
    }
  }
  
  // changeã¸ã®ãƒãƒ¼ã‚¸ã¯ã—ãªã„ - delete/insertã®ã¾ã¾è¿”ã™
  return diff;
}

// HTMLã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// ãƒˆãƒ¼ã‚¯ãƒ³å€¤ã‚’å®‰å…¨ã«æ–‡å­—åˆ—åŒ–ï¼ˆ[object Object] å¯¾ç­– / é…åˆ—ãƒ»ãƒˆãƒ¼ã‚¯ãƒ³é…åˆ—ã‚‚è¨±å®¹ï¼‰
function safeStringify(value) {
  try {
    const seen = new WeakSet();
    return JSON.stringify(value, (k, v) => {
      if (typeof v === 'bigint') return v.toString();
      if (typeof v === 'object' && v !== null) {
        if (seen.has(v)) return '[Circular]';
        seen.add(v);
      }
      return v;
    });
  } catch (_) {
    // æœ€å¾Œã®ä¿é™ºã€‚ã“ã“ãŒèµ°ã£ã¦ã‚‚ "[object Object]" ã‚’å‡ºã•ãªã„ã€‚
    try { return String(value); } catch { return '[Object]'; }
  }
}

// ãƒˆãƒ¼ã‚¯ãƒ³ã® value ã‚’ã€Œå¿…ãšæ–‡å­—åˆ—ã€ã«ã™ã‚‹ï¼ˆ[object Object] ã‚’é¿ã‘ã‚‹ï¼‰
function tokenValueToString(value, _depth = 0) {
  // value ã¯æ–‡å­—åˆ—ãŒåŸºæœ¬ã ãŒã€å®Ÿè£…å¤‰æ›´ã‚„å·®åˆ†ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®æˆ»ã‚Šå€¤ã«ã‚ˆã£ã¦
  // é…åˆ—/ãƒˆãƒ¼ã‚¯ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ··ã–ã‚‹ã“ã¨ãŒã‚ã‚‹ã€‚
  // ã“ã“ã§ã€Œç¢ºå®Ÿã«è¡¨ç¤ºç”¨ã®æ–‡å­—åˆ—ã€ã«è½ã¨ã—è¾¼ã‚€ï¼ˆ[object Object] ã‚’å‡ºã•ãªã„ï¼‰ã€‚
  if (_depth > 6) return '';
  if (value === null || value === undefined) return '';
  const t = typeof value;
  if (t === 'string') return value;
  if (t === 'number' || t === 'boolean' || t === 'bigint') return String(value);

  // é…åˆ—ï¼ˆä¾‹: ãƒˆãƒ¼ã‚¯ãƒ³é…åˆ— / æ–‡å­—åˆ—é…åˆ— / ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé…åˆ—ï¼‰
  if (Array.isArray(value)) {
    let out = '';
    for (let i = 0; i < value.length; i++) {
      out += tokenValueToString(value[i], _depth + 1);
    }
    return out;
  }

  // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆä¾‹: {type, value} / Intl.Segmenter ã® segment / ç‹¬è‡ªæ§‹é€ ï¼‰
  if (t === 'object') {
    // å…¸å‹: { type: 'equal'|'insert'|'delete'|'newline', value: '...' }
    if (Object.prototype.hasOwnProperty.call(value, 'value')) {
      return tokenValueToString(value.value, _depth + 1);
    }
    // Intl.Segmenter ã® segment ã‚„ã€ã‚ã‚ŠãŒã¡ãªãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰å
    if (typeof value.segment === 'string') return value.segment;
    if (typeof value.text === 'string') return value.text;
    if (typeof value.str === 'string') return value.str;
    if (typeof value.line === 'string') return value.line;
    if (typeof value.raw === 'string') return value.raw;

    // Stringã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç­‰: valueOf ãŒæ–‡å­—åˆ—ãªã‚‰ãã‚Œã‚’æ¡ç”¨
    try {
      const v = (typeof value.valueOf === 'function') ? value.valueOf() : null;
      if (typeof v === 'string') return v;
    } catch (e) {}

    // toString ãŒæœ‰ç”¨ãªå ´åˆï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã® "[object Object]" ã¯é™¤å¤–ï¼‰
    try {
      const s = (typeof value.toString === 'function') ? value.toString() : null;
      if (typeof s === 'string' && s !== '[object Object]') return s;
    } catch (e) {}

    // ã‚ˆãã‚ã‚‹å…¥ã‚Œå­ï¼ˆvalue / token / segment ãªã©ï¼‰
    const candidates = ['value','token','segment','text','str','s','line','raw'];
    for (const k of candidates) {
      if (Object.prototype.hasOwnProperty.call(value, k)) {
        const out = tokenValueToString(value[k]);
        if (typeof out === 'string' && out !== '[object Object]') return out;
      }
    }

    // æœ€å¾Œã®æ‰‹æ®µ: å¾ªç’°å‚ç…§ã§ã‚‚è½ã¡ãªã„ stringify
    try {
      const seen = new WeakSet();
      return JSON.stringify(value, (k, v) => {
        if (typeof v === 'object' && v !== null) {
          if (seen.has(v)) return '[Circular]';
          seen.add(v);
        }
        if (typeof v === 'bigint') return v.toString();
        return v;
      });
    } catch (e) {
      return Object.prototype.toString.call(value);
    }
  }

  // function / symbol ãªã©
  try { return String(value); } catch (e) { return ''; }
}


// ã€Œæ¯”è¼ƒå‡¦ç†ã«å…¥ã‚Œã‚‹å‰ã€ç”¨: è¡¨ç¤ºç”¨ã«å¼·åˆ¶æ–‡å­—åˆ—åŒ–ï¼ˆ[object Object] ã‚’æ ¹çµ¶ï¼‰
function toPlainString(v) {
  return tokenValueToString(v);
}
// è¡Œåˆ†å‰²ï¼ˆæœ«å°¾æ”¹è¡Œã‚‚ä¿æŒ: "a\n" -> ["a",""]ï¼‰
function splitLinesKeepEmpty(text) {
  // ã“ã“ã§ã¯ compare() ã§æ”¹è¡Œæ­£è¦åŒ–æ¸ˆã¿ï¼ˆ\ré™¤å»ï¼‰ã‚’å‰æ
  // splitã¯æœ«å°¾ãŒ"\n"ãªã‚‰æœ€å¾Œã«ç©ºè¦ç´ ã‚’ä½œã‚‹ã®ã§ã€ãã®ã¾ã¾åˆ©ç”¨ã™ã‚‹
  return text.split('\n');
}

// token diff ã®çµæœï¼ˆequal/delete/insertï¼‰ã‚’ã€Œ1è¡Œåˆ†ã®A/Bãƒˆãƒ¼ã‚¯ãƒ³ã€ã«å¤‰æ›
function diffTokensToRowTokens(diffTokens) {
  const aTokens = [];
  const bTokens = [];
  for (const d of diffTokens) {
    if (d.type === 'equal') {
      aTokens.push({ type: 'equal', value: d.value });
      bTokens.push({ type: 'equal', value: d.value });
    } else if (d.type === 'delete') {
      aTokens.push({ type: 'delete', value: d.value });
    } else if (d.type === 'insert') {
      bTokens.push({ type: 'insert', value: d.value });
    }
  }
  return { aTokens, bTokens };
}

// ãƒ†ã‚­ã‚¹ãƒˆå…¨ä½“ã‚’ã€Œè¡Œå˜ä½ã€ã§LCSå·®åˆ† â†’ è¡Œã”ã¨ã«ï¼ˆå¿…è¦ãªã‚‰è¡Œå†…ã‚‚ï¼‰å·®åˆ†åŒ–ã—ã¦ rows ã‚’ä½œã‚‹
function buildRowsByLines(textA, textB) {
  const rows = [];
  const linesA = splitLinesKeepEmpty(textA).map(toPlainString);
  const linesB = splitLinesKeepEmpty(textB).map(toPlainString);

  const lineDiff = generateDiff(linesA, linesB);

  function pushRow(aTokens, bTokens, opts) {
    rows.push({
      a: { tokens: aTokens || [], isEmpty: !!(opts && opts.aEmpty) },
      b: { tokens: bTokens || [], isEmpty: !!(opts && opts.bEmpty) }
    });
  }

  // è¡ŒåŒå£«ã®ã€Œè¿‘ã•ã€ã‚’å‡ºã™ãŸã‚ã®æ­£è¦åŒ–ï¼ˆæ¯”è¼ƒç”¨ï¼‰
  function _normLineForMatch(s) {
    if (s == null) return '';
    // æœ«å°¾ç©ºç™½ã¯æ¯”è¼ƒå¯¾è±¡ã«å«ã‚ã‚‹ï¼ˆå·®åˆ†ã¨ã—ã¦å‡ºã—ãŸã„ï¼‰ã®ã§trimEndã¯ã—ãªã„
    // ãŸã ã—æ¯”è¼ƒã®æºã‚Œã‚’æ¸›ã‚‰ã™ãŸã‚ã€é€£ç¶šç©ºç™½ã¯1ã¤ã«ç¸®ç´„ã—ã¦ãŠã
    return String(s).replace(/\r/g, '').replace(/[ \t]+/g, ' ').toLowerCase();
  }

  function _bigrams(s) {
    const out = [];
    for (let i = 0; i + 1 < s.length; i++) out.push(s.slice(i, i + 2));
    return out;
  }

  function _diceSimilarity(a, b) {
    if (a === b) return 1;
    if (!a || !b) return 0;
    const A = _bigrams(a);
    const B = _bigrams(b);
    if (A.length === 0 || B.length === 0) return 0;

    const m = new Map();
    for (const x of A) m.set(x, (m.get(x) || 0) + 1);

    let inter = 0;
    for (const y of B) {
      const c = m.get(y) || 0;
      if (c > 0) {
        inter++;
        m.set(y, c - 1);
      }
    }
    return (2 * inter) / (A.length + B.length);
  }

  function _lineSimilarity(aLine, bLine) {
    // ç©ºè¡Œã¯ã€Œæ”¹è¡Œã®å­˜åœ¨ã€ãã®ã‚‚ã®ãªã®ã§ã€ç©ºè¡Œã¨éç©ºè¡ŒãŒãƒãƒƒãƒã—ãªã„ã‚ˆã†ã«ã™ã‚‹
    const aEmpty = (aLine === '');
    const bEmpty = (bLine === '');
    if (aEmpty && bEmpty) return 1;
    if (aEmpty !== bEmpty) return -1; // çµ¶å¯¾ã«ãƒšã‚¢ãƒªãƒ³ã‚°ã•ã›ãªã„

    const a = _normLineForMatch(aLine);
    const b = _normLineForMatch(bLine);
    if (a === b) return 1;
    return _diceSimilarity(a, b);
  }

  // deleteÃ—N ã¨ insertÃ—M ã‚’ã€ã§ãã‚‹ã ã‘ã€Œä¼¼ã¦ã„ã‚‹è¡ŒåŒå£«ã€ã§ãƒšã‚¢ã«ã™ã‚‹
  // DPã§æœ€å°ã‚³ã‚¹ãƒˆæ•´åˆ—ï¼ˆã‚®ãƒ£ãƒƒãƒ—è¨±å¯ï¼‰
  function _alignReplaceBlock(delLines, insLines) {
    const n = delLines.length;
    const m = insLines.length;

    const gap = 0.65; // ã‚®ãƒ£ãƒƒãƒ—ã®ã‚³ã‚¹ãƒˆï¼ˆå°ã•ã™ãã‚‹ã¨ä½•ã§ã‚‚ã‚®ãƒ£ãƒƒãƒ—ã«ãªã‚Šã€ã§ã‹ã™ãã‚‹ã¨å¤‰ãªãƒãƒƒãƒã‚’ã™ã‚‹ï¼‰
    const BIG = 9999;

    const dp = Array.from({ length: n + 1 }, () => Array(m + 1).fill(0));
    const bt = Array.from({ length: n + 1 }, () => Array(m + 1).fill(0)); // 1=match 2=del-gap 3=ins-gap

    dp[0][0] = 0;
    for (let i = 1; i <= n; i++) { dp[i][0] = dp[i - 1][0] + gap; bt[i][0] = 2; }
    for (let j = 1; j <= m; j++) { dp[0][j] = dp[0][j - 1] + gap; bt[0][j] = 3; }

    for (let i = 1; i <= n; i++) {
      for (let j = 1; j <= m; j++) {
        const sim = _lineSimilarity(delLines[i - 1], insLines[j - 1]);
        const matchCost = (sim < 0) ? BIG : (1 - sim);
        const cMatch = dp[i - 1][j - 1] + matchCost;
        const cDel = dp[i - 1][j] + gap;
        const cIns = dp[i][j - 1] + gap;

        let best = cMatch;
        let code = 1;
        if (cDel < best) { best = cDel; code = 2; }
        if (cIns < best) { best = cIns; code = 3; }

        dp[i][j] = best;
        bt[i][j] = code;
      }
    }

    const pairsRev = [];
    let i = n, j = m;
    while (i > 0 || j > 0) {
      const code = bt[i][j];
      if (code === 1) {
        pairsRev.push({ a: delLines[i - 1], b: insLines[j - 1] });
        i--; j--;
      } else if (code === 2) {
        pairsRev.push({ a: delLines[i - 1], b: null });
        i--;
      } else {
        pairsRev.push({ a: null, b: insLines[j - 1] });
        j--;
      }
    }
    pairsRev.reverse();
    return pairsRev;
  }

  // ãƒ¡ã‚¤ãƒ³ï¼šlineDiff ã‚’è¡Œãƒ†ãƒ¼ãƒ–ãƒ« rows ã«å¤‰æ›
  for (let i = 0; i < lineDiff.length; i++) {
    const item = lineDiff[i];

    if (item.type === 'equal') {
      // åŒä¸€è¡Œï¼ˆç©ºè¡Œã‚‚å«ã‚€ï¼‰
      pushRow([{ type: 'equal', value: toPlainString(item.value) }], [{ type: 'equal', value: toPlainString(item.value) }]);
      continue;
    }

    // é€£ç¶šã™ã‚‹ delete/insert ã‚’ã¾ã¨ã‚ã¦å‡¦ç†ï¼ˆreplaceãƒ–ãƒ­ãƒƒã‚¯ï¼‰
    const delBlock = [];
    const insBlock = [];
    let j = i;
    while (j < lineDiff.length && (lineDiff[j].type === 'delete' || lineDiff[j].type === 'insert')) {
      if (lineDiff[j].type === 'delete') {
        if (lineDiff[j].value !== '\n') delBlock.push(toPlainString(lineDiff[j].value));
      } else if (lineDiff[j].type === 'insert') {
        if (lineDiff[j].value !== '\n') insBlock.push(toPlainString(lineDiff[j].value));
      }
      j++;
    }

    if (delBlock.length && insBlock.length) {
      const pairs = _alignReplaceBlock(delBlock, insBlock);

      for (const p of pairs) {
        const aLine = p.a;
        const bLine = p.b;

        // ç‰‡å´ã®ã¿ï¼ˆå‰Šé™¤/æŒ¿å…¥ï¼‰
        if (aLine != null && bLine == null) {
          if (aLine === '') pushRow([{ type: 'newline-delete', value: 'â†µ' }], [], { bEmpty: true });
          else pushRow([{ type: 'delete', value: aLine }], [], { bEmpty: true });
          continue;
        }
        if (aLine == null && bLine != null) {
          if (bLine === '') pushRow([], [{ type: 'newline-insert', value: 'â†µ' }], { aEmpty: true });
          else pushRow([], [{ type: 'insert', value: bLine }], { aEmpty: true });
          continue;
        }

        // ä¸¡å´ã‚ã‚Š
        if (aLine === '' && bLine === '') {
          pushRow([{ type: 'equal', value: '' }], [{ type: 'equal', value: '' }]);
          continue;
        }

        const tokenDiff = generateDiff(tokenize(aLine), tokenize(bLine));
        const aTokens = diffTokensToRowTokens(tokenDiff, 'delete');
        const bTokens = diffTokensToRowTokens(tokenDiff, 'insert');

        pushRow(aTokens, bTokens);
      }
    } else if (delBlock.length) {
      for (const aLine of delBlock) {
        if (aLine === '') pushRow([{ type: 'newline-delete', value: 'â†µ' }], [], { bEmpty: true });
        else pushRow([{ type: 'delete', value: aLine }], [], { bEmpty: true });
      }
    } else {
      for (const bLine of insBlock) {
        if (bLine === '') pushRow([], [{ type: 'newline-insert', value: 'â†µ' }], { aEmpty: true });
        else pushRow([], [{ type: 'insert', value: bLine }], { aEmpty: true });
      }
    }

    i = j - 1;
  }

  return rows;
}



// å·®åˆ†ã‚’è¡Œã”ã¨ã«ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
function renderDiff(diff) {
  const rows = [];
  let currentA = [];
  let currentB = [];

  function pushRow(aTokens, bTokens) {
    rows.push({
      a: { tokens: aTokens, isEmpty: aTokens.length === 0 },
      b: { tokens: bTokens, isEmpty: bTokens.length === 0 }
    });
  }

  // ç¾åœ¨ã®è¡Œã‚’ç¢ºå®šï¼ˆç©ºè¡Œã‚‚å¿…è¦ãªã‚‰ forceEmpty=trueï¼‰
  function flush(forceEmpty = false) {
    if (forceEmpty) {
      pushRow([], []);
    } else if (currentA.length > 0 || currentB.length > 0) {
      pushRow(currentA, currentB);
    }
    currentA = [];
    currentB = [];
  }

  // ç‰‡å´ã ã‘ã®æ”¹è¡Œã‚’ã€Œæ”¹è¡Œãã®ã‚‚ã®ã®è¡Œã€ã¨ã—ã¦å‡ºã™
  function emitNewlineOnly(which) {
    if (which === 'A') {
      pushRow([{ type: 'newline-delete', value: 'â†µ' }], []);
    } else {
      pushRow([], [{ type: 'newline-insert', value: 'â†µ' }]);
    }
  }

  for (const item of diff) {
    const v = toPlainString(item.value);
    // === æ”¹è¡Œãƒˆãƒ¼ã‚¯ãƒ³ã¯ã€Œãã®æ™‚ç‚¹ã§å¿…ãšè¡Œå¢ƒç•Œã¨ã—ã¦å‡¦ç†ã€ã™ã‚‹ ===
    if (v === '\n') {
      if (item.type === 'equal') {
        // ä¸¡æ–¹ã®æ”¹è¡Œ: ç¾åœ¨è¡Œã‚’ç¢ºå®šã€‚ç©ºãªã‚‰ç©ºè¡Œã¨ã—ã¦å‡ºã™
        if (currentA.length === 0 && currentB.length === 0) flush(true);
        else flush(false);
      } else if (item.type === 'delete') {
        // Aã ã‘æ”¹è¡Œ: ã¾ãšç¾åœ¨è¡Œã‚’ç¢ºå®šã—ã¦ã‹ã‚‰ã€æ”¹è¡Œè¡Œã‚’å‡ºã™
        flush(false);
        emitNewlineOnly('A');
      } else if (item.type === 'insert') {
        // Bã ã‘æ”¹è¡Œ: ã¾ãšç¾åœ¨è¡Œã‚’ç¢ºå®šã—ã¦ã‹ã‚‰ã€æ”¹è¡Œè¡Œã‚’å‡ºã™
        flush(false);
        emitNewlineOnly('B');
      }
      continue;
    }

    // === é€šå¸¸ãƒˆãƒ¼ã‚¯ãƒ³ ===
    if (item.type === 'equal') {
      currentA.push({ type: 'equal', value: v });
      currentB.push({ type: 'equal', value: v });
    } else if (item.type === 'delete') {
      currentA.push({ type: 'delete', value: v });
    } else if (item.type === 'insert') {
      currentB.push({ type: 'insert', value: v });
    }
  }

  // æœ«å°¾ã®æ®‹ã‚Š
  flush(false);

  // ä½™è¨ˆãªç©ºè¡Œã®é‡è¤‡ã‚’åœ§ç¸®ï¼š
  // ã€Œæ”¹è¡Œå·®åˆ†ã‚’1è¡Œã¨ã—ã¦å‡ºã—ãŸç›´å¾Œã€ã«ã€Œç©ºè¡Œ(ä¸¡æ–¹ç©º)ã€ãŒç¶šãã‚±ãƒ¼ã‚¹ãŒã‚ã‚Šã€
  // ãã®å ´åˆã¯ç©ºè¡ŒãŒ1ã¤å¤šãè¦‹ãˆã‚‹ã®ã§ã€å¾Œç¶šã®ç©ºè¡Œã‚’å‰Šé™¤ã™ã‚‹ã€‚
  const compacted = [];
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];

    const aLen = r.a.tokens.length;
    const bLen = r.b.tokens.length;

    const aNewlineOnly = (aLen === 1 && r.a.tokens[0].type && r.a.tokens[0].type.indexOf('newline-') === 0 && bLen === 0);
    const bNewlineOnly = (bLen === 1 && r.b.tokens[0].type && r.b.tokens[0].type.indexOf('newline-') === 0 && aLen === 0);
    const isNewlineOnly = aNewlineOnly || bNewlineOnly;

    const next = (i + 1 < rows.length) ? rows[i + 1] : null;
    const nextIsBothEmpty = !!next && next.a.tokens.length === 0 && next.b.tokens.length === 0;

    compacted.push(r);

    if (isNewlineOnly && nextIsBothEmpty) {
      // æ¬¡ã®ã€Œä¸¡æ–¹ç©ºè¡Œã€ã¯è¦–è¦šçš„ã«é‡è¤‡ã™ã‚‹ã®ã§ã‚¹ã‚­ãƒƒãƒ—
      i++;
    }
  }

  return compacted;

}

function renderDiffLegacy(diff) {
  const rows = [];
  let currentA = [];
  let currentB = [];
  
  // ä¸¡æ–¹ã«æ”¹è¡ŒãŒæ¥ãŸã¨ãã ã‘flush
  function flush() {
    if (currentA.length > 0 || currentB.length > 0) {
      rows.push({
        a: { tokens: currentA, isEmpty: currentA.length === 0 },
        b: { tokens: currentB, isEmpty: currentB.length === 0 }
      });
    }
    currentA = [];
    currentB = [];
  }
  
  let pendingNewlineA = false;
  let pendingNewlineB = false;
  
  for (const item of diff) {
    if (item.type === 'equal') {
      if (item.value === '\n') {
        // ä¸¡æ–¹ã«æ”¹è¡Œ â†’ è¡Œã‚’ç¢ºå®š
        flush();
      } else {
        currentA.push({ type: 'equal', value: item.value });
        currentB.push({ type: 'equal', value: item.value });
      }
    } else if (item.type === 'delete') {
      if (item.value === '\n') {
        // Aã ã‘æ”¹è¡Œ â†’ æ”¹è¡Œãƒãƒ¼ã‚«ãƒ¼ã‚’è¿½åŠ ã—ã¦ãã®ã¾ã¾ç¶šã‘ã‚‹
        currentA.push({ type: 'newline-delete', value: 'â†µ' });
      } else {
        currentA.push({ type: 'delete', value: item.value });
      }
    } else if (item.type === 'insert') {
      if (item.value === '\n') {
        // Bã ã‘æ”¹è¡Œ â†’ æ”¹è¡Œãƒãƒ¼ã‚«ãƒ¼ã‚’è¿½åŠ ã—ã¦ãã®ã¾ã¾ç¶šã‘ã‚‹
        currentB.push({ type: 'newline-insert', value: 'â†µ' });
      } else {
        currentB.push({ type: 'insert', value: item.value });
      }
    }
  }
  
  // æœ€å¾Œã®è¡Œ
  flush();
  
  return rows;
}



// æ–‡å­—æ¯”è¼ƒï¼ˆå…¨æ–‡ãƒˆãƒ¼ã‚¯ãƒ³ï¼‰ã§ç™ºç”Ÿã—ãŒã¡ãªã€Œå˜èª + æ”¹è¡Œå·®åˆ† + å…ˆé ­ã‚¹ãƒšãƒ¼ã‚¹ä»˜ãç¶šãã€
// ï¼æœ¬æ¥ã¯åŒä¸€è¡Œãªã®ã«é€”ä¸­ã§åˆ†å‰²ã•ã‚Œã‚‹è¡¨ç¤ºã‚’ä¿®å¾©ã™ã‚‹ã€‚
// ä¾‹ï¼š A: "It will ..." / B: "\nThat will ..."
// diffãŒ "delete It" â†’ "insert \n" â†’ "insert That" â†’ "equal  will ..." ã®ä¸¦ã³ã«ãªã‚Šã€
// è¡¨ç¤ºãŒ "It" è¡Œ + "â†µ" è¡Œ + " will ..." è¡Œ ã«ãªã‚‹ã‚±ãƒ¼ã‚¹ã‚’
// "â†µ" è¡Œã‚’å‰ã¸ç§»å‹•ã—ã€"It" ã¨ " will ..." ã‚’åŒä¸€è¡Œã¸çµ±åˆã™ã‚‹ã€‚
function repairMidlineNewlineRows(rows) {
  function isNewlineOnlyRow(r) {
    const aLen = r.a.tokens.length;
    const bLen = r.b.tokens.length;
    const aNewlineOnly = (aLen === 1 && r.a.tokens[0].type && r.a.tokens[0].type.indexOf('newline-') === 0 && bLen === 0);
    const bNewlineOnly = (bLen === 1 && r.b.tokens[0].type && r.b.tokens[0].type.indexOf('newline-') === 0 && aLen === 0);
    return aNewlineOnly || bNewlineOnly;
  }

  function tokenText(tokens) {
    let s = '';
    for (const t of tokens) s += t.value || '';
    return s;
  }

  function isLeadingWordOnlyRow(r) {
    const aEmpty = r.a.tokens.length === 0;
    const bEmpty = r.b.tokens.length === 0;
    if (aEmpty === bEmpty) return false; // ç‰‡å´ã ã‘
    const tokens = aEmpty ? r.b.tokens : r.a.tokens;
    const s = tokenText(tokens);

    // æ”¹è¡Œã¯å«ã¾ãªã„
    if (s.indexOf('\n') !== -1) return false;

    // 1å˜èªï¼ˆè‹±æ•°å­—/è¨˜å·æ··åœ¨ã§ã‚‚OKï¼‰+ æœ«å°¾ã«ç©ºç™½ãŒç„¡ã„ã€ã¨ã„ã†ãã‚‰ã„ã®ç·©ã„åˆ¤å®š
    // ï¼ˆ"It" / "That" / "Will" ãªã©ã‚’æƒ³å®šï¼‰
    if (s.trim() !== s) return false; // å‰å¾Œã«ç©ºç™½ã‚’å«ã‚€ãªã‚‰å˜èªã ã‘ã§ã¯ãªã„
    if (s.length === 0) return false;
    // ã‚¹ãƒšãƒ¼ã‚¹ã‚’å«ã‚€ãªã‚‰å˜èªã ã‘ã§ã¯ãªã„
    if (s.indexOf(' ') !== -1 || s.indexOf('\t') !== -1) return false;

    return true;
  }

  function startsWithSpaceOnNonEmptySide(r) {
    const aEmpty = r.a.tokens.length === 0;
    const bEmpty = r.b.tokens.length === 0;
    // ä¸¡æ–¹ç©ºã¯é™¤å¤–
    if (aEmpty && bEmpty) return false;

    // ã©ã¡ã‚‰ã‹ã®è¡¨ç¤ºå´ãƒ†ã‚­ã‚¹ãƒˆã®å…ˆé ­ãŒã‚¹ãƒšãƒ¼ã‚¹ãªã‚‰ true
    const aText = aEmpty ? '' : tokenText(r.a.tokens);
    const bText = bEmpty ? '' : tokenText(r.b.tokens);

    const aOk = aText.length > 0 && (aText[0] === ' ' || aText[0] === '\t');
    const bOk = bText.length > 0 && (bText[0] === ' ' || bText[0] === '\t');

    return aOk || bOk;
  }

  const out = [];
  for (let i = 0; i < rows.length; i++) {
    // ãƒ‘ã‚¿ãƒ¼ãƒ³: [å˜èªã ã‘ç‰‡å´] [æ”¹è¡Œå·®åˆ†] [å…ˆé ­ã‚¹ãƒšãƒ¼ã‚¹ã§ç¶šãè¡Œ]
    if (i + 2 < rows.length && isLeadingWordOnlyRow(rows[i]) && isNewlineOnlyRow(rows[i + 1]) && startsWithSpaceOnNonEmptySide(rows[i + 2])) {
      const wordRow = rows[i];
      const nlRow = rows[i + 1];
      const contRow = rows[i + 2];

      // 1) ã¾ãšæ”¹è¡Œå·®åˆ†è¡Œã‚’å…ˆã«å‡ºã™ï¼ˆï¼æœ¬æ¥ã®è¡Œå¢ƒç•Œã¨ã—ã¦æ‰±ã†ï¼‰
      out.push(nlRow);

      // 2) å˜èªè¡Œ + ç¶šãè¡Œ ã‚’çµ±åˆ
      const merged = {
        a: { tokens: [], isEmpty: false },
        b: { tokens: [], isEmpty: false }
      };

      // Aå´
      merged.a.tokens = (wordRow.a.tokens.length ? wordRow.a.tokens.slice() : []).concat(contRow.a.tokens.length ? contRow.a.tokens.slice() : []);
      merged.b.tokens = (wordRow.b.tokens.length ? wordRow.b.tokens.slice() : []).concat(contRow.b.tokens.length ? contRow.b.tokens.slice() : []);

      merged.a.isEmpty = merged.a.tokens.length === 0;
      merged.b.isEmpty = merged.b.tokens.length === 0;

      out.push(merged);

      i += 2;
      continue;
    }

    out.push(rows[i]);
  }

  return out;
}






// è¡Œã®å†…å®¹ã‚’HTMLã«å¤‰æ›
function rowToHtml(row) {
  // ç©ºè¡Œãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼
  if (row.isEmpty) {
    return '<span class="empty-line"></span>';
  }
  
  let html = '';
  let currentType = null;
  let buffer = '';
  
  for (const item of row.tokens) {
    // æ”¹è¡Œãƒãƒ¼ã‚«ãƒ¼ã¯åˆ¥æ‰±ã„
    if (item.type === 'newline-delete' || item.type === 'newline-insert') {
      if (buffer) {
        html += wrapWithClass(buffer, currentType);
        buffer = '';
        currentType = null;
      }
      // æ”¹è¡Œãƒãƒ¼ã‚«ãƒ¼ã®å¾Œã«å®Ÿéš›ã®æ”¹è¡Œã‚’å…¥ã‚Œã‚‹
      html += '<span class="newline-marker">' + item.value + '</span></span>';
      continue;
    }
    
    if (item.type !== currentType) {
      if (buffer) {
        html += wrapWithClass(buffer, currentType);
      }
      currentType = item.type;
      buffer = escapeHtml(tokenValueToString(item.value));
    } else {
      buffer += escapeHtml(tokenValueToString(item.value));
    }
  }
  if (buffer) {
    html += wrapWithClass(buffer, currentType);
  }
  
  return html || '&nbsp;';
}

function wrapWithClass(text, type) {
  if (type === 'delete' || type === 'insert') {
    const className = type === 'delete' ? 'diff-delete' : 'diff-insert';
    // ã‚¹ãƒšãƒ¼ã‚¹ã¨ãã‚Œä»¥å¤–ã‚’åˆ†é›¢ã—ã¦å‡¦ç†
    let result = '';
    let buffer = '';
    
    for (const char of text) {
      if (char === ' ') {
        // ãƒãƒƒãƒ•ã‚¡ã«ãŸã¾ã£ãŸéã‚¹ãƒšãƒ¼ã‚¹æ–‡å­—ã‚’å‡ºåŠ›
        if (buffer) {
          result += `<span class="${className}">${buffer}</span>`;
          buffer = '';
        }
        // ã‚¹ãƒšãƒ¼ã‚¹ã¯å€‹åˆ¥ã«ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        result += `<span class="${className} space-char"> </span>`;
      } else {
        buffer += char;
      }
    }
    // æ®‹ã‚Šã®ãƒãƒƒãƒ•ã‚¡ã‚’å‡ºåŠ›
    if (buffer) {
      result += `<span class="${className}">${buffer}</span>`;
    }
    return result;
  }
  return text;
}

// çµ±è¨ˆæƒ…å ±ã‚’è¨ˆç®—
function countStats(text) {
  // CRã‚’é™¤å»
  text = text.replace(/\r/g, '');
  
  const total = text.length;
  const newlines = (text.match(/\n/g) || []).length;
  const withoutNewlines = text.replace(/\n/g, '').length;
  const spaces = (text.replace(/\n/g, '').match(/\s/g) || []).length;
  const chars = text.replace(/\s/g, '').length;
  const words = text.trim().split(/\s+/).filter(w => w.length > 0).length;
  
  return {
    chars,           // æ–‡å­—æ•°ï¼ˆç©ºç™½ãƒ»æ”¹è¡Œãªã—ï¼‰
    spaces,          // ç©ºç™½æ•°
    charsWithSpaces: withoutNewlines, // ç©ºç™½è¾¼ã¿æ–‡å­—æ•°
    newlines,        // æ”¹è¡Œæ•°
    charsTotal: total, // æ”¹è¡Œè¾¼ã¿æ–‡å­—æ•°
    words            // å˜èªæ•°
  };
}

// å·®åˆ†ã®ã¿è¡¨ç¤ºãƒˆã‚°ãƒ«
let onlyDiffMode = false;

function updateDiffOnlyButton() {
  const btn = document.getElementById('toggleDiffOnlyBtn');
  if (!btn) return;

  if (onlyDiffMode) {
    btn.textContent = 'å…¨è¡Œè¡¨ç¤º';
    btn.classList.add('is-active');
  } else {
    btn.textContent = 'å·®åˆ†ã®ã¿è¡¨ç¤º';
    btn.classList.remove('is-active');
  }
}

function toggleDiffOnly() {
  onlyDiffMode = !onlyDiffMode;
  const results = document.getElementById('results');
  if (results) {
    results.classList.toggle('diff-only-mode', onlyDiffMode);
  }
  updateDiffOnlyButton();
}

// çµæœã®ã¿è¡¨ç¤ºï¼ˆå°åˆ·ç”¨ï¼‰ãƒˆã‚°ãƒ«
let resultOnlyMode = false;

function updateResultOnlyButton() {
  const btn = document.getElementById('toggleResultOnlyBtn');
  if (!btn) return;

  if (resultOnlyMode) {
    btn.textContent = 'å…¨ä½“ã‚’è¡¨ç¤º';
    btn.classList.add('is-active');
  } else {
    btn.textContent = 'çµæœã®ã¿è¡¨ç¤º';
    btn.classList.remove('is-active');
  }
}

function toggleResultOnly() {
  resultOnlyMode = !resultOnlyMode;
  document.body.classList.toggle('result-only-mode', resultOnlyMode);
  updateResultOnlyButton();
}

// ãƒ¡ã‚¤ãƒ³æ¯”è¼ƒé–¢æ•°
function compareLine() {
  let textA = document.getElementById('textA').value;
  let textB = document.getElementById('textB').value;

  // æ”¹è¡Œã‚³ãƒ¼ãƒ‰æ­£è¦åŒ–ï¼ˆWindowsã®CRLF/CRã‚’LFã«çµ±ä¸€ï¼‰
  textA = textA.replace(/\r\n?/g, '\n');
  textB = textB.replace(/\r\n?/g, '\n');
const rows = _normalizeRowsTokens(buildRowsByLines(textA, textB));

  // line-based diff ã§ã‚‚çµ±è¨ˆç”¨ã« diff ç›¸å½“ï¼ˆå·®åˆ†æœ‰ç„¡åˆ¤å®šï¼‰ã‚’ä½œã‚‹
  const hasDiff = rows.some(r => _tTokenArray(r.a.tokens).some(t => t.type !== 'equal') || _tTokenArray(r.b.tokens).some(t => t.type !== 'equal'));
// Excelãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç”¨ã«ä¿å­˜
  lastDiffRows = rows;
  
  // Excelãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç”¨ã«ä¿å­˜
  lastDiffRows = rows;

  renderComparisonRows(rows, textA, textB, hasDiff);
}

function renderComparisonRows(rows, textA, textB, hasDiff) {
  _normalizeRowsTokens(rows);

  const tbody = document.getElementById('diffBody');
  tbody.innerHTML = '';
  // å·®åˆ†ã‚«ã‚¦ãƒ³ãƒˆç”¨
  let deleteCount = 0;
  let insertCount = 0;
  
  if (!hasDiff && textA === textB) {
    tbody.innerHTML = `
      <tr>
        <td colspan="3">
          <div class="no-diff">
            <div class="no-diff-icon">âœ“</div>
            <p>å·®åˆ†ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚ä¸¡æ–¹ã®ãƒ†ã‚­ã‚¹ãƒˆã¯åŒä¸€ã§ã™ã€‚</p>
          </div>
        </td>
      </tr>
    `;
    document.getElementById('diffStats').innerHTML = '';
  } else {
    // å·®åˆ†è¡Œã‚’è¡¨ç¤º
    let lineNum = 1;
    for (const row of rows) {
      const tr = document.createElement('tr');

      // å·®åˆ†ãŒãªã„è¡Œã¯ã‚¯ãƒ©ã‚¹ä»˜ä¸ï¼ˆå·®åˆ†ã®ã¿è¡¨ç¤ºã§éè¡¨ç¤ºã«ã™ã‚‹ï¼‰
      const rowHasDiff = _tTokenArray(row.a.tokens).some(t => t.type === 'delete' || (t.type && t.type.startsWith('newline'))) ||
                         _tTokenArray(row.b.tokens).some(t => t.type === 'insert' || (t.type && t.type.startsWith('newline')));
      if (!rowHasDiff) {
        tr.classList.add('no-diff-row');
      } else {
        // å·®åˆ†ã‚«ã‚¦ãƒ³ãƒˆ
        deleteCount += row.a.tokens.filter(t => t.type === 'delete').length;
        insertCount += row.b.tokens.filter(t => t.type === 'insert').length;
      }
      
      // è¡Œç•ªå·ã‚»ãƒ«
      const tdNum = document.createElement('td');
      tdNum.className = 'line-num';
      tdNum.textContent = lineNum++;
      tr.appendChild(tdNum);
      
      const tdA = document.createElement('td');
      const tdB = document.createElement('td');
      
      // ç©ºè¡Œãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼ã®å ´åˆã¯èƒŒæ™¯è‰²ã‚’å¤‰ãˆã‚‹
      if (row.a.isEmpty) {
        tdA.className = 'empty-cell';
      }
      if (row.b.isEmpty) {
        tdB.className = 'empty-cell';
      }
      
      tdA.innerHTML = rowToHtml(row.a);
      tdB.innerHTML = rowToHtml(row.b);
      
      tr.appendChild(tdA);
      tr.appendChild(tdB);
      tbody.appendChild(tr);
    }
    
    // å·®åˆ†ã‚«ã‚¦ãƒ³ãƒˆè¡¨ç¤º
    document.getElementById('diffStats').innerHTML = `
      <span class="stat-delete">å‰Šé™¤: ${deleteCount}</span>
      <span class="stat-insert">æŒ¿å…¥: ${insertCount}</span>
    `;
  }
  
  // çµ±è¨ˆæƒ…å ±ã‚’è¿½åŠ 
  const statsA = countStats(textA);
  const statsB = countStats(textB);
  
  const statsTr = document.createElement('tr');
  statsTr.className = 'stats-row';
  statsTr.innerHTML = `
    <td class="line-num"></td>
    <td>
      <dl class="stats">
        <div class="stats-line"><dt>æ–‡å­—æ•°</dt><dd>${statsA.chars}</dd></div>
        <div class="stats-line"><dt>ç©ºç™½æ•°</dt><dd>${statsA.spaces}</dd><dt>ç©ºç™½è¾¼ã¿æ–‡å­—æ•°</dt><dd>${statsA.charsWithSpaces}</dd></div>
        <div class="stats-line"><dt>æ”¹è¡Œæ•°</dt><dd>${statsA.newlines}</dd><dt>æ”¹è¡Œè¾¼ã¿æ–‡å­—æ•°</dt><dd>${statsA.charsTotal}</dd></div>
        <div class="stats-line"><dt>å˜èªæ•°</dt><dd>${statsA.words}</dd></div>
      </dl>
    </td>
    <td>
      <dl class="stats">
        <div class="stats-line"><dt>æ–‡å­—æ•°</dt><dd>${statsB.chars}</dd></div>
        <div class="stats-line"><dt>ç©ºç™½æ•°</dt><dd>${statsB.spaces}</dd><dt>ç©ºç™½è¾¼ã¿æ–‡å­—æ•°</dt><dd>${statsB.charsWithSpaces}</dd></div>
        <div class="stats-line"><dt>æ”¹è¡Œæ•°</dt><dd>${statsB.newlines}</dd><dt>æ”¹è¡Œè¾¼ã¿æ–‡å­—æ•°</dt><dd>${statsB.charsTotal}</dd></div>
        <div class="stats-line"><dt>å˜èªæ•°</dt><dd>${statsB.words}</dd></div>
      </dl>
    </td>
  `;
  tbody.appendChild(statsTr);
  
  // çµæœã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤º
  document.getElementById('results').classList.add('visible');
  // å·®åˆ†ã®ã¿è¡¨ç¤ºã®çŠ¶æ…‹ã‚’åæ˜ 
  document.getElementById('results').classList.toggle('diff-only-mode', onlyDiffMode);
  updateDiffOnlyButton();
  document.getElementById('results').scrollIntoView({ behavior: 'smooth', block: 'start' });

}



// äº’æ›: æ—¢å­˜ã®å‘¼ã³å‡ºã—ï¼ˆCtrl+Enterç­‰ï¼‰ã¯ compare() ã‚’ä½¿ã†å ´åˆãŒã‚ã‚‹ã®ã§ã€è¡Œæ¯”è¼ƒã¸å§”è­²

// tokens ãŒã€Œé…åˆ—ã€ã§ãªã„ã‚±ãƒ¼ã‚¹ï¼ˆæ–‡å­—åˆ—/å˜ä¸€token/undefinedï¼‰ã«å‚™ãˆã¦æ­£è¦åŒ–
function _ensureTokenArray(tokens) {
  if (Array.isArray(tokens)) return tokens;
  if (tokens == null) return [];
  // ã™ã§ã« {type,value} ã®å˜ä¸€tokenã£ã½ã„
  if (typeof tokens === 'object' && ('type' in tokens || 'value' in tokens)) return [tokens];
  // æ–‡å­—åˆ—ãªã©
  return [{ type: 'equal', value: String(tokens) }];
}

function _normalizeRowsTokens(rows) {
  if (!Array.isArray(rows)) return rows;
  for (const r of rows) {
    if (!r || !r.a || !r.b) continue;
    r.a.tokens = _ensureTokenArray(r.a.tokens);
    r.b.tokens = _ensureTokenArray(r.b.tokens);
  }
  return rows;
}

function compare() {
  return compareHybrid();
}

// æ—§æ–¹å¼: æ–‡å­—ï¼ˆãƒˆãƒ¼ã‚¯ãƒ³åˆ—ï¼‰å˜ä½ã®æ¯”è¼ƒ
function compareChars() {
  let textA = document.getElementById('textA').value;
  let textB = document.getElementById('textB').value;

  // æ”¹è¡Œã‚³ãƒ¼ãƒ‰æ­£è¦åŒ–ï¼ˆWindowsã®CRLF/CRã‚’LFã«çµ±ä¸€ï¼‰
  textA = textA.replace(/\r\n?/g, '\n');
  textB = textB.replace(/\r\n?/g, '\n');

  const tokensA = tokenize(textA);
  const tokensB = tokenize(textB);
  const diff = generateDiff(tokensA, tokensB);
  let rows = _normalizeRowsTokens(renderDiff(diff));
  rows = repairMidlineNewlineRows(rows);
  // å·®åˆ†ãŒã‚ã‚‹ã‹ï¼ˆè¡Œå˜ä½ã®è¡¨ç¤ºã§ã‚‚åˆ¤å®šã¯ rows ã§ååˆ†ï¼‰
  const hasDiff = rows.some(r => _tTokenArray(r.a.tokens).some(t => t.type !== 'equal') || _tTokenArray(r.b.tokens).some(t => t.type !== 'equal'));

  // Excelãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç”¨ã«ä¿å­˜
  lastDiffRows = rows;

  // ã“ã“ã‹ã‚‰ã¯ compareLine() ã¨åŒã˜æç”»å‡¦ç†
  renderComparisonRows(rows, textA, textB, hasDiff);
}

function compareCharsLegacy() {
  let textA = document.getElementById('textA').value;
  let textB = document.getElementById('textB').value;

  // æ”¹è¡Œã‚³ãƒ¼ãƒ‰æ­£è¦åŒ–ï¼ˆWindowsã®CRLF/CRã‚’LFã«çµ±ä¸€ï¼‰
  textA = textA.replace(/\r\n?/g, '\n');
  textB = textB.replace(/\r\n?/g, '\n');

  const tokensA = tokenize(textA);
  const tokensB = tokenize(textB);
  const diff = generateDiff(tokensA, tokensB);

  // ãƒ¬ã‚¬ã‚·ãƒ¼ï¼šè¡Œå†…ã®æ”¹è¡Œå·®åˆ†ã‚’â€œä¿®å¾©â€ã—ãªã„ï¼ˆæ˜”ã®æŒ™å‹•ã‚’å†ç¾ï¼‰
  const rows = renderDiffLegacy(diff);
const hasDiff = rows.some(r => _tTokenArray(r.a.tokens).some(t => t.type !== 'equal') || _tTokenArray(r.b.tokens).some(t => t.type !== 'equal'));

  // Excelãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ç”¨ã«ä¿å­˜
  lastDiffRows = rows;

  renderComparisonRows(rows, textA, textB, hasDiff);
}



// è¡Œæ¯”è¼ƒã¨æ–‡å­—æ¯”è¼ƒã‚’ä¸¡æ–¹èµ°ã‚‰ã›ã€è¡¨ç¤ºãŒã€Œå´©ã‚Œã¦è¦‹ãˆã‚‹ã€æ–¹ã‚’é¿ã‘ã‚‹ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰
function scoreRowsForDisplay(rows) {
  let newlineOnly = 0;
  let emptySide = 0;
  let bothEmpty = 0;
  let midlineSplit = 0;
  const total = rows.length;

  function isNewlineOnly(r) {
    const aLen = r.a.tokens.length;
    const bLen = r.b.tokens.length;
    const aNewlineOnly = (aLen === 1 && r.a.tokens[0].type && String(r.a.tokens[0].type).startsWith('newline') && bLen === 0);
    const bNewlineOnly = (bLen === 1 && r.b.tokens[0].type && String(r.b.tokens[0].type).startsWith('newline') && aLen === 0);
    return aNewlineOnly || bNewlineOnly;
  }

  function tokenText(tokens) {
    let s = '';
    for (const t of tokens) s += (t.value || '');
    return s;
  }

  for (const r of rows) {
    const aEmpty = r.a.tokens.length === 0;
    const bEmpty = r.b.tokens.length === 0;

    if (aEmpty && bEmpty) bothEmpty++;
    if (aEmpty !== bEmpty) emptySide++;
    if (isNewlineOnly(r)) newlineOnly++;
  }

  // midline splitï¼ˆå˜èª + â†µ + ç¶šãï¼‰ã‚’å¼·ã‚ã«ç½°å‰‡
  for (let i = 0; i + 2 < rows.length; i++) {
    const r0 = rows[i];
    const r1 = rows[i + 1];
    const r2 = rows[i + 2];
    if (!isNewlineOnly(r1)) continue;

    const a0only = r0.a.tokens.length > 0 && r0.b.tokens.length === 0;
    const b0only = r0.b.tokens.length > 0 && r0.a.tokens.length === 0;
    if (!(a0only || b0only)) continue;

    const s0 = tokenText(a0only ? r0.a.tokens : r0.b.tokens);
    if (s0.length === 0) continue;
    if (s0.trim() !== s0) continue;
    if (s0.indexOf(' ') !== -1 || s0.indexOf('\t') !== -1 || s0.indexOf('\n') !== -1) continue;

    const s2a = r2.a.tokens.length ? tokenText(r2.a.tokens) : '';
    const s2b = r2.b.tokens.length ? tokenText(r2.b.tokens) : '';
    const contStartsWithSpace = (s2a.length && (s2a[0] === ' ' || s2a[0] === '\t')) || (s2b.length && (s2b[0] === ' ' || s2b[0] === '\t'));
    if (!contStartsWithSpace) continue;

    midlineSplit++;
  }

  // é‡ã¿ï¼šnewline-only ãŒä¸€ç•ªã€Œå£Šã‚Œã¦è¦‹ãˆã‚‹ã€ã®ã§å¼·ã‚
  // midlineSplit ã‚‚å¼·ã‚ã«ç½°å‰‡
  const score = (newlineOnly * 8) + (midlineSplit * 10) + (emptySide * 3) + (total * 0.2) + (bothEmpty * 0.5);
  return { score, newlineOnly, midlineSplit, emptySide, bothEmpty, total };
}

function computeHybridRows(textA, textB) {
  // 1) è¡Œæ¯”è¼ƒ
  const rowsLine = buildRowsByLines(textA, textB);

  // 2) æ–‡å­—æ¯”è¼ƒï¼ˆãƒˆãƒ¼ã‚¯ãƒ³åˆ—ï¼‰â†’ è¡Œåˆ†å‰²
  const diffChars = generateDiff(tokenize(textA), tokenize(textB));
  let rowsChars = renderDiff(diffChars);
  rowsChars = repairMidlineNewlineRows(rowsChars);
  // 3) ã‚¹ã‚³ã‚¢ã§ã€Œã‚ˆã‚Šè‡ªç„¶ã«è¦‹ãˆã‚‹æ–¹ã€ã‚’é¸ã¶
  const sLine = scoreRowsForDisplay(rowsLine);
  const sChars = scoreRowsForDisplay(rowsChars);

  const useLine = (sLine.score <= sChars.score);
  const rows = useLine ? rowsLine : rowsChars;

  return {
    rows,
    method: useLine ? 'line' : 'chars',
    scores: { line: sLine, chars: sChars }
  };
}

function compareHybrid() {
  let textA = document.getElementById('textA').value;
  let textB = document.getElementById('textB').value;

  // æ”¹è¡Œã‚³ãƒ¼ãƒ‰æ­£è¦åŒ–ï¼ˆWindowsã®CRLF/CRã‚’LFã«çµ±ä¸€ï¼‰
  textA = textA.replace(/\r\n?/g, '\n');
  textB = textB.replace(/\r\n?/g, '\n');

  const result = computeHybridRows(textA, textB);

  // ãƒ‡ãƒãƒƒã‚°ã—ã‚„ã™ã„ã‚ˆã†ã«ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã¸ï¼ˆå¿…è¦ãªã‘ã‚Œã°æ¶ˆã—ã¦OKï¼‰
  console.groupCollapsed('ğŸ§© compareHybrid: scoring');
  console.log('method', result.method);
  console.log('line', result.scores.line);
  console.log('chars', result.scores.chars);
  console.groupEnd();

  const rows = _normalizeRowsTokens(result.rows);
  const hasDiff = rows.some(r => _tTokenArray(r.a.tokens).some(t => t.type !== 'equal') || _tTokenArray(r.b.tokens).some(t => t.type !== 'equal'));

  lastDiffRows = rows;
  renderComparisonRows(rows, textA, textB, hasDiff);
}



// ã‚¯ãƒªã‚¢
function clearAll() {
  document.getElementById('textA').value = '';
  document.getElementById('textB').value = '';
  document.getElementById('results').classList.remove('visible');
}

// ã‚µãƒ³ãƒ—ãƒ«ãƒ†ã‚­ã‚¹ãƒˆã‚’èª­ã¿è¾¼ã¿
function loadSample() {
  document.getElementById('textA').value = `ä¸‹è¨˜ã®æ–‡ç« ã‚’æ¯”è¼ƒã—ã¦ãã ã•ã„ã€‚
   Betty Botter bought some butter, 
But, she said, this butter's bitter;

If I put it in my batter,
It will make my batter bitter,
But a bit of better butter
Will make my batter better.
So she bought a bit of butter
Better than her bitter butter,
And she put it in her batter,
And it made her batter better,
So 'twas better Betty Botter
Bought a bit of better butter.`;

  document.getElementById('textB').value = `ä¸‹è¨˜ã®æ–‡ç« ã‚’ï¼Œï¾‹ï¾‹è¼ƒã—ã¦ãã ã¡ã„ï¼
Betty Botter bought some butter,
But, she said, the butter's bitter;
If I put it in my batter,

That will make my batter bitter.
But a bit of better butter, 
That will make my batter better.
So she bought a bit of butter
Better than her bitter butter.
And she put it in her batter,
And it made her batter better.
So it was better Betty Botter
Bought a bit of better butter.`;

  compare();
}

function loadSample2() {
  const a = `AAAAAAAAAAAAAAA     B9*************** AAAAAAA32
AAAAAAAAAAAAAAA     A9*************** AAAAAAA32
AAAAAAAAAAAAAAA     B9*************** AAAAAAA32
AAAAAAAAAAAAAAA     C9*************** AAAAAAA32
AAAAAAAAAAAAAAA     D9*************** AAAAAAA32`;
  const b = `AAAAAAAAAAAAAAA     B9*************** AAAAAAA32
AAAAAAAAAAAAAAA     B9*************** AAAAAAA32
AAAAAAAAAAAAAAA     C9*************** AAAAAAA32
CAAAAAAAAAAAAAA     D9*************** AAAAAAA32`;
  document.getElementById('textA').value = a;
  document.getElementById('textB').value = b;
  // ã™ãæ¯”è¼ƒã—ãŸã„å ´åˆã¯æ¬¡ã‚’æœ‰åŠ¹åŒ–ï¼ˆç¾çŠ¶ã¯å…¥åŠ›ã ã‘ï¼‰
  compareHybrid();
}


// å·¦å³å…¥ã‚Œæ›¿ãˆ
function swapTexts() {
  const textA = document.getElementById('textA');
  const textB = document.getElementById('textB');
  const temp = textA.value;
  textA.value = textB.value;
  textB.value = temp;
  
  // çµæœãŒè¡¨ç¤ºã•ã‚Œã¦ã„ãŸã‚‰å†æ¯”è¼ƒ
  if (document.getElementById('results').classList.contains('visible')) {
    compare();
  }
}

// ãƒ†ãƒ¼ãƒåˆ‡ã‚Šæ›¿ãˆ
function setTheme(theme) {
  document.documentElement.setAttribute('data-theme', theme === 'light' ? '' : theme);
  
  // ãƒœã‚¿ãƒ³ã®activeçŠ¶æ…‹ã‚’æ›´æ–°
  document.querySelectorAll('.theme-btn').forEach(btn => {
    btn.classList.remove('active');
  });
  document.querySelector(`.theme-btn.${theme}`).classList.add('active');
  
  // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ›´æ–°
  const url = new URL(window.location);
  if (theme === 'light') {
    url.searchParams.delete('theme');
  } else {
    url.searchParams.set('theme', theme);
  }
  window.history.replaceState({}, '', url);
}

// ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ãƒ†ãƒ¼ãƒã‚’å¾©å…ƒ
(function() {
  const urlParams = new URLSearchParams(window.location.search);
  const theme = urlParams.get('theme') || 'light';
  setTheme(theme);
  
  // å·®åˆ†ã®ã¿è¡¨ç¤ºãƒœã‚¿ãƒ³åˆæœŸåŒ–
  updateDiffOnlyButton();

  // ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
  setupDragDrop('panelA', 'textA');
  setupDragDrop('panelB', 'textB');
  
  // ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºå¾©å…ƒ
  const fontSize = urlParams.get('fontSize') || '13';
  setFontSize(fontSize, true);
  
  // è¡Œé–“å¾©å…ƒ
  const lineHeight = urlParams.get('lineHeight') || '15';
  setLineHeight(lineHeight, true);
  
  // ãƒã‚¤ãƒ©ã‚¤ãƒˆè‰²å¾©å…ƒ
  const colorDelete = urlParams.get('colorDelete');
  const colorInsert = urlParams.get('colorInsert');
  const colorChange = urlParams.get('colorChange');
  if (colorDelete) document.getElementById('colorDelete').value = '#' + colorDelete;
  if (colorInsert) document.getElementById('colorInsert').value = '#' + colorInsert;
  if (colorChange) document.getElementById('colorChange').value = '#' + colorChange;
  updateHighlightColor();
  
  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.key === 'Enter') {
      e.preventDefault();
      compare();
    }
  });
})();

// ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
function loadFile(event, textareaId) {
  const file = event.target.files[0];
  if (file) {
    if (!checkFileSize(file)) {
      event.target.value = '';
      return;
    }
    if (!checkFileType(file)) {
      event.target.value = '';
      return;
    }
    readFile(file, textareaId);
  }
}

// ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãƒã‚§ãƒƒã‚¯ï¼ˆ1MBä»¥ä¸Šã§è­¦å‘Šï¼‰
const MAX_FILE_SIZE = 1 * 1024 * 1024; // 1MB
const WARN_FILE_SIZE = 500 * 1024; // 500KB

// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å¯¾å¿œå½¢å¼
const DEFAULT_EXTENSIONS = [
  '.txt', '.md', '.html', '.htm', '.xht', '.xhtml', 
  '.css', '.js', '.json', '.xml', '.csv',
  '.java', '.properties', '.gradle', '.kt', '.scala', '.groovy', 
  '.yml', '.yaml', '.pom'
];

function getAllowedExtensions() {
  const urlParams = new URLSearchParams(window.location.search);
  const extraExts = urlParams.get('ext');
  const allowed = [...DEFAULT_EXTENSIONS];
  if (extraExts) {
    extraExts.split(',').forEach(ext => {
      const e = ext.startsWith('.') ? ext : '.' + ext;
      if (!allowed.includes(e.toLowerCase())) {
        allowed.push(e.toLowerCase());
      }
    });
  }
  return allowed;
}

function getFileExtension(filename) {
  const lastDot = filename.lastIndexOf('.');
  return lastDot >= 0 ? filename.slice(lastDot).toLowerCase() : '';
}

function checkFileType(file) {
  const ext = getFileExtension(file.name);
  const allowed = getAllowedExtensions();
  
  if (!ext) {
    return confirm('æ‹¡å¼µå­ã®ãªã„ãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚ãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦èª­ã¿è¾¼ã¿ã¾ã™ã‹ï¼Ÿ');
  }
  
  if (!allowed.includes(ext)) {
    const proceed = confirm(
      `æœªå¯¾å¿œã®å½¢å¼ã§ã™ï¼ˆ${ext}ï¼‰ã€‚\n\nãƒ†ã‚­ã‚¹ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦èª­ã¿è¾¼ã¿ã¾ã™ã‹ï¼Ÿ\n\n` +
      `OKã‚’æŠ¼ã™ã¨ã€ã“ã®URLã§ã¯æ¬¡å›ã‹ã‚‰ç¢ºèªãªã—ã§èª­ã¿è¾¼ã‚ã¾ã™ã€‚\n` +
      `ï¼ˆãƒ–ãƒƒã‚¯ãƒãƒ¼ã‚¯ã—ã¦ãŠãã¨ä¾¿åˆ©ã§ã™ï¼‰`
    );
    if (proceed) {
      addExtensionToUrl(ext);
    }
    return proceed;
  }
  return true;
}

function addExtensionToUrl(ext) {
  const url = new URL(window.location);
  const currentExts = url.searchParams.get('ext');
  const extWithoutDot = ext.startsWith('.') ? ext.slice(1) : ext;
  
  if (currentExts) {
    const extList = currentExts.split(',');
    if (!extList.includes(extWithoutDot)) {
      extList.push(extWithoutDot);
      url.searchParams.set('ext', extList.join(','));
    }
  } else {
    url.searchParams.set('ext', extWithoutDot);
  }
  window.history.replaceState({}, '', url);
}

function checkFileSize(file) {
  if (file.size > MAX_FILE_SIZE) {
    alert(`ãƒ•ã‚¡ã‚¤ãƒ«ãŒå¤§ãã™ãã¾ã™ï¼ˆ${formatFileSize(file.size)}ï¼‰ã€‚\n1MBä»¥ä¸‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚`);
    return false;
  }
  if (file.size > WARN_FILE_SIZE) {
    return confirm(`ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå¤§ãã„ã§ã™ï¼ˆ${formatFileSize(file.size)}ï¼‰ã€‚\nå‡¦ç†ã«æ™‚é–“ãŒã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚ç¶šè¡Œã—ã¾ã™ã‹ï¼Ÿ`);
  }
  return true;
}

function formatFileSize(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
  return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
}

// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã«ã‚»ãƒƒãƒˆï¼ˆSJIS/EUC-JP/UTF-8è‡ªå‹•åˆ¤åˆ¥ï¼‰
function readFile(file, textareaId) {
  const reader = new FileReader();
  reader.onload = (e) => {
    const arrayBuffer = e.target.result;
    const uint8Array = new Uint8Array(arrayBuffer);
    
    // ã‚¨ãƒ³ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚’è‡ªå‹•æ¤œå‡º
    const detectedEncoding = Encoding.detect(uint8Array);
    
    // Unicodeé…åˆ—ã«å¤‰æ›
    const unicodeArray = Encoding.convert(uint8Array, {
      to: 'UNICODE',
      from: detectedEncoding
    });
    
    // æ–‡å­—åˆ—ã«å¤‰æ›
    const text = Encoding.codeToString(unicodeArray);
    document.getElementById(textareaId).value = text;
  };
  reader.readAsArrayBuffer(file);
}

// ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
function setupDragDrop(panelId, textareaId) {
  const panel = document.getElementById(panelId);
  const textarea = document.getElementById(textareaId);
  
  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
    panel.addEventListener(eventName, (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
  });
  
  ['dragenter', 'dragover'].forEach(eventName => {
    panel.addEventListener(eventName, () => {
      panel.classList.add('drag-over');
    });
  });
  
  ['dragleave', 'drop'].forEach(eventName => {
    panel.addEventListener(eventName, () => {
      panel.classList.remove('drag-over');
    });
  });
  
  panel.addEventListener('drop', (e) => {
    const files = e.dataTransfer.files;
    if (files.length > 0) {
      const file = files[0];
      if (checkFileSize(file) && checkFileType(file)) {
        readFile(file, textareaId);
      }
    }
  });
}

// Excelãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
let lastDiffRows = null; // æ¯”è¼ƒçµæœã‚’ä¿å­˜

// ãƒˆãƒ¼ã‚¯ãƒ³åˆ—ã‹ã‚‰æ”¹è¡Œãƒˆãƒ¼ã‚¯ãƒ³ã‚’é™¤ã„ãŸãƒ—ãƒ¬ãƒ¼ãƒ³æ–‡å­—åˆ—ã‚’ç”Ÿæˆ
function tokensToPlain(tokens) {
  if (!tokens || tokens.length === 0) return '';
  let s = '';
  for (const t of tokens) {
    if (!t) continue;
    // newlineãƒˆãƒ¼ã‚¯ãƒ³ã¯å®Ÿéš›ã®æ”¹è¡Œã¨ã—ã¦å‡ºåŠ›
    if (t.type && String(t.type).startsWith('newline')) {
      s += '\n';
      continue;
    }
    s += tokenValueToString(t.value);
  }
  return s;
}

// Excelã§ç©ºç™½ã‚„è¡Œæœ«ç©ºç™½ã‚’ç¢ºå®Ÿã«å¯è¦–åŒ–ã™ã‚‹ï¼ˆåŠè§’ã‚¹ãƒšãƒ¼ã‚¹â†’â£ã€è¡Œæœ«ã«â†µã‚’ä»˜ä¸ï¼‰
function toVisibleWhitespaceLine(text) {
  const s = (text ?? '').replace(/ /g, 'â£');
  return s + 'â†µ';
}


async function downloadExcel() {
  if (!lastDiffRows) {
    alert('å…ˆã«æ¯”è¼ƒã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„');
    return;
  }
  
  const textA = document.getElementById('textA').value;
  const textB = document.getElementById('textB').value;
  const statsA = countStats(textA);
  const statsB = countStats(textB);
  
  // ãƒ¯ãƒ¼ã‚¯ãƒ–ãƒƒã‚¯ä½œæˆ
  const wb = new ExcelJS.Workbook();
  const ws = wb.addWorksheet('æ¯”è¼ƒçµæœ');
  
  // åˆ—å¹…ã¯å¾Œã§è‡ªå‹•è¨ˆç®—ã™ã‚‹ãŸã‚ã€åˆæœŸå€¤ã¯è¨­å®šã—ãªã„
  ws.columns = [
    { key: 'no' },
    { key: 'diffA' },
    { key: 'diffB' },
    { key: 'match' },
    { key: 'rawA' },
    { key: 'rawB' }
  ];
  // æ—¢å®šãƒ•ã‚©ãƒ³ãƒˆï¼ˆExcelå´ã®è¦‹ãŸç›®çµ±ä¸€ï¼‰
  for (let c = 1; c <= 12; c++) {
    ws.getColumn(c).font = { name: 'ï¼­ï¼³ ã‚´ã‚·ãƒƒã‚¯' };
  }

  
  // ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œ
  const headerRow = ws.addRow(['No', 'ãƒ†ã‚­ã‚¹ãƒˆ Aï¼ˆå·®åˆ†â£/â†µè¡¨ç¤ºï¼‰', 'ãƒ†ã‚­ã‚¹ãƒˆ Bï¼ˆå·®åˆ†â£/â†µè¡¨ç¤ºï¼‰', 'ä¸€è‡´', 'ãƒ†ã‚­ã‚¹ãƒˆ Aï¼ˆåŸæ–‡ï¼‰', 'ãƒ†ã‚­ã‚¹ãƒˆ Bï¼ˆåŸæ–‡ï¼‰']);
  headerRow.eachCell(cell => {
    cell.font = { name: 'ï¼­ï¼³ ã‚´ã‚·ãƒƒã‚¯', bold: true };
    cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFE0E0E0' } };
  });
  
  // ã‚ªãƒ¼ãƒˆãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¨­å®š
  ws.autoFilter = {
    from: { row: 1, column: 1 },
    to: { row: 1, column: 6 }
  };
  
  // è‰²å®šç¾©ï¼ˆå‰Šé™¤ãƒ»æŒ¿å…¥ã¨ã‚‚ã«èµ¤ï¼‰
  const colors = {
    delete: { font: 'FFFF0000', bg: 'FFFFD9D9' },
    insert: { font: 'FFFF0000', bg: 'FFFFD9D9' },
    newline: { font: 'FF996600', bg: 'FFFFF0D9' }
  };
  
  // æ¯”è¼ƒçµæœã‚’è¿½åŠ 
  lastDiffRows.forEach((row, index) => {
    // å·®åˆ†ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    const hasDiff = _tTokenArray(row.a.tokens).some(t => t.type === 'delete' || t.type.startsWith('newline')) ||
                    _tTokenArray(row.b.tokens).some(t => t.type === 'insert' || t.type.startsWith('newline'));
    
    const excelRow = ws.addRow([index + 1, '', '', !hasDiff, '', '']);    
    // æ”¹è¡Œå·®åˆ†è¡Œï¼ˆâ†µã ã‘ã®è¡Œï¼‰ã¯ã€UIã®ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆã‚’Excelã«ã‚‚åæ˜ 
    // â€» è¡Œå…¨ä½“ã§ã¯ãªãã€UIã§ empty-cell ã«ãªã£ã¦ã„ã‚‹ã€Œç©ºå´ã€ã ã‘ã‚’ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆã™ã‚‹
    const aLen = row.a.tokens.length;
    const bLen = row.b.tokens.length;
    const aIsNewlineOnly = (aLen === 1 && row.a.tokens[0].type && row.a.tokens[0].type.startsWith('newline') && bLen === 0);
    const bIsNewlineOnly = (bLen === 1 && row.b.tokens[0].type && row.b.tokens[0].type.startsWith('newline') && aLen === 0);

    if (aIsNewlineOnly || bIsNewlineOnly) {
      const grayFill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFA6A6A6' } };

      // åˆ—: 1 No / 2 DiffA / 3 DiffB / 4 Match / 5 RawA / 6 RawB
      // Aã«â†µãŒã‚ã£ã¦BãŒç©º => Bå´(DiffB, RawB)ã‚’ã‚°ãƒ¬ãƒ¼
      if (aIsNewlineOnly) {
        excelRow.getCell(3).fill = grayFill; // DiffB
        excelRow.getCell(6).fill = grayFill; // RawB
      }

      // Bã«â†µãŒã‚ã£ã¦AãŒç©º => Aå´(DiffA, RawA)ã‚’ã‚°ãƒ¬ãƒ¼
      if (bIsNewlineOnly) {
        excelRow.getCell(2).fill = grayFill; // DiffA
        excelRow.getCell(5).fill = grayFill; // RawA
      }
    }

    // empty-cellï¼ˆç‰‡å´ãŒç©ºã®è¡Œï¼‰ã¯ã€UIã®ã‚°ãƒ¬ãƒ¼ã‚¢ã‚¦ãƒˆã‚’Excelã«ã‚‚åæ˜ ï¼ˆè¡Œå…¨ä½“ã§ã¯ãªãç©ºå´ã®ã¿ï¼‰
    {
      const grayFill2 = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFA6A6A6' } };

      const aEmpty = row.a.tokens.length === 0;
      const bEmpty = row.b.tokens.length === 0;

      // åˆ—: 2 DiffA / 3 DiffB / 5 RawA / 6 RawB
      if (aEmpty && !bEmpty) {
        excelRow.getCell(2).fill = grayFill2; // DiffA
        excelRow.getCell(5).fill = grayFill2; // RawA
      }
      if (bEmpty && !aEmpty) {
        excelRow.getCell(3).fill = grayFill2; // DiffB
        excelRow.getCell(6).fill = grayFill2; // RawB
      }
    }

    // Noåˆ—ã®æ›¸å¼
    const noCell = excelRow.getCell(1);
    noCell.alignment = { horizontal: 'center' };
    noCell.font = { name: 'ï¼­ï¼³ ã‚´ã‚·ãƒƒã‚¯' };
    
    // Aåˆ—
    const cellA = excelRow.getCell(2);
    applyRichText(cellA, row.a.tokens, colors);
    
    // Båˆ—
    const cellB = excelRow.getCell(3);
    applyRichText(cellB, row.b.tokens, colors);

    // åŸæ–‡åˆ—ï¼ˆå·®åˆ†è£…é£¾ãªã—ï¼‰
    const rawA = tokensToPlain(row.a.tokens);
    const rawB = tokensToPlain(row.b.tokens);

    const cellRawA = excelRow.getCell(5);
    const cellRawB = excelRow.getCell(6);
    cellRawA.value = rawA;
    cellRawB.value = rawB;

    // è¦‹ã‚„ã™ã•ã®ãŸã‚ç­‰å¹…ãƒ•ã‚©ãƒ³ãƒˆ
    const monoFont = { name: 'ï¼­ï¼³ ã‚´ã‚·ãƒƒã‚¯' };
    cellRawA.font = monoFont;
    cellRawB.font = monoFont;
    
    // ä¸€è‡´åˆ¤å®šåˆ—ã®æ›¸å¼
    const matchCell = excelRow.getCell(4);
    matchCell.alignment = { horizontal: 'center' };
    matchCell.font = { name: 'ï¼­ï¼³ ã‚´ã‚·ãƒƒã‚¯' };
    
    excelRow.alignment = { wrapText: true, vertical: 'top' };
  });
  
  // çµ±è¨ˆæƒ…å ±ï¼ˆå³å´ã«é…ç½®ã€1åˆ—ç©ºã‘ã¦Håˆ—ã‹ã‚‰ï¼‰
  const statsStartCol = 8;
  
  // çµ±è¨ˆãƒ˜ãƒƒãƒ€ãƒ¼
  ws.getCell(1, statsStartCol).value = 'çµ±è¨ˆæƒ…å ±';
  ws.getCell(1, statsStartCol).font = { name: 'ï¼­ï¼³ ã‚´ã‚·ãƒƒã‚¯', bold: true };
  ws.getCell(1, statsStartCol + 1).value = 'ãƒ†ã‚­ã‚¹ãƒˆ A';
  ws.getCell(1, statsStartCol + 1).font = { name: 'ï¼­ï¼³ ã‚´ã‚·ãƒƒã‚¯', bold: true };
  ws.getCell(1, statsStartCol + 2).value = 'ãƒ†ã‚­ã‚¹ãƒˆ B';
  ws.getCell(1, statsStartCol + 2).font = { name: 'ï¼­ï¼³ ã‚´ã‚·ãƒƒã‚¯', bold: true };
  
  const statsData = [
    ['æ–‡å­—æ•°', statsA.chars, statsB.chars],
    ['ç©ºç™½æ•°', statsA.spaces, statsB.spaces],
    ['ç©ºç™½è¾¼ã¿æ–‡å­—æ•°', statsA.charsWithSpaces, statsB.charsWithSpaces],
    ['æ”¹è¡Œæ•°', statsA.newlines, statsB.newlines],
    ['æ”¹è¡Œè¾¼ã¿æ–‡å­—æ•°', statsA.charsTotal, statsB.charsTotal],
    ['å˜èªæ•°', statsA.words, statsB.words]
  ];
  
  statsData.forEach((stat, i) => {
    const rowNum = i + 2;
    ws.getCell(rowNum, statsStartCol).value = stat[0];
    ws.getCell(rowNum, statsStartCol).font = { name: 'ï¼­ï¼³ ã‚´ã‚·ãƒƒã‚¯' };
    ws.getCell(rowNum, statsStartCol + 1).value = stat[1];
    ws.getCell(rowNum, statsStartCol + 1).font = { name: 'ï¼­ï¼³ ã‚´ã‚·ãƒƒã‚¯' };
    ws.getCell(rowNum, statsStartCol + 2).value = stat[2];
    ws.getCell(rowNum, statsStartCol + 2).font = { name: 'ï¼­ï¼³ ã‚´ã‚·ãƒƒã‚¯' };
  });
  
  // åˆ—å¹…ã‚’å†…å®¹ã«åŸºã¥ã„ã¦è‡ªå‹•è¨ˆç®—
  function autoFitColumn(worksheet, columnNumber, minWidth = 8, maxWidth = 200) {
    let maxLength = 0;
    worksheet.getColumn(columnNumber).eachCell({ includeEmpty: false }, (cell) => {
      let cellLength = 0;
      if (cell.value && cell.value.richText) {
        // ãƒªãƒƒãƒãƒ†ã‚­ã‚¹ãƒˆã®å ´åˆ
        const text = cell.value.richText.map(r => r.text).join('');
        const lines = text.split('\n');
        cellLength = Math.max(...lines.map(line => {
          // å…¨è§’æ–‡å­—ã¯3ã€åŠè§’ã¯1.2ã¨ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆï¼ˆã•ã‚‰ã«ä½™è£•ã‚’æŒãŸã›ã‚‹ï¼‰
          let len = 0;
          for (const char of line) {
            len += char.charCodeAt(0) > 255 ? 3 : 1.2;
          }
          return len;
        }));
      } else if (cell.value != null) {
        const text = String(cell.value);
        const lines = text.split('\n');
        cellLength = Math.max(...lines.map(line => {
          let len = 0;
          for (const char of line) {
            len += char.charCodeAt(0) > 255 ? 3 : 1.2;
          }
          return len;
        }));
      }
      maxLength = Math.max(maxLength, cellLength);
    });
    // å¹…ã‚’è¨­å®šï¼ˆä½™ç™½+6ã‚’è¿½åŠ ï¼‰
    worksheet.getColumn(columnNumber).width = Math.min(maxWidth, Math.max(minWidth, maxLength + 6));
  }
  
  // å„åˆ—ã®å¹…ã‚’è‡ªå‹•èª¿æ•´ï¼ˆãƒ†ã‚­ã‚¹ãƒˆåˆ—ã¯æœ€å¤§å¹…ã‚’å¤§ãã‚ã«ï¼‰
  autoFitColumn(ws, 1, 6, 12);    // Noåˆ—
  autoFitColumn(ws, 2, 30, 250);  // ãƒ†ã‚­ã‚¹ãƒˆAï¼ˆå·®åˆ†ï¼‰
  autoFitColumn(ws, 3, 30, 250);  // ãƒ†ã‚­ã‚¹ãƒˆBï¼ˆå·®åˆ†ï¼‰
  autoFitColumn(ws, 4, 8, 14);    // ä¸€è‡´åˆ¤å®š
  
  // E,Fåˆ—ï¼ˆåŸæ–‡ï¼‰ã¯B,Cåˆ—ï¼ˆå·®åˆ†ï¼‰ã¨åŒã˜å¹…ã«ã™ã‚‹
  const widthB = ws.getColumn(2).width;
  const widthC = ws.getColumn(3).width;
  ws.getColumn(5).width = widthB;  // ãƒ†ã‚­ã‚¹ãƒˆAï¼ˆåŸæ–‡ï¼‰= ãƒ†ã‚­ã‚¹ãƒˆAï¼ˆå·®åˆ†ï¼‰ã¨åŒã˜
  ws.getColumn(6).width = widthC;  // ãƒ†ã‚­ã‚¹ãƒˆBï¼ˆåŸæ–‡ï¼‰= ãƒ†ã‚­ã‚¹ãƒˆBï¼ˆå·®åˆ†ï¼‰ã¨åŒã˜
  
  // çµ±è¨ˆåˆ—ã®å¹…ã‚’è‡ªå‹•èª¿æ•´
  autoFitColumn(ws, statsStartCol, 18, 30);
  autoFitColumn(ws, statsStartCol + 1, 12, 25);
  autoFitColumn(ws, statsStartCol + 2, 12, 25);
  
  // è¡Œã®é«˜ã•ã‚’å†…å®¹ã«åŸºã¥ã„ã¦è‡ªå‹•è¨ˆç®—
  ws.eachRow((row, rowNumber) => {
    let maxLines = 1;
    row.eachCell({ includeEmpty: false }, (cell) => {
      let lines = 1;
      if (cell.value && cell.value.richText) {
        const text = cell.value.richText.map(r => r.text).join('');
        lines = (text.match(/\n/g) || []).length + 1;
      } else if (cell.value != null) {
        const text = String(cell.value);
        lines = (text.match(/\n/g) || []).length + 1;
      }
      maxLines = Math.max(maxLines, lines);
    });
    // è¡Œã®é«˜ã•ã‚’è¨­å®šï¼ˆ1è¡Œã‚ãŸã‚Š15ãƒã‚¤ãƒ³ãƒˆã€æœ€å°15ï¼‰
    row.height = Math.max(15, maxLines * 15);
  });
  
  // ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
  const buffer = await wb.xlsx.writeBuffer();
  const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  const now = new Date();
  // æ—¥æœ¬æ™‚é–“ï¼ˆJSTï¼‰ã§ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’ç”Ÿæˆ
  const jstTimestamp = new Date(now.getTime() + 9 * 60 * 60 * 1000)
    .toISOString().slice(0, 19).replace(/[-:]/g, '').replace('T', '_');
  a.href = url;
  a.download = `DiffView_${jstTimestamp}.xlsx`;
  a.click();
  URL.revokeObjectURL(url);
}

// ãƒªãƒƒãƒãƒ†ã‚­ã‚¹ãƒˆã‚’é©ç”¨ï¼ˆExcelå‡ºåŠ›ç”¨ï¼šâ£/â†µ ã¯å·®åˆ†ï¼ˆinsert/delete/newlineï¼‰éƒ¨åˆ†ã ã‘ã«è¡¨ç¤ºã—ã€ãƒã‚¤ãƒ©ã‚¤ãƒˆã¯ç¶­æŒï¼‰
function applyRichText(cell, tokens, colors, baseFontSize = 11) {
  const monoName = 'ï¼­ï¼³ ã‚´ã‚·ãƒƒã‚¯';
  const smallFontSize = 5.5; // ã‚¹ãƒšãƒ¼ã‚¹è¨˜å·ç”¨ã®åŠåˆ†ã‚µã‚¤ã‚º Math.max(6, Math.round(baseFontSize / 2))

  // ç©ºã®å ´åˆã¯ç©ºæ–‡å­—ï¼ˆå·®åˆ†è¡¨ç¤ºè¨˜å·ã¯ä»˜ã‘ãªã„ï¼‰
  if (!tokens || tokens.length === 0) {
    cell.value = '';
    cell.font = { name: monoName, size: baseFontSize };
    return;
  }

  const richText = [];

  // ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¹ãƒšãƒ¼ã‚¹è¨˜å·ã§åˆ†å‰²ã—ã¦ãƒªãƒƒãƒãƒ†ã‚­ã‚¹ãƒˆã«è¿½åŠ ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°ï¼ˆã‚¹ãƒšãƒ¼ã‚¹è¨˜å·ã®ã¿åŠåˆ†ã‚µã‚¤ã‚º+ä¸‹ç·šï¼‰
  function addTextWithSmallSpaces(text, baseFont) {
    if (!text) return;
    
    // ã‚¹ãƒšãƒ¼ã‚¹è¨˜å·ï¼ˆâ£ï¼‰ã®ã¿ã§åˆ†å‰²ï¼ˆã‚¿ãƒ–è¨˜å·â‡¥ã¯é€šå¸¸ã‚µã‚¤ã‚ºï¼‰
    const parts = text.split(/(â£+)/);
    for (const part of parts) {
      if (!part) continue;
      if (/^â£+$/.test(part)) {
        // ã‚¹ãƒšãƒ¼ã‚¹è¨˜å·éƒ¨åˆ†ã¯åŠåˆ†ã®ã‚µã‚¤ã‚º+ä¸‹ç·š
        richText.push({
          text: part,
          font: { ...baseFont, size: smallFontSize, underline: true }
        });
      } else {
        // é€šå¸¸ãƒ†ã‚­ã‚¹ãƒˆï¼ˆã‚¿ãƒ–è¨˜å·å«ã‚€ï¼‰
        richText.push({
          text: part,
          font: { ...baseFont, size: baseFontSize }
        });
      }
    }
  }

  for (const token of tokens) {
    if (!token) continue;

    // æ”¹è¡Œãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆè¡Œã®è¿½åŠ /å‰Šé™¤ãªã©ã®è¡¨ç¾ï¼‰
    if (token.type === 'newline-delete' || token.type === 'newline-insert') {
      richText.push({
        text: 'â†µ\n',
        font: { name: monoName, size: baseFontSize, color: { argb: colors.newline.font } }
      });
      continue;
    }

    const raw = tokenValueToString(token.value);

    // â£ ã¨ â‡¥ ã®å¯è¦–åŒ–ã¯å·®åˆ†ï¼ˆinsert/deleteï¼‰ã®ã¿
    const txt = (token.type === 'insert' || token.type === 'delete')
      ? raw.replace(/ /g, 'â£').replace(/\t/g, 'â‡¥')
      : raw;

    if (!txt) continue;

    if (token.type === 'delete') {
      addTextWithSmallSpaces(txt, { name: monoName, color: { argb: colors.delete.font } });
    } else if (token.type === 'insert') {
      addTextWithSmallSpaces(txt, { name: monoName, color: { argb: colors.insert.font } });
    } else {
      // é€šå¸¸ãƒ†ã‚­ã‚¹ãƒˆã¯ãã®ã¾ã¾ï¼ˆã‚¹ãƒšãƒ¼ã‚¹è¨˜å·ãªã—ï¼‰
      richText.push({
        text: txt,
        font: { name: monoName, size: baseFontSize }
      });
    }
  }

  if (richText.length === 0) {
    cell.value = '';
    cell.font = { name: monoName, size: baseFontSize };
    return;
  }

  cell.value = { richText };
}

// ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºè¨­å®š
function setFontSize(size, skipUrl = false) {
  const sizeNum = parseInt(size);
  document.documentElement.style.setProperty('--diff-font-size', sizeNum + 'px');
  document.getElementById('fontSizeSlider').value = sizeNum;
  document.getElementById('fontSizeValue').textContent = sizeNum + 'px';
  
  // ãƒ†ãƒ¼ãƒ–ãƒ«ã®ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’æ›´æ–°
  const diffTable = document.querySelector('.diff-table');
  if (diffTable) {
    diffTable.style.fontSize = sizeNum + 'px';
  }
  
  if (!skipUrl) {
    updateTextSettingsUrl();
  }
}

// è¡Œé–“è¨­å®š
function setLineHeight(value, skipUrl = false) {
  const valueNum = parseInt(value);
  const lineHeight = valueNum / 10;
  document.documentElement.style.setProperty('--diff-line-height', lineHeight);
  document.getElementById('lineHeightSlider').value = valueNum;
  document.getElementById('lineHeightValue').textContent = lineHeight.toFixed(1);
  
  // ãƒ†ãƒ¼ãƒ–ãƒ«ã®è¡Œé–“ã‚’æ›´æ–°
  const diffTable = document.querySelector('.diff-table');
  if (diffTable) {
    diffTable.style.lineHeight = lineHeight;
  }
  
  if (!skipUrl) {
    updateTextSettingsUrl();
  }
}

// URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ›´æ–°
function updateTextSettingsUrl() {
  const url = new URL(window.location);
  const fontSize = parseInt(document.getElementById('fontSizeSlider').value);
  const lineHeight = parseInt(document.getElementById('lineHeightSlider').value);
  
  if (fontSize === 13) {
    url.searchParams.delete('fontSize');
  } else {
    url.searchParams.set('fontSize', fontSize);
  }
  
  if (lineHeight === 15) {
    url.searchParams.delete('lineHeight');
  } else {
    url.searchParams.set('lineHeight', lineHeight);
  }
  
  window.history.replaceState({}, '', url);
}

// ãƒ†ã‚­ã‚¹ãƒˆè¨­å®šãƒªã‚»ãƒƒãƒˆ
function resetTextSettings() {
  setFontSize(13);
  setLineHeight(15);
}

// ãƒ†ã‚­ã‚¹ãƒˆè¨­å®šãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ãƒˆã‚°ãƒ«
function toggleTextSettings() {
  const popup = document.getElementById('textPopup');
  popup.classList.toggle('visible');
}

// ãƒã‚¤ãƒ©ã‚¤ãƒˆè‰²ã®æ›´æ–°
function updateHighlightColor() {
  const colorDelete = document.getElementById('colorDelete').value;
  const colorInsert = document.getElementById('colorInsert').value;
  const colorChange = document.getElementById('colorChange').value;
  
  // CSSå¤‰æ•°ã‚’æ›´æ–°
  document.documentElement.style.setProperty('--delete', colorDelete);
  document.documentElement.style.setProperty('--delete-bg', colorDelete + '20');
  document.documentElement.style.setProperty('--insert', colorInsert);
  document.documentElement.style.setProperty('--insert-bg', colorInsert + '20');
  document.documentElement.style.setProperty('--change', colorChange);
  document.documentElement.style.setProperty('--change-bg', colorChange + '20');
  
  // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ›´æ–°
  const url = new URL(window.location);
  const defaultDelete = '#d63031';
  const defaultInsert = '#00a86b';
  const defaultChange = '#e67e22';
  
  if (colorDelete !== defaultDelete) {
    url.searchParams.set('colorDelete', colorDelete.slice(1));
  } else {
    url.searchParams.delete('colorDelete');
  }
  if (colorInsert !== defaultInsert) {
    url.searchParams.set('colorInsert', colorInsert.slice(1));
  } else {
    url.searchParams.delete('colorInsert');
  }
  if (colorChange !== defaultChange) {
    url.searchParams.set('colorChange', colorChange.slice(1));
  } else {
    url.searchParams.delete('colorChange');
  }
  window.history.replaceState({}, '', url);
}

// è‰²è¨­å®šã‚’ãƒªã‚»ãƒƒãƒˆ
function resetColors() {
  document.getElementById('colorDelete').value = '#d63031';
  document.getElementById('colorInsert').value = '#00a86b';
  document.getElementById('colorChange').value = '#e67e22';
  updateHighlightColor();
}

// ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®å¤–å´ã‚¯ãƒªãƒƒã‚¯ã§é–‰ã˜ã‚‹
document.addEventListener('click', (e) => {
  const textPopup = document.getElementById('textPopup');
  const textSettings = document.querySelector('.text-settings');
  
  if (textPopup && textSettings && !textSettings.contains(e.target)) {
    textPopup.classList.remove('visible');
  }
});

/* ============================================================================
 * ãƒ†ã‚¹ãƒˆãƒ©ãƒ³ãƒŠãƒ¼
 * - runAllTests() ã‚’å®Ÿè¡Œã™ã‚‹ã¨ã€ä¸»è¦ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆdiffâ†’renderDiffã®è¡Œåˆ†å‰²/æ”¹è¡Œå·®åˆ†/ç©ºè¡Œåœ§ç¸®ï¼‰
 *   ãŒæƒ³å®šã©ãŠã‚Šå‹•ãã‹ã‚’ä¸€æ‹¬ã§æ¤œè¨¼ã—ã¾ã™ã€‚
 * - å¤±æ•—ã—ãŸã‚‰ä¾‹å¤–ã‚’æŠ•ã’ã¾ã™ï¼ˆã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«è©³ç´°ãŒå‡ºã¾ã™ï¼‰ã€‚
 * ========================================================================== */

function _tAssert(cond, msg) {
  if (!cond) throw new Error('[TEST] ' + msg);
}

function _tEq(a, b, msg) {
  if (a !== b) throw new Error('[TEST] ' + msg + ` (expected=${JSON.stringify(b)} got=${JSON.stringify(a)})`);
}

function _tJsonEq(a, b, msg) {
  const sa = JSON.stringify(a);
  const sb = JSON.stringify(b);
  if (sa !== sb) throw new Error('[TEST] ' + msg + `\n expected=${sb}\n got     =${sa}`);
}

// æ”¹è¡Œå·®åˆ†è¡Œï¼ˆâ†µã ã‘ã®è¡Œï¼‰ã®åˆ¤å®šï¼ˆExcelå´ã¨åŒã˜æ¡ä»¶ã§æƒãˆã‚‹ï¼‰

function _tNowMs() {
  return (typeof performance !== 'undefined' && performance && typeof performance.now === 'function')
    ? performance.now()
    : Date.now();
}

function _tLogStart(name) {
  try { console.groupCollapsed(`ğŸ§ª ${name}`); } catch (e) {}
  return _tNowMs();
}

function _tLogEnd(t0) {
  const dt = _tNowMs() - t0;
  try { console.log(`â± ${dt.toFixed(2)}ms`); console.groupEnd(); } catch (e) {}
}

// rows å†…ã®ã€Œæ–‡å­—åˆ—ä»¥å¤–ã®å€¤ã€ã‚’æ¤œå‡ºï¼ˆ[object Object] ã®åŸå› èª¿æŸ»ç”¨ï¼‰
function _tFindNonStringTokenValues(rows) {
  const hits = [];
  const pushHit = (i, side, tok) => {
    hits.push({
      row: i + 1,
      side,
      type: tok && tok.type,
      valueType: tok && tok.value === null ? 'null' : typeof (tok && tok.value),
      value: tok && tok.value
    });
  };

  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    for (const sideKey of ['a', 'b']) {
      const s = r[sideKey];
      if (!s || !Array.isArray(s.tokens)) continue;
      for (const tok of s.tokens) {
        if (!tok) continue;
        const v = tok.value;
        if (typeof v === 'object' && v !== null) pushHit(i, sideKey, tok);
      }
    }
  }
  return hits;
}


function _tTokenArray(tokens) {
  if (tokens == null) return [];
  if (Array.isArray(tokens)) return tokens;
  if (typeof tokens === 'string') return [{ value: tokens }];
  if (typeof tokens === 'object') {
    if ('value' in tokens) return [tokens];
    // fallback: stringify object safely
    try { return [{ value: JSON.stringify(tokens) }]; } catch (e) { return [{ value: String(tokens) }]; }
  }
  return [{ value: String(tokens) }];
}


function _tAssertNoObjectObjectInRendered(rows, name) {
  const bad = [];
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    const a = rowToHtml(r.a);
    const b = rowToHtml(r.b);
    if (a.includes('[object Object]') || b.includes('[object Object]')) {
      bad.push({ row: i + 1, a, b });
    }
  }
  _tAssert(bad.length === 0, `${name}: rendered contains "[object Object]" at rows: ` + bad.map(x => x.row).join(','));
}
function _isNewlineOnlyRow(row) {
  const aLen = row.a.tokens.length;
  const bLen = row.b.tokens.length;
  const aIsNewlineOnly = (aLen === 1 && row.a.tokens[0].type && row.a.tokens[0].type.startsWith('newline') && bLen === 0);
  const bIsNewlineOnly = (bLen === 1 && row.b.tokens[0].type && row.b.tokens[0].type.startsWith('newline') && aLen === 0);
  return { aIsNewlineOnly, bIsNewlineOnly, isNewlineOnly: aIsNewlineOnly || bIsNewlineOnly };
}

// --- å€‹åˆ¥ãƒ†ã‚¹ãƒˆ -------------------------------------------------------------

function test_basic_no_diff_single_line() {
  const A = "Hello world";
  const B = "Hello world";
  const diff = generateDiff(tokenize(A), tokenize(B));
  const rows = renderDiff(diff);

  _tEq(rows.length, 1, "No-diff: rows.length should be 1");

  const aLine = rows[0].a.tokens.map(t => t.value).join('');
  const bLine = rows[0].b.tokens.map(t => t.value).join('');

  _tEq(aLine, A, "No-diff: A line must equal original");
  _tEq(bLine, B, "No-diff: B line must equal original");

  _tAssert(!_isNewlineOnlyRow(rows[0]).isNewlineOnly, "No-diff: must not be newline-only row");
}

function test_equal_newline_creates_empty_row() {
  const A = "A\n\nB";
  const B = "A\n\nB";
  const diff = generateDiff(tokenize(A), tokenize(B));
  const rows = renderDiff(diff);

  // æœŸå¾…: è¡Œã¯ "A", (ç©ºè¡Œ), "B" ã®3è¡Œ
  _tEq(rows.length, 3, "Equal newlines: should produce 3 rows");

  const line0A = rows[0].a.tokens.map(t => t.value).join('');
  const line0B = rows[0].b.tokens.map(t => t.value).join('');
  _tEq(line0A, "A", "Row0 should be A (A-side)");
  _tEq(line0B, "A", "Row0 should be A (B-side)");

  _tEq(rows[1].a.tokens.length, 0, "Row1 should be empty A");
  _tEq(rows[1].b.tokens.length, 0, "Row1 should be empty B");

  const line2A = rows[2].a.tokens.map(t => t.value).join('');
  const line2B = rows[2].b.tokens.map(t => t.value).join('');
  _tEq(line2A, "B", "Row2 should be B (A-side)");
  _tEq(line2B, "B", "Row2 should be B (B-side)");
}

function test_newline_only_row_when_b_has_extra_blank_line() {
  // A: "X\nY"
  // B: "X\n\nY"  (Bã ã‘ç©ºè¡ŒãŒ1ã¤å¤šã„)
  const A = "X\nY";
  const B = "X\n\nY";
  const diff = generateDiff(tokenize(A), tokenize(B));
  const rows = renderDiff(diff);

  // æœŸå¾…: "X" è¡Œ + (Bå´ã ã‘â†µè¡Œ) + "Y" è¡Œ ã®3è¡Œ
  _tEq(rows.length, 3, "B extra blank: should be 3 rows");
  _tEq(rows[0].a.tokens[0].value, "X", "Row0 X");
  const n = _isNewlineOnlyRow(rows[1]);
  _tAssert(n.isNewlineOnly, "Row1 should be newline-only");
  _tAssert(n.bIsNewlineOnly, "Row1 should be B newline-only");
  _tEq(rows[2].a.tokens[0].value, "Y", "Row2 Y");
}

function test_newline_only_row_when_a_has_extra_blank_line() {
  const A = "X\n\nY";
  const B = "X\nY";
  const diff = generateDiff(tokenize(A), tokenize(B));
  const rows = renderDiff(diff);

  _tEq(rows.length, 3, "A extra blank: should be 3 rows");
  const n = _isNewlineOnlyRow(rows[1]);
  _tAssert(n.isNewlineOnly, "Row1 should be newline-only");
  _tAssert(n.aIsNewlineOnly, "Row1 should be A newline-only");
}

function test_it_not_split_by_fake_newline() {
  // ä»¥å‰ã®ãƒã‚°: "It" ã®ç›´å¾Œã«ã€Œå­˜åœ¨ã—ãªã„æ”¹è¡Œã€ãŒå·®åˆ†è¡¨ç¤ºã«æŒŸã¾ã‚‹ã“ã¨ãŒã‚ã£ãŸã€‚
  // ã“ã“ã§ã¯ã€Œè¡Œå¢ƒç•Œã§ It ãŒåˆ†æ–­ã•ã‚Œã¦ã„ãªã„ã€ã“ã¨ã‚’æ¤œè¨¼ã™ã‚‹ã€‚
  const A = "If I put it in my batter,\nIt will make my batter bitter,\nBut a bit of better butter\n";
  const B = "If I put it in my batter,\n\nThat will make my batter bitter.\nBut a bit of better butter,\n";

  const diff = generateDiff(tokenize(A), tokenize(B));
  const rows = renderDiff(diff);

  const aLines = rows.map(r => r.a.tokens.map(t => t.value).join(''));

  // NGä¾‹: ã‚ã‚‹è¡Œã®æœ«å°¾ãŒ "It" ã§ã€æ¬¡ã®è¡Œã®å…ˆé ­ãŒ " will" / "will" ã«ãªã£ã¦ã—ã¾ã†
  for (let i = 0; i + 1 < aLines.length; i++) {
    const cur = aLines[i];
    const next = aLines[i + 1];

    if (cur.endsWith("It") && (next.startsWith(" will") || next.startsWith("will"))) {
      throw new Error('[TEST] It must not be split across rows (found boundary: "It" | "' + next.slice(0, 12) + '...")');
    }
  }

  }


function test_punctuation_not_forced_to_next_line() {
  // ä»¥å‰ã®ãƒã‚°: å¥ç‚¹/ãƒ‰ãƒƒãƒˆãŒæ¬¡ã®è¡Œã«æŠ¼ã—å‡ºã•ã‚Œã‚‹ã‚±ãƒ¼ã‚¹
  const A = "Hello.\nWorld\n";
  const B = "Hello\nWorld\n";
  const diff = generateDiff(tokenize(A), tokenize(B));
  const rows = renderDiff(diff);

  const firstA = rows[0].a.tokens.map(t => t.value).join('');
  _tEq(firstA, "Hello.", "Dot must remain on the same line in A");
}

function test_compaction_no_double_empty_after_newline_only() {
  const A = "X\nY";
  const B = "X\n\nY";
  const diff = generateDiff(tokenize(A), tokenize(B));
  const rows = renderDiff(diff);

  _tEq(rows.length, 3, "Compaction: should stay at 3 rows");
  _tAssert(!(rows[1].a.tokens.length === 0 && rows[1].b.tokens.length === 0), "Row1 must not be both-empty");
}

// --- å®Ÿè¡Œ -------------------------------------------------------------

function test_hybrid_prefers_line_on_repeated_similar_lines() {
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒå ±å‘Šã—ãŸã‚¿ã‚¤ãƒ—ï¼šä¼¼ãŸè¡ŒãŒä¸¦ã¶ï¼ˆå…¨æ–‡ãƒˆãƒ¼ã‚¯ãƒ³LCSã ã¨è¡Œå¯¾å¿œãŒå£Šã‚Œã‚„ã™ã„ï¼‰
  const A = [
    "AAAAAAAAAAAAAAA     B9*************** AAAAAAA32",
    "AAAAAAAAAAAAAAA     A9*************** AAAAAAA32",
    "AAAAAAAAAAAAAAA     B9*************** AAAAAAA32",
    "AAAAAAAAAAAAAAA     C9*************** AAAAAAA32",
    "AAAAAAAAAAAAAAA     D9*************** AAAAAAA32"
  ].join("\n");

  const B = [
    "AAAAAAAAAAAAAAA     B9*************** AAAAAAA32",
    "AAAAAAAAAAAAAAA     B9*************** AAAAAAA32",
    "AAAAAAAAAAAAAAA     C9*************** AAAAAAA32",
    "CAAAAAAAAAAAAAA     D9*************** AAAAAAA32"
  ].join("\n");

  const r = computeHybridRows(A, B);
  _tEq(r.method, 'line', "Hybrid should prefer line-based for repeated similar lines");
}

function test_hybrid_returns_rows_and_scores() {
  const A = "X\n\nY";
  const B = "X\nY";
  const r = computeHybridRows(A, B);

  _tAssert(!!r && Array.isArray(r.rows), "Hybrid result must contain rows[]");
  _tAssert(r.method === 'line' || r.method === 'chars', "Hybrid result must contain method");
  _tAssert(!!r.scores && !!r.scores.line && !!r.scores.chars, "Hybrid result must contain scores");
  _tAssert(typeof r.scores.line.score === 'number', "scores.line.score must be number");
  _tAssert(typeof r.scores.chars.score === 'number', "scores.chars.score must be number");
}

function test_scoreRows_penalizes_newline_only_more_than_empty_side() {
  // ãƒ‹ãƒ¥ãƒ¼ãƒ©ã‚¤ãƒ³-onlyãŒå¼·ãç½°å‰‡ã«ãªã‚‹è¨­è¨ˆã‹ã‚’æ¤œè¨¼ï¼ˆã‚¹ã‚³ã‚¢ã®ç›¸å¯¾é–¢ä¿‚ï¼‰
  const rows1 = [
    { a: { tokens: [{ type: 'newline-delete', value: 'â†µ' }] }, b: { tokens: [] } }
  ];
  const rows2 = [
    { a: { tokens: [{ type: 'delete', value: 'X' }] }, b: { tokens: [] } }
  ];
  const s1 = scoreRowsForDisplay(rows1);
  const s2 = scoreRowsForDisplay(rows2);

  _tAssert(s1.score > s2.score, "newline-only should be penalized more than simple empty-side");
}

function test_chars_repair_does_not_split_it_will_by_newline_move() {
  // A: ç©ºè¡Œã‚’ "If I put..." ã®å‰ã«å…¥ã‚Œã‚‹
  // B: ç©ºè¡Œã‚’ "If I put..." ã®å¾Œã«å…¥ã‚Œã‚‹
  const A = [
    "Betty Botter bought some butter,",
    "But, she said, this butter's bitter;",
    "",
    "If I put it in my batter,",
    "It will make my batter bitter,"
  ].join("\n");

  const B = [
    "Betty Botter bought some butter,",
    "But, she said, the butter's bitter;",
    "If I put it in my batter,",
    "",
    "That will make my batter bitter."
  ].join("\n");

  const diff = generateDiff(tokenize(A), tokenize(B));
  let rows = renderDiff(diff);
  rows = repairMidlineNewlineRows(rows);

  // æœŸå¾…ï¼š "It" ã ã‘ã®è¡ŒãŒå‡ºã¦ã€ãã®ç›´å¾Œã« " will" ã§å§‹ã¾ã‚‹è¡ŒãŒå‡ºã‚‹ã€ã¨ã„ã†å£Šã‚Œæ–¹ãŒãªã„ã“ã¨
  let bad = false;
  for (let i = 0; i + 1 < rows.length; i++) {
    const a0 = rows[i].a.tokens.map(t => t.value).join('');
    const a1 = rows[i + 1].a.tokens.map(t => t.value).join('');
    if (a0 === 'It' && a1.startsWith(' will')) {
      bad = true;
      break;
    }
  }
  _tAssert(!bad, "Chars diff should not split 'It will' across rows due to moved blank line");
}


function test_line_replace_block_alignment() {
  _tLogStart("test_line_replace_block_alignment");

  const A =
"    from: { row: 1, column: 1 },\n" +
"    to: { row: 1, column: 6 }\n" +
"  };\n" +
"  \n" +
"  // è‰²å®šç¾©\n" +
"  const colors = {\n" +
"    delete: { font: 'FFCC0000', bg: 'FFFFD9D9' },\n" +
"    insert: { font: 'FF006600', bg: 'FFD9FFD9' },\n" +
"    newline: { font: 'FF996600', bg: 'FFFFF0D9' }\n" +
"  };\n";

  const B =
"    from: { row: 1, column: 1 },\n" +
"    to: { row: 1, column: 6 }\n" +
"  };\n" +
"  \n" +
"  // è‰²å®šç¾©ï¼ˆå‰Šé™¤ãƒ»æŒ¿å…¥ã¨ã‚‚ã«èµ¤ï¼‰\n" +
"  const colors = {\n" +
"    delete: { font: 'FFFF0000', bg: 'FFFFD9D9' },\n" +
"    insert: { font: 'FFFF0000', bg: 'FFFFD9D9' },\n" +
"    newline: { font: 'FF996600', bg: 'FFFFF0D9' }\n" +
"  };\n";

  const rows = buildRowsByLines(A, B);

  // æœŸå¾…:
  // - "delete:" è¡Œã¯ A/B ä¸¡æ–¹ã«å­˜åœ¨ã™ã‚‹ã®ã§ã€ç‰‡å´emptyã«ãªã‚‰ãªã„ï¼ˆç½®æ›è¡Œï¼‰
  // - "insert:" è¡Œã‚‚åŒæ§˜
  // æ—§ãƒã‚°ã§ã¯ delete è¡ŒãŒ Aã®ã¿ã€insert è¡ŒãŒ Bã®ã¿ ã«ãªã‚ŠãŒã¡
  const hasDeleteReplace = rows.some(r => !r.a.isEmpty && !r.b.isEmpty &&
    _tTokenArray(r.a.tokens).some(t => t.value && t.value.includes("delete:")) &&
    _tTokenArray(r.b.tokens).some(t => t.value && t.value.includes("delete:"))
  );
  const hasInsertReplace = rows.some(r => !r.a.isEmpty && !r.b.isEmpty &&
    _tTokenArray(r.a.tokens).some(t => t.value && t.value.includes("insert:")) &&
    _tTokenArray(r.b.tokens).some(t => t.value && t.value.includes("insert:"))
  );

  _tAssert(hasDeleteReplace, '[TEST] Expected "delete:" line to be aligned as a replace-row (both sides non-empty)');
  _tAssert(hasInsertReplace, '[TEST] Expected "insert:" line to be aligned as a replace-row (both sides non-empty)');

  _tLogOk("test_line_replace_block_alignment");
}


function test_hybrid_align_shifted_similar_lines() {
  _tLogTestStart("Hybrid: align shifted similar lines (But a bit...)");

  const A = [
    "If I put it in my batter,",
    "It will make my batter bitter,",
    "But a bit of better butter",
    "Will make my batter better."
  ].join("\n");

  const B = [
    "If I put it in my batter,",
    "That will make my batter bitter.",
    "But a bit of better butter,",
    "That will make my batter better."
  ].join("\n");

  const rows = computeHybridRows(A, B);

  // Expect to find a row where BOTH sides contain "But a bit of better butter"
  let ok = false;
  for (const r of rows) {
    const a = (r.a && r.a.rawLine != null) ? String(r.a.rawLine) : tokensToPlainText(r.a.tokens || []);
    const b = (r.b && r.b.rawLine != null) ? String(r.b.rawLine) : tokensToPlainText(r.b.tokens || []);
    if (a.includes("But a bit of better butter") && b.includes("But a bit of better butter")) { ok = true; break; }
  }
  _tAssert(ok, '[TEST] Expected "But a bit of better butter" to align in the same row (A and B).');

  _tLogTestPass("Hybrid: align shifted similar lines (But a bit...)");
}



function test_no_object_object_in_line_and_hybrid() {
  const t0 = _tLogStart('no [object Object] in line/hybrid');

  const A = `ä¸‹è¨˜ã®æ–‡ç« ã‚’æ¯”è¼ƒã—ã¦ãã ã•ã„ã€‚
   Betty Botter bought some butter, 
But, she said, this butter's bitter;

If I put it in my batter,
It will make my batter bitter,
But a bit of better butter
Will make my batter better.
So she bought a bit of butter
Better than her bitter butter,
And she put it in her batter,
And it made her batter better,
So 'twas better Betty Botter
Bought a bit of better butter.`;

  const B = `ä¸‹è¨˜ã®æ–‡ç« ã‚’ï¼Œï¾‹ï¾‹è¼ƒã—ã¦ãã ã¡ã„ï¼
Betty Botter bought some butter,
But, she said, the butter's bitter;
If I put it in my batter,

That will make my batter bitter.
But a bit of better butter, 
That will make my batter better.
So she bought a bit of butter
Better than her bitter butter.
And she put it in her batter,
And it made her batter better.
So it was better Betty Botter
Bought a bit of better butter.`;

  // è¡Œæ¯”è¼ƒ
  const linesA = splitLinesKeepEmpty(A).map(toPlainString);
  const linesB = splitLinesKeepEmpty(B).map(toPlainString);
  const rowsLine = buildRowsByLines(linesA, linesB);
  _normalizeRowsTokens(rowsLine);

  const hitsLine = _tFindNonStringTokenValues(rowsLine);
  if (hitsLine.length) {
    console.warn('[TEST] non-string token values (line):', hitsLine.slice(0, 20));
  }
  _tAssert(hitsLine.length === 0, 'line: found non-string token values');
  _tAssertNoObjectObjectInRendered(rowsLine, 'line');

  // ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰æ¯”è¼ƒï¼ˆå†…éƒ¨ãƒ­ã‚¸ãƒƒã‚¯ã‚’ç›´æ¥ï¼‰
  const rowsHybrid = computeHybridRows(linesA, linesB);
  _normalizeRowsTokens(rowsHybrid);

  const hitsHybrid = _tFindNonStringTokenValues(rowsHybrid);
  if (hitsHybrid.length) {
    console.warn('[TEST] non-string token values (hybrid):', hitsHybrid.slice(0, 20));
  }
  _tAssert(hitsHybrid.length === 0, 'hybrid: found non-string token values');
  _tAssertNoObjectObjectInRendered(rowsHybrid, 'hybrid');

  _tLogEnd(t0);
}

function runAllTests() {
  test_line_replace_block_alignment();

  const tests = [
    test_basic_no_diff_single_line,
    test_equal_newline_creates_empty_row,
    test_newline_only_row_when_b_has_extra_blank_line,
    test_newline_only_row_when_a_has_extra_blank_line,
    test_it_not_split_by_fake_newline,
    test_punctuation_not_forced_to_next_line,
    test_compaction_no_double_empty_after_newline_only,
    test_hybrid_prefers_line_on_repeated_similar_lines,
    test_hybrid_align_shifted_similar_lines,
    test_hybrid_returns_rows_and_scores,
    test_scoreRows_penalizes_newline_only_more_than_empty_side,
    test_chars_repair_does_not_split_it_will_by_newline_move
  ];

  const started = performance.now();
  const results = [];

  console.group('ğŸ§ª runAllTests: start');
  console.log(`tests: ${tests.length}`);

  for (const fn of tests) {
    const name = fn.name || '(anonymous)';
    console.group(`â–¶ ${name}`);
    console.log('status: running');
    const t0 = performance.now();
    try {
      fn();
      const t1 = performance.now();
      const ms = Math.round((t1 - t0) * 1000) / 1000;
      results.push({ name, ok: true, ms });
      console.log(`status: âœ… pass (${ms} ms)`);
      console.groupEnd();
    } catch (e) {
      const t1 = performance.now();
      const ms = Math.round((t1 - t0) * 1000) / 1000;
      results.push({ name, ok: false, ms, error: String(e && e.message ? e.message : e) });
      console.error(`status: âŒ fail (${ms} ms)`);
      console.error(e);
      console.groupEnd();
      console.groupEnd();
      // å¤±æ•—ã¯å³åœæ­¢ï¼ˆåŸå› ã‚’æœ€åˆã®1ä»¶ã«çµã‚‹ï¼‰
      throw e;
    }
  }

  const total = Math.round((performance.now() - started) * 1000) / 1000;

  console.groupCollapsed(`âœ… runAllTests: all passed (${results.length}/${tests.length}) total=${total} ms`);
  for (const r of results) {
    console.log(`${r.ok ? 'âœ…' : 'âŒ'} ${r.name}: ${r.ms} ms`);
  }
  console.groupEnd();

  console.log('ğŸ§ª runAllTests: done');
  console.groupEnd();
}

window.runAllTests = runAllTests;

</script>
</body>
</html>  test_no_object_object_in_line_and_hybrid();
